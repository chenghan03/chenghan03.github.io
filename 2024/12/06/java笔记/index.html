
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 6.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>java笔记 - 阿翰</title>

  
    <meta name="description" content="# java 运行机制  .java 文件是源代码，.class 文件是字节码，javac.exe 编译源代码为字节码 每有一个类，编译后都会生成一个.class 文件  JDK JRE JVM JDK &#x3D; JRE + Java 开发工具 JRE &#x3D; JVM + 核心类库 JVM：Java virtual machine # 注意事项：  源文件的组成部分是类（class） java 应用程序入口">
<meta property="og:type" content="article">
<meta property="og:title" content="java笔记">
<meta property="og:url" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="阿翰">
<meta property="og:description" content="# java 运行机制  .java 文件是源代码，.class 文件是字节码，javac.exe 编译源代码为字节码 每有一个类，编译后都会生成一个.class 文件  JDK JRE JVM JDK &#x3D; JRE + Java 开发工具 JRE &#x3D; JVM + 核心类库 JVM：Java virtual machine # 注意事项：  源文件的组成部分是类（class） java 应用程序入口">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/C:%5CUsers%5CAhan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240815120355095.png">
<meta property="og:image" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/C:%5CUsers%5CAhan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240908205218302.png">
<meta property="og:image" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/D:%5C%E6%96%87%E6%A1%A3%5CWPS%5C543277641%5CIMG_0027.PNG">
<meta property="og:image" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/D:%5CDesktop%5C4bc77e5417f181b4c06b18ae3162ff47.png">
<meta property="article:published_time" content="2024-12-06T10:12:15.000Z">
<meta property="article:modified_time" content="2024-12-06T10:59:04.860Z">
<meta property="article:author" content="阿翰">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tchdv.cn/2024/12/06/java%E7%AC%94%E8%AE%B0/C:%5CUsers%5CAhan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240815120355095.png">
  
  
  
  <meta name="keywords" content="java">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/img/avatar.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">阿翰</div><div class="sub cap">加油</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/12/06/java%E7%AC%94%E8%AE%B0/"><span class="title">java笔记</span></a><a class="item title" href="/2024/12/03/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"><span class="title">博客迁移</span></a><a class="item title" href="/2024/04/30/think-java/"><span class="title">think_java</span></a><a class="item title" href="/2024/04/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"><span class="title">文件上传漏洞</span></a><a class="item title" href="/2024/03/28/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"><span class="title">信息收集</span></a><a class="item title" href="/2024/04/07/uploadlabs%E7%AC%94%E8%AE%B0/"><span class="title">uploadlabs笔记</span></a><a class="item title" href="/2024/03/27/sql%E6%B3%A8%E5%85%A5%E4%B9%8Bwaf%E7%BB%95%E8%BF%87/"><span class="title">sql注入之waf绕过</span></a><a class="item title" href="/2024/03/28/sql%E6%B3%A8%E5%85%A5/"><span class="title">sql注入</span></a><a class="item title" href="/2022/03/11/luckguy/"><span class="title">luckguy</span></a><a class="item title" href="/2022/04/15/2020%E5%8D%8E%E5%8D%97%E5%B8%88%E5%A4%A7CTF%E6%96%B0%E7%94%9F%E8%B5%9Bmaze/"><span class="title">2020华南师大CTF新生赛maze</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-12-06T10:12:15.000Z">2024-12-06</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-12-06T10:59:04.860Z">2024-12-06</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>java笔记</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="java运行机制"><a class="markdownIt-Anchor" href="#java运行机制">#</a> java 运行机制</h1>
<ol>
<li>.java 文件是源代码，.class 文件是字节码，javac.exe 编译源代码为字节码</li>
<li>每有一个类，编译后都会生成一个.class 文件</li>
</ol>
<p><strong>JDK JRE JVM</strong></p>
<p>JDK = JRE + Java 开发工具</p>
<p>JRE = JVM + 核心类库</p>
<p>JVM：Java virtual machine</p>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项：</h2>
<ol>
<li>源文件的组成部分是类（class）</li>
<li>java 应用程序入口是 main () 方法，固定书写格式：public static void main (String [] args) {}</li>
<li>一个源文件最多只能有一个 public 类，其他不限</li>
<li>如果源文件包含一个 public 类，那文件名必须按该类名命名</li>
<li>main 方法可以写在非 public 类，然后指定运行非 public 类，这样入口方法就是非 public 类的 main 方法</li>
</ol>
<h1 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符">#</a> 转义字符</h1>
<p>\t：制表位，对齐，固定宽度</p>
<p>\r：一个回车，对齐到第一个字并逐个替换，比如 System.out.println (“我爱你 \r 他”)，会输出他爱你</p>
<p>如果是 System.out.println (“我爱你 \r\n 他”) 就会输出两行</p>
<p>我爱你</p>
<p>他</p>
<h1 id="文档注释"><a class="markdownIt-Anchor" href="#文档注释">#</a> 文档注释</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41872247/article/details/117778467">Javadoc 写法和标签总结_javadoc 标签大全 - CSDN 博客</a></p>
<p>在方法的上面输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure>
<p>然后回车，就会自动生成一个 javadoc 格式的文档，然后就可以填内容了</p>
<p>和其他注释最主要的区别就是 javadoc 的注释可以在我们鼠标放到方法名 / 类名 / 变量名上面的时候，直接看到其内容，而双斜杠的注释不行</p>
<p>所以按照一般来说，我们会在类 / 变量 / 方法的注释中使用 javadoc 的形式，而在某段代码的注释使用双斜杠形式</p>
<h2 id="用法"><a class="markdownIt-Anchor" href="#用法">#</a> 用法</h2>
<p>javadoc -d 文件夹名 -xx -yy Demo3.java</p>
<p>假设在 d 盘且文件名为 tch，所以下面这个就是</p>
<p>javadoc -d d:\ -author -version tch.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="常用javadoc标签"><a class="markdownIt-Anchor" href="#常用javadoc标签">#</a> 常用 javadoc 标签</h2>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>标签类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>@author</td>
<td>作者标识</td>
<td>包、 类、接口</td>
</tr>
<tr>
<td>@deprecated</td>
<td>标识当前 API 已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个 API</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>指明当前文档根目录的路径</td>
<td></td>
</tr>
<tr>
<td>@exception</td>
<td>标志一个类抛出的异常</td>
<td>构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>从直接父类继承的注释</td>
<td></td>
</tr>
<tr>
<td></td>
<td>链接到某个特定的成员对应的文档中</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@param</td>
<td>方法的入参名及描述信息，如入参有特别要求，可在此注释</td>
<td>构造函数、方法</td>
</tr>
<tr>
<td>@return</td>
<td>对函数返回值的注释</td>
<td>方法</td>
</tr>
<tr>
<td>@see</td>
<td>引用，查看相关内容，如类、方法、变量等</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@serial</td>
<td>说明一个序列化属性</td>
<td></td>
</tr>
<tr>
<td>@serialData</td>
<td>说明通过 writeObject () 和 writeExternal () 方法写的数据</td>
<td></td>
</tr>
<tr>
<td>@serialField</td>
<td>说明一个 ObjectStreamField 组件</td>
<td>@</td>
</tr>
<tr>
<td>@since</td>
<td>描述文本，API 在什么程序的什么版本后开发支持</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@throws</td>
<td>构造函数或方法所会抛出的异常</td>
<td>构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>显示常量的值，该常量必须是 static 属性</td>
<td>静态值域</td>
</tr>
<tr>
<td>@version</td>
<td>版本号</td>
<td>包、 类、接口</td>
</tr>
<tr>
<td><strong>对两种标签格式的说明：</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>@tag 格式的标签（不被 { } 包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。</li>
<li>{@tag} 格式的标签（由 { } 包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中</li>
</ul>
<h1 id="数据类型转换细节"><a class="markdownIt-Anchor" href="#数据类型转换细节">#</a> 数据类型转换细节</h1>
<h2 id="自动转换"><a class="markdownIt-Anchor" href="#自动转换">#</a> 自动转换</h2>
<ol>
<li>（byte short）和 char 之间不会相互自动转换</li>
<li>byte short char 他们三者可以计算，在计算时首先转换为 int 类型
<ul>
<li>哪怕是相同的类型，比如 byte 和 byte 计算，他也会先转成 int 再计算，结果类型也就是 int，另外两个也是的</li>
</ul>
</li>
<li>布尔类型不参与类型自动转换</li>
</ol>
<h2 id="强制转换"><a class="markdownIt-Anchor" href="#强制转换">#</a> 强制转换</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123.5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>)a;</span><br><span class="line"><span class="comment">//字符串强制转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(a);</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseDouble(a);</span><br><span class="line"><span class="type">long</span> <span class="variable">num3</span> <span class="operator">=</span> Integer.parseLong(a);</span><br><span class="line"><span class="comment">//其他类型以此类推</span></span><br><span class="line"><span class="comment">//而char类型的强制转换就只会截取字符串的第一个字符 </span></span><br><span class="line">System.out.println(a.charAt(<span class="number">0</span>));<span class="comment">//输出a的第一个字符</span></span><br></pre></td></tr></table></figure>
<h1 id="位移运算"><a class="markdownIt-Anchor" href="#位移运算">#</a> 位移运算</h1>
<ol>
<li>算术右移 &gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位，可以理解为右移一位就除以 2</li>
<li>算术左移 &lt;&lt;：符号位不变，低位补 0，可以理解为左移一位就乘以 2</li>
<li>'&gt;&gt;&gt;' 逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补 0</li>
</ol>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h1>
<ol>
<li>
<p>不知道值的时候比如需要输入就用动态，已知数组的值比如用来加密的表就用静态</p>
</li>
<li>
<p>数组如果未赋值，每个类型都有其对应的默认值：数字类型全是 0 或 0.0（浮点），char 为 \u000，boolean 为 false，String 为 null</p>
</li>
<li>
<p>数组的赋值为地址复制，如果只想值复制的话，可以先分配空间后再用遍历赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">arr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr1.length;i++) &#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="动态初始化"><a class="markdownIt-Anchor" href="#动态初始化">#</a> 动态初始化</h2>
<p>int [] arr= new arr [10]; 或者 int arr [] = new arr [10];</p>
<p>也可以先声明再分配空间：</p>
<p>int arr[];</p>
<p>arr = new int[10]；</p>
<h2 id="静态初始化"><a class="markdownIt-Anchor" href="#静态初始化">#</a> 静态初始化</h2>
<p>int tch[] = {1，2，3，4，5};</p>
<h2 id="扩容"><a class="markdownIt-Anchor" href="#扩容">#</a> 扩容</h2>
<p>用新数组扩容并转移地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">newarr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    newarr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">newarr[newarr.length-<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">arr = newarr;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组">#</a> 二维数组</h2>
<ul>
<li>
<p>java 中二维数组的列数可以不确定，第一个一维可以有五个元素，第二个一维可以只有 3 个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];<span class="comment">//在这里给每个一维数组分配长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;<span class="comment">//静态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//动态</span></span><br><span class="line"><span class="comment">//或者先声明</span></span><br><span class="line"><span class="type">int</span> arr[][];</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//还可以这样</span></span><br><span class="line"><span class="type">int</span>[] arr[] = <span class="keyword">new</span> <span class="title class_">arr</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//这种方式可以同时定义一个一维和二维</span></span><br><span class="line"><span class="type">int</span>[] arr1,arr2[];</span><br></pre></td></tr></table></figure>
<h1 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象">#</a> 类与对象</h1>
<h2 id="创建规则"><a class="markdownIt-Anchor" href="#创建规则">#</a> 创建规则</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">	String name;</span><br><span class="line">	int age;</span><br><span class="line">	String color;</span><br><span class="line">&#125;</span><br><span class="line">//使用时，先实例化再引用</span><br><span class="line">Cat cat1 = new Cat();//cat1就是对象名 </span><br><span class="line">cat1.name = &quot;小白&quot;;</span><br><span class="line">cat1.age = 3;</span><br><span class="line">cat1.color = &quot;白色&quot;;</span><br><span class="line">//如果不对类中的属性赋值的话，就是默认值，默认值规则和数组一样</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的复制是指向地址的</li>
</ul>
<h2 id="类和对象的内存分配机制"><a class="markdownIt-Anchor" href="#类和对象的内存分配机制">#</a> 类和对象的内存分配机制</h2>
<ul>
<li>栈：一般存放基本数据类型</li>
<li>堆：存放对象（Cat cat，数组等）</li>
<li>方法区：常量池（常量，比如字符串），类加载信息</li>
</ul>
<h2 id="创建对象的流程简单分析"><a class="markdownIt-Anchor" href="#创建对象的流程简单分析">#</a> 创建对象的流程简单分析</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">p.age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>先加载 Person 类信息（属性和方法信息，只加载一次）</li>
<li>在堆中分配空间，进行默认初始化（默认值）</li>
<li>把地址赋给 p，让 p 指向对象</li>
<li>进行指定的初始化，比如上面代码的赋值</li>
</ol>
<h1 id="方法"><a class="markdownIt-Anchor" href="#方法">#</a> 方法</h1>
<h2 id="如何创建和引用"><a class="markdownIt-Anchor" href="#如何创建和引用">#</a> 如何创建和引用</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tch</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		  <span class="type">Personn</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//分配空间</span></span><br><span class="line">		  p1.speak();<span class="comment">//引用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;<span class="comment">//无传入值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m a good man&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法调用过程"><a class="markdownIt-Anchor" href="#方法调用过程">#</a> 方法调用过程</h2>
<ol>
<li>程序执行到方法时，会开辟一个独立空间（栈空间）</li>
<li>当方法执行完毕，或者执行到 return 语句时，就会返回</li>
<li>返回到调用方法的地方</li>
<li>返回后继续执行方法后面的代码</li>
<li>当 main 方法 (栈) 执行完毕后整个程序退出</li>
</ol>
<h2 id="一些细节"><a class="markdownIt-Anchor" href="#一些细节">#</a> 一些细节</h2>
<ol>
<li>有多个返回值的时候可以用数组</li>
<li>void 类型不可以 return 值，但可以只写 return</li>
<li>同类中的方法可以直接调用，不用创建对象</li>
</ol>
<h2 id="传参机制"><a class="markdownIt-Anchor" href="#传参机制">#</a> 传参机制</h2>
<ol>
<li>基本数据类型的传参就是拷贝</li>
<li>引用数据类型的传参是指向地址</li>
</ol>
<h1 id="递归"><a class="markdownIt-Anchor" href="#递归">#</a> 递归</h1>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量时独立的，不会相互影响</li>
<li>如果方法中使用的是引用类型变量，就会共享该引用类型的数据</li>
</ol>
<p>递归主要是对于规律的应用吧，只要微操作和超级操作是对的，就不要去想里面的过程是怎么样，两个操作都是正确的，其实也就互相证明了这个程序是对的，要相信它可以实现我们的要求</p>
<h1 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载">#</a> 方法重载</h1>
<p>java 中允许同一个类中有多个同名方法的存在，但形参列表要不一样。重载减轻了起名和记名的麻烦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如最基础的</span></span><br><span class="line">System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>方法名要一致</li>
<li>形参列表必须不同，类型、个数、顺序等</li>
<li>返回类型：无要求</li>
</ol>
<h1 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数">#</a> 可变参数</h1>
<p>java 允许将同一个类中，多个同名同功能但参数个数不同的方法，封装成一个方法。可通过可变参数实现</p>
<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法">#</a> 基本语法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回类型 方法名(数据类型...形参名) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用可变参数时，可以把参数当作数组来使用，也可以把数组传进来</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节"><a class="markdownIt-Anchor" href="#细节">#</a> 细节</h2>
<ol>
<li>可变参数的个数可以是 0 也可以是任意多个</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后，且一个形参列表中只能有一个可变参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b,<span class="type">char</span>... c)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="作用域"><a class="markdownIt-Anchor" href="#作用域">#</a> 作用域</h1>
<ol>
<li>java 中主要的变量就是属性（成员变量）和局部变量</li>
<li>局部变量一般是指在成员方法中定义的变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//age就是全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里的n和name就是局部变量</span></span><br><span class="line">        <span class="comment">//n和name的作用域就在cry中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(age);<span class="comment">//这里可以用age但不能用cry中的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java 中作用域的分类：</li>
</ul>
<p>全局变量：也就是属性，作用域为整个类体</p>
<p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p>
<ul>
<li>
<p>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值</p>
</li>
<li>
<p>局部变量和属性（全局变量）可以重名，访问时遵循就近原则</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;tom&quot;</span>;<span class="comment">//这行在就会输出tom，反之输出jack</span></span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以跨类调用全局变量</li>
<li>全局变量可以加修饰符，局部不可以</li>
</ul>
<h1 id="构造器方法"><a class="markdownIt-Anchor" href="#构造器方法">#</a> 构造器 / 方法</h1>
<ul>
<li>构造器的修饰符可以默认，也可以是 public，protected，private</li>
<li>构造器没有返回值</li>
<li>方法名和类名必须一样</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器的调用系统完成，在创建对象时，系统会自动调用该类的构造器完成对对象的<strong>初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">constructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">//new一个对象时，直接通过构造器指定名字和年龄</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tch&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//构造器的名称和类名要一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">        name = pName;</span><br><span class="line">        age = pAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造器也可以重载，因为构造器本身也是方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">constructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tch&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tchhhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">        name = pName;</span><br><span class="line">        age = pAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName)</span> &#123;<span class="comment">//只有一个形参</span></span><br><span class="line">        name = pName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序员如果没定义构造器，系统会自动生成一个默认无参构造器</li>
<li>有参构造器在 new 新对象的时候要提供参数，无参构造器不需要，相当于给了多种 new 新对象的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">/*    Person(); &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;<span class="comment">//这里是空的，但实际上有一个默认的构造器，可以通过反编译出来，javap</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一旦定义了自己的构造器，默认的构造器就被覆盖了，不能再使用默认无参构造器，除非显式地定义一下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    public Person(String pName, int pAge) &#123;</span><br><span class="line">    //...</span><br><span class="line">    &#125;</span><br><span class="line">    Person() &#123;//显式的定义一下</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字">#</a> this 关键字</h1>
<p>在这里定义构造器的时候，如果可以把形参定义为 String name, int age 看上去就会更简介，但是如果这样定义就会导致 name 的值为空，这里可以用 this 来解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String dName, <span class="type">int</span> dAge)</span> &#123;</span><br><span class="line">		name = dName;</span><br><span class="line">		age = dAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 虚拟机会给每个对象分配 this，代表当前对象，哪个对象调用 this 就指的是哪个对象的地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>this 不能在类定义的外部使用，只能在类定义的方法中使用</li>
<li>访问成员方法的语法：this. 方法名 (参数列表)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        f1();</span><br><span class="line">        <span class="built_in">this</span>.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问构造器语法:this (参数列表)；只能在构造器中使用（只能在构造器中访问另一个构造器）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果要在构造器中用this访问另一个构造器</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;tch&quot;</span>,<span class="number">21</span>);<span class="comment">//this语句必须要在第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包"><a class="markdownIt-Anchor" href="#包">#</a> 包</h1>
<p>包实际上就是创建不同的文件夹来保存类文件</p>
<h2 id="作用"><a class="markdownIt-Anchor" href="#作用">#</a> 作用：</h2>
<ul>
<li>区分相同名字的类</li>
<li>当类很多时，可以很好的管理类</li>
<li>控制访问范围</li>
</ul>
<h2 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范">#</a> 命名规范</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般的命名规范</span></span><br><span class="line">com.公司名.项目名.业务模块名</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line">com.sina.crm.user<span class="comment">//用户模块</span></span><br><span class="line">com.sina.crm.order<span class="comment">//订单模块</span></span><br><span class="line">com.sina.crm.utils<span class="comment">//工具类</span></span><br></pre></td></tr></table></figure>
<h2 id="常用的包"><a class="markdownIt-Anchor" href="#常用的包">#</a> 常用的包</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*		<span class="comment">//lang包时基本包，默认引入</span></span><br><span class="line">java.util.*		<span class="comment">//系统提供的工具，工具类，使用Scanner</span></span><br><span class="line">java.net.*		<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*		<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure>
<h2 id="细节-2"><a class="markdownIt-Anchor" href="#细节-2">#</a> 细节</h2>
<ul>
<li>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句 package</li>
<li>import 指令位置放在 package 的下面，在类定义前面，可以有多句且没有顺序要求</li>
</ul>
<h1 id="访问修饰符"><a class="markdownIt-Anchor" href="#访问修饰符">#</a> 访问修饰符</h1>
<ol>
<li>公开级别：用 public 修饰，对外公开</li>
<li>受保护级别：protected，对子类和同一个包中的类公开</li>
<li>默认级别：没有修饰符号，向同一个包的类公开</li>
<li>私有级别：private，只有类本身可以访问，不对外公开</li>
</ol>
<h1 id="封装encapsulation"><a class="markdownIt-Anchor" href="#封装encapsulation">#</a> 封装 encapsulation</h1>
<p>封装就是把抽象出的数据 [属性] 和对数据的操作 [方法] 封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作 [方法]，才能对数据进行操作</p>
<h2 id="封装的好处"><a class="markdownIt-Anchor" href="#封装的好处">#</a> 封装的好处</h2>
<ol>
<li>隐藏实现细节：方法 (连接数据库)&lt;–调用 (传入参数)</li>
<li>可与对数据进行验证，保证安全合理</li>
</ol>
<h2 id="封装的实现步骤"><a class="markdownIt-Anchor" href="#封装的实现步骤">#</a> 封装的实现步骤</h2>
<ul>
<li>
<p>将属性进行私有化【不能直接修改属性】</p>
</li>
<li>
<p>提供一个公共的 (public) set 方法，用于对属性判断并赋值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXxx</span><span class="params">(类型 参数名)</span>&#123;<span class="comment">//Xxx表示某个属性</span></span><br><span class="line">    <span class="comment">//加入数据验证的业务逻辑</span></span><br><span class="line">    属性 = 参数名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提供一个公共的 (public) get 方法，用于获取属性的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 数据类型 getXxx()&#123;<span class="comment">//权限判断，Xxx某个属性</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getter和setter"><a class="markdownIt-Anchor" href="#getter和setter">#</a> Getter 和 Setter</h2>
<p>Getter 和 Setter 方法可以直接在别的类中访问或修改私有属性，它们提供了封装性，检验和操作的功能，通过规范的命名和方法签名，可以提高代码的可读性和维护性</p>
<p>快捷键：Alt + insert（笔记本加 Fn）</p>
<h3 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2">#</a> 作用</h3>
<ul>
<li>
<p>Getter 和 Setter 方法的使用可以有效地控制对对象属性的访问和修改，提供了封装性和安全性</p>
</li>
<li>
<p>通过 Getter 方法，其他类可以获取属性的值而不需要直接访问属性</p>
</li>
<li>
<p>通过 Setter 方法，其他类可以修改属性的值而不需要直接修改属性</p>
</li>
<li>
<p>封装性：通过 Getter 和 Setter 方法，可以对属性的访问和修改进行控制</p>
</li>
<li>
<p>验证和操作：可以在 Getter 和 Setter 方法中实现对属性的验证和操作，例如范围检查、格式转换等，确保数据的合法性</p>
</li>
<li>
<p>可读性和可维护性：通过 Getter 和 Setter 方法可以提供更具描述性和可读性的代码，使代码更易于理解和维护</p>
</li>
</ul>
<h1 id="继承"><a class="markdownIt-Anchor" href="#继承">#</a> 继承</h1>
<p>在一些问题中可能会出现，很多类的属性和方法都一样，这就造成了代码复用的现象，代码冗余度很高，继承就可以解决代码复用性的问题。</p>
<p>当多个类存在相同属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/12/06/java%E7%AC%94%E8%AE%B0/C:%5CUsers%5CAhan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240815120355095.png" alt="image-20240815120355095"></p>
<h2 id="语法"><a class="markdownIt-Anchor" href="#语法">#</a> 语法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类会自动拥有父类定义的属性和方法</span></span><br><span class="line"><span class="comment">//父类也叫超类，基类</span></span><br><span class="line"><span class="comment">//子类又叫派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pupil</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在考小学数学&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节-3"><a class="markdownIt-Anchor" href="#细节-3">#</a> 细节</h2>
<ul>
<li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问</li>
<li>子类必须调用父类的构造器，完成对父类的初始化</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如现在的父类就没有无参构造器，但是有形参为String，int的构造器，那么可以这样使用super();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类Sub()构造器被调用。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果希望指定去调用父类的某个构造器，则显示的调用一下</li>
<li>super 在使用时，需要放在构造器第一行</li>
<li>super () 和 this () 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</li>
<li>java 所有类都是 Object 类的子类，Object 类是所有类的基类</li>
<li>父类构造器的调用不限于直接父类，将一直往上追溯，直到 Object 类 (顶级父类)</li>
<li>子类最多只能继承一个父类（指直接继承），即 java 中是单继承机制。</li>
</ul>
<p>如果要让 A 继承 B 和 C，得先 A 继承 B，B 继承 C</p>
<ul>
<li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat <span class="keyword">extends</span> <span class="title class_">Animal</span><span class="comment">//合理</span></span><br><span class="line"></span><br><span class="line">Person <span class="keyword">extends</span> <span class="title class_">Music</span><span class="comment">//不合理</span></span><br></pre></td></tr></table></figure>
<h1 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字">#</a> super 关键字</h1>
<p>用 super 调用父类的构造器，可使分工明确，父类属性由父类初始化，子类的属性由子类初始化</p>
<h2 id="语法-2"><a class="markdownIt-Anchor" href="#语法-2">#</a> 语法</h2>
<ul>
<li>访问父类的属性，但不能访问父类的 private 属性	super. 属性名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="built_in">super</span>.n1+<span class="built_in">super</span>.n2);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问父类的方法，不能访问父类的 private 方法    super. 方法名 ()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.test();</span><br></pre></td></tr></table></figure>
<ul>
<li>访问父类的构造器    super (参数列表)；只能放在构造器的第一句</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;jack, 22&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="细节-4"><a class="markdownIt-Anchor" href="#细节-4">#</a> 细节</h2>
<ul>
<li>当子类中有和父类中的成员重名时，为了访问父类的成员，必须通过 super，如果没有重名，使用 super、this、直接访问时一样的效果</li>
<li>super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；如果多个基类中都有同名的成员，使用 super 访问遵循就近原则。</li>
</ul>
<h1 id="方法重写覆盖override"><a class="markdownIt-Anchor" href="#方法重写覆盖override">#</a> 方法重写 / 覆盖 (override)</h1>
<p>方法覆盖就是子类有一个方法和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法 +</p>
<p>** 作用：** 可以达到不更改父类的方法便创建了子类的一个方法。使程序更加的安全</p>
<h2 id="注意事项和使用细节"><a class="markdownIt-Anchor" href="#注意事项和使用细节">#</a> 注意事项和使用细节</h2>
<ul>
<li>子类的方法的参数，方法名称，要和父类方法的参数名称完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是 object，子类返回类型是 String</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ul>
<h1 id="多态"><a class="markdownIt-Anchor" href="#多态">#</a> 多态</h1>
<p>问题引出：一个主人有几个宠物，比如小狗和猫，小狗吃骨头，猫吃鱼，可能还会吃别的东西，那么在这种情况下，我们要建立一个小狗的类、小猫的类，还有食物的类，而食物又分为骨头，鱼，后面可能还会有别的，那么这些食物就是 food 的子类。在这种情况下，我每多一个宠物，我就要在主方法中多写一个方法来调用他们，这样会随着项目的扩展导致方法数量太多，不利于管理和维护</p>
<p>而在多态的情况下，父类对象可以指向子类对象，那么只要是这个父类的子类，都可以直接传入同一个方法中来调用，根据子类的不同而输出不同的值</p>
<h2 id="方法的多态"><a class="markdownIt-Anchor" href="#方法的多态">#</a> 方法的多态</h2>
<p>方法的重写和重载就体现了多态</p>
<h2 id="对象的多态"><a class="markdownIt-Anchor" href="#对象的多态">#</a> 对象的多态</h2>
<ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时 “=” 号的左边，运行类型看 “=” 号的右边</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//animal编译类型是Animal，运行类型是Dog</span></span><br><span class="line">animal = <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//animal的运行类型变成了Cat，编译类型仍然是Animal</span></span><br></pre></td></tr></table></figure>
<h2 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2">#</a> 注意事项</h2>
<ul>
<li>多态的前提是两个对象（类）存在继承关系</li>
<li>属性没有重写之说，属性的值看编译类型。（如果转型的类中有和父类一样的属性，那么就看编译的是哪个类，值就是哪个类的值）</li>
<li>instanceof 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的（前面这个是否为后面这个的）<strong>子类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译类型运行类型都为BB，但BB是AA的子类，所以返回结果都为ture</span></span><br><span class="line"><span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">System.out.println(bb <span class="keyword">instanceof</span> BB);</span><br><span class="line">System.out.println(bb <span class="keyword">instanceof</span> AA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//aa编译类型AA，运行类型BB</span></span><br><span class="line"><span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">System.out.println(aa <span class="keyword">instanceof</span> AA);</span><br><span class="line">System.out.println(aa <span class="keyword">instanceof</span> BB);</span><br><span class="line"><span class="comment">//返回结果都为ture</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> exetnds AA&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态向上转型"><a class="markdownIt-Anchor" href="#多态向上转型">#</a> 多态向上转型</h3>
<p>本质：父类的引用指向了子类的对象（也就是向上转型）。只要是继承关系，父类都可以指向下面的任意子类</p>
<p>特点：编译类型看左边，运行类型看右边</p>
<p>语法：父类类型	应用名 = new 子类类型 ();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>可以调用父类中的所有成员（需遵守访问权限，比如私有就无法调用）</li>
<li>不能调用子类中的特有成员（父类中没有的，就不能调用）</li>
<li>最终的运行效果看子类的具体实现</li>
</ul>
<h3 id="向下转型"><a class="markdownIt-Anchor" href="#向下转型">#</a> 向下转型</h3>
<p>为了代码维护的便利，我们利用多态的性质进行了一个向上转型，但当我们在向上转型之后，又需要用到子类中的成员，但此时无法引用，这还是就可以向下转型进行一个强转，强行把指向父类又改成指向子类，这样就可以使用子类的成员了</p>
<p>语法：子类类型	引用名 = （子类类型）父类引用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br></pre></td></tr></table></figure>
<ul>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类引用必须指向的是<strong>当前目标类型</strong>的对象（就是如果要向下转型，你转型的目标原本就是这个类型的，只不过之前向上转型了，现在相当于是复原回它原本的类型）</li>
<li>可以调用子类类型中所有的成员</li>
</ul>
<h2 id="java动态绑定机制"><a class="markdownIt-Anchor" href="#java动态绑定机制">#</a> java 动态绑定机制</h2>
<ol>
<li>当调用对象方法的时候，该方法回合该对象的内存地址 (也就是运行类型) 绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明就用哪里的</li>
</ol>
<h2 id="多态数组"><a class="markdownIt-Anchor" href="#多态数组">#</a> 多态数组</h2>
<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student和Teacher都是Person的子类，数组为Person类，里面的数据可以存放子类</span></span><br><span class="line">Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">5</span>];</span><br><span class="line">persons[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>);</span><br><span class="line">persons[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tch&quot;</span>, <span class="number">21</span>);</span><br><span class="line">persons[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;king&quot;</span>, <span class="number">30</span>, <span class="number">20000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="多态参数"><a class="markdownIt-Anchor" href="#多态参数">#</a> 多态参数</h2>
<p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">tch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tch&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">35</span>);</span><br><span class="line"><span class="comment">//这里Student和Teacher都是Person的子类，可以直接将这样一个对象传给AAA的形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AAA</span><span class="params">(Person a)</span> &#123;</span><br><span class="line">    System.out.println(a.say());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="object类"><a class="markdownIt-Anchor" href="#object类">#</a> Object 类</h1>
<h2 id><a class="markdownIt-Anchor" href="#">#</a> ==</h2>
<ol>
<li>== 既可以判断基本类型，又可以判断引用类型</li>
<li>== 如果判断基本类型，判断的是值是否相等</li>
<li>== 如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">A b = a;</span><br><span class="line">A c = b;</span><br></pre></td></tr></table></figure>
<h2 id="equals"><a class="markdownIt-Anchor" href="#equals">#</a> equals()</h2>
<p>equals 是 Object 类中的方法，<strong>只能判断引用类型</strong>，默认判断的是地址是否相等，子类中往往<strong>要重写该方法</strong>，用于判断内容是否相等，比如 Integer，String，这两个之所以可以直接比较值，是因为 integer 类和 String 类中已经重写了 equals 方法</p>
<p>如果没有重写 equals 方法，那么就是比较地址，如果重写了，就是比较重写的值，根据这个我们可以自己重写我们所需要的 equals 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object的equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">//判断如果比较的两个对象是同一个对象，返回ture</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类型判断</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;<span class="comment">//是Person才开始比较，否则直接返回false</span></span><br><span class="line">            <span class="comment">//进行类型转换，现在相当于是Object类，所以需要向下转型,我需要得到obj的各个属性来进行判断</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age &amp;&amp; <span class="built_in">this</span>.gender == p.gender;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashcode方法"><a class="markdownIt-Anchor" href="#hashcode方法">#</a> hashCode 方法</h2>
<p>返回该对象的哈希码值，支持此方法是为了提高哈希表的性能。</p>
<ol>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用，如果一个指向的是同一个对象，哈希值一样</li>
<li>如果指向的是不同的对象，哈希值不一样</li>
<li>哈希值主要根据地址号计算，不能完全将哈希值等价于地址</li>
<li>后面在集合中，hashCode 如果需要的话，也可以重写</li>
</ol>
<h2 id="tostring方法"><a class="markdownIt-Anchor" href="#tostring方法">#</a> toString 方法</h2>
<ul>
<li>默认返回：全类名 (包名 + 类名)+@+ 哈希值的 16 进制，子类往往重写 toString 方法，用于返回对象的属性信息</li>
<li>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</li>
<li>当直接输出一个对象时，toString 方法会被默认的调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写toString方法输出对象的属性，使用快捷键alt+insert -&gt; toStirng</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monster</span><span class="params">(String name, <span class="type">int</span> age, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重写后一般是把对象的属性值输出，也可以自己定制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Monster&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, job=&#x27;&quot;</span> + job + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="finalize方法"><a class="markdownIt-Anchor" href="#finalize方法">#</a> finalize 方法</h2>
<p>这个实际开发中几乎不会用，应付面试</p>
<ol>
<li>当对象被回收时，系统自动调用该对象的 finalize 方法，释放资源，子类可重写该方法</li>
<li>什么时候被回收：当某个对象没有任何引用时，jvm 会认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象之前，会先调用 finalize 方法</li>
<li>垃圾回收机制的调用，是由系统来决定 (即有自己的 GC 算法)，也可以通过 System.gc () 主动触发垃圾回收机制</li>
</ol>
<h1 id="断点调试"><a class="markdownIt-Anchor" href="#断点调试">#</a> 断点调试</h1>
<ul>
<li>在断点调试过程中，是运行状态，是以对象的运行类型来执行的</li>
</ul>
<h2 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键">#</a> 快捷键</h2>
<p>F7（跳入）	shift+F8（跳出）	F9（resume，执行到下一个断点）</p>
<p>F7：跳入方法内	F8：逐行执行代码	shift+F8：跳出方法</p>
<h1 id="类变量和类方法"><a class="markdownIt-Anchor" href="#类变量和类方法">#</a> 类变量和类方法</h1>
<p>类变量和类方法也叫做静态变量和静态方法，可以直接使用而<strong>不需要初始化</strong>，对所有对象都共享。</p>
<ul>
<li>在 java7 以上，静态变量和静态方法都是储存在方法区；java7 及以下的静态变量储存在常量池的一个专门储存 static 变量的地方</li>
<li>类方法中不能使用和对象有关的关键字，比如 this 和 super</li>
<li>静态方法只能访问静态变量或方法</li>
<li>静态方法不能被重写</li>
</ul>
<h1 id="main方法语法"><a class="markdownIt-Anchor" href="#main方法语法">#</a> main 方法语法</h1>
<ul>
<li>main 方法接受 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：java 执行的程序 参数1 参数2 参数3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在cmd中执行这个程序，然后输入“java hello tch tchh tchhh”，就会输出这几个字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="代码块"><a class="markdownIt-Anchor" href="#代码块">#</a> 代码块</h1>
<p>代码块又称为初始化块，属于类中的成员，是类的一部分，类似于方法，将逻辑语句封装在方法体中，用 {} 包围。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line">[修饰符]&#123;</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符可选，要写的话也只能写 static</li>
<li>代码块分为两类，使用 static 修饰的交静态代码块，没有 static 修饰的交普通代码块</li>
<li>逻辑语句可分为任何逻辑语句（输入输出、方法调用、循环、判断等）</li>
<li>分号可以省略</li>
</ul>
<h2 id="代码块的好处"><a class="markdownIt-Anchor" href="#代码块的好处">#</a> 代码块的好处</h2>
<ul>
<li>相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>
<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里有三种构造器，而我们在构造器前添加了普通代码块，注意是普通代码块</span></span><br><span class="line"><span class="comment">     * 那么无论是哪个构造器被调用，都会先执行代码块中的内容，这样就提升了代码的复用性</span></span><br><span class="line"><span class="comment">     * 就不需要再每个构造器中都写上这三句代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;映前广告&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;广告结束&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;电影开始&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, String director)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String title, <span class="type">int</span> year, String director)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节-5"><a class="markdownIt-Anchor" href="#细节-5">#</a> 细节</h2>
<ul>
<li>static 代码块的作用是对类进行初始化，而且随着<strong>类的加载</strong>而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行一次</li>
</ul>
<p>类什么时候被加载：</p>
<ol>
<li>创建实例时（new）</li>
<li>创建子类对象实例，父类也会被加载，父类先加载，子类后加载</li>
<li>使用类的静态成员时（静态变量 / 方法）</li>
</ol>
<ul>
<li>
<p>普通代码块在创建对象实例时会被隐式的调用，被创建一次就会被调用一次。但如果只是使用类的静态成员，普通代码块不会执行</p>
</li>
<li>
<p>创建对象时，代码块在类中的调用顺序如下 1-&gt;2-&gt;3</p>
<ol>
<li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和普通属性初始化，则按定义顺序调用）</li>
<li>调用构造方法</li>
</ol>
</li>
<li>
<p>构造器的最前面其实隐含了 super () 和调用普通代码块的一句话，静态相关的代码块，属性初始化，在类加载时就执行完毕，因此是优先于构造器和普通代码块执行的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//隐藏语句：</span></span><br><span class="line">		<span class="comment">//(1)super();</span></span><br><span class="line">        <span class="comment">//(2)调用普通代码块的语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个子类对象时的加载顺序：（面试高频）
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性初始化</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
</li>
</ul>
<h1 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式">#</a> 单例设计模式</h1>
<p>单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。单例模式有两种方式：饿汉式和懒汉式</p>
<h2 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式">#</a> 饿汉式</h2>
<p>无论是否使用对象，都会先创建，所以叫饿汉式。但这样有可能会造成资源浪费</p>
<p>步骤如下</p>
<ol>
<li>构造器私有化（防止直接 new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法    getInstance</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">girlFriend</span> <span class="operator">=</span> GirlFriend.getGirlFriend();</span><br><span class="line">        System.out.println(girlFriend);<span class="comment">//无论创建几次新的对象，都是指向GirlFriend内部创建的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//为了能够在静态方法中使用，需要将其静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">    <span class="comment">//如何保证只能创建一个GirlFriend对象</span></span><br><span class="line">    <span class="comment">//1.将构造器私有化</span></span><br><span class="line">    <span class="comment">//2.在类的内部直接创建</span></span><br><span class="line">    <span class="comment">//3.提供一个公共的static方法，返回gf对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式">#</a> 懒汉式</h2>
<p>在需要使用的时候才创建对象，所以叫懒汉式</p>
<p>步骤如下：</p>
<ol>
<li>构造器私有化</li>
<li>定义一个 static 对象</li>
<li>提供一个 public 方法，可以返回 Cat 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">mao</span> <span class="operator">=</span> Cat.getInstance();</span><br><span class="line">        System.out.println(mao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希望在程序运行过程中只能创建一个Cat对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat;</span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="comment">//2.定义一个static对象</span></span><br><span class="line">    <span class="comment">//3.提供一个public方法，可以返回Cat对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cat == <span class="literal">null</span>) &#123;<span class="comment">//如果没有创建Cat对象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;mimi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两者区别"><a class="markdownIt-Anchor" href="#两者区别">#</a> 两者区别</h2>
<ol>
<li>最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用是才创建</li>
<li>饿汉式不存在<strong>线程安全</strong>问题，懒汉式存在线程安全问题</li>
<li>饿汉式存在浪费资源的可能，懒汉式因为是使用时才创建，不存在这个问题</li>
<li>在 javaSE 标准类中，java.lang.Runtime 就是经典的单例模式</li>
</ol>
<h1 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字">#</a> final 关键字</h1>
<p>final 可以修饰类、属性、方法和局部变量，在什么时候会用到 final 关键字</p>
<ol>
<li>当不希望类被继承时，可以用 final 修饰</li>
<li>当不希望父类的某个方法被子类覆盖 / 重写时</li>
<li>当不希望类的某个属性的值被修改</li>
<li>当不希望某个局部变量被修改</li>
</ol>
<h2 id="注意事项-3"><a class="markdownIt-Anchor" href="#注意事项-3">#</a> 注意事项</h2>
<ul>
<li>final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">TAX_RATE</span> <span class="operator">=</span> <span class="number">0.08</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>final 修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在以下位置之一
<ol>
<li>定义时：如 public final double TAX_RATE = 0.08;</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ol>
</li>
<li>如果 final 修饰的属性是静态的，则初始化的位置只能是：定义时；在静态代码块；不能在构造器中赋值</li>
<li>final 类不能继承，但可以实例化对象</li>
<li>如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承</li>
<li>一般来说，如果一个类已经是 final 类了，就没必要将方法再修饰成 final</li>
<li>final 不能修饰构造器</li>
<li>final 和 static 往往搭配使用，效率更高，底层编译器做了优化处理，不会导致类加载</li>
<li>包装类（integer，double，float，boolean 等都是 final），String 也是 final 类</li>
</ul>
<h1 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类">#</a> 抽象类</h1>
<p>当父类的某些方法需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<p>一般情况都是让子类继承来实现方法，抽象类的价值更多是在于设计，设计者设计好之后，让子类继承并实现抽象类。抽象类是考官比较爱问的知识点，在框架和设计模式使用较多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个类中存在抽象方法时，类也要声明为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节-6"><a class="markdownIt-Anchor" href="#细节-6">#</a> 细节</h2>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含 abstract 方法，抽象类可以没 abstract 方法</li>
<li>一旦类包含了 abstract 方法，这个类就必须声明为抽象类</li>
<li>abstract 只能修饰类和方法，不能修饰属性或其他的</li>
<li>抽象类可以有任意成员，比如非抽象方法、构造器、静态属性等</li>
<li>抽象方法不能有主题，即不能实现</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</li>
<li>抽象方法不能使用 private、final 和 static 修饰，因为这些关键字和重写都是相违背的</li>
</ol>
<h1 id="抽象模板模式"><a class="markdownIt-Anchor" href="#抽象模板模式">#</a> 抽象模板模式</h1>
<p>在模板模式中，一个抽象类公开定义了执行它的方法的方式，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，这种类型的设计模式属于行为型模式。</p>
<h2 id="主要解决的问题"><a class="markdownIt-Anchor" href="#主要解决的问题">#</a> 主要解决的问题</h2>
<p>解决在多个子类中重复实现相同的方法的问题，通过将通用方法抽象到父类中来避免代码重复</p>
<p>** 使用建议：** 当有多个子类共有的方法且逻辑相同时，考虑使用模板方法定义在父类中；对于重要或复杂的方法，可以考虑作为模板方法定义在父类中</p>
<h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点">#</a> 优缺点</h2>
<ul>
<li>** 封装不变部分：** 算法的不变部分被封装在父类中</li>
<li>** 扩展可变部分：** 子类可以扩展或修改算法的可变部分</li>
<li>** 提取公共代码：** 减少代码重复，便于维护</li>
</ul>
<p>缺点就是 ** 类数目增加：** 没个不同的实现都需要一个子类，可能倒是系统庞大</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个抽象类，它的模板方法被设置为final</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay</span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建扩展了上述类的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cricket</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口"><a class="markdownIt-Anchor" href="#接口">#</a> 接口</h1>
<p>接口就是给出一些没有实现的方法，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法（抽象方法/默认方法/静态方法）</span></span><br><span class="line">&#125;</span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    自己属性；</span><br><span class="line">    自己方法</span><br><span class="line">	必须实现的接口的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 jdk7.0 前，接口里的所有方法都没有方法体</li>
<li>jdk8.0 后接口类可以有静态方法和默认方法 (static 和 default)，也就是说接口中可以有方法的具体实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Animal.java */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节-7"><a class="markdownIt-Anchor" href="#细节-7">#</a> 细节</h2>
<ol>
<li>接口不能被实例化</li>
<li>接口中所有的方法都是 public 方法，如果不写也是默认 public，接口中抽象方法可以不用 abstract 修饰</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都实现（alt+enter 快捷键）</li>
<li>抽象类实现接口，可以不用实现接口的方法</li>
<li>一个类可以同时实现多个接口</li>
<li>接口中的属性只能是 final 类型，而且是 public static final 修饰符，但是被隐藏了，比如 int a=1; 实际上是 public static final int a=1;（必须初始化）</li>
<li>接口中书信固定访问形式：接口名。属性名</li>
<li>一个接口不能继承其他的类，但是可以继承多个别的接口：interface A extends B,C {}</li>
<li>接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的</li>
</ol>
<h2 id="接口和继承的比较"><a class="markdownIt-Anchor" href="#接口和继承的比较">#</a> 接口和继承的比较</h2>
<p>当子类继承了父类，就自动拥有了父类的功能。如果子类需要扩展功能，可以通过实现接口的方式来扩展。</p>
<p>可以理解为，实现接口是对 java 单继承机制的一种补充。</p>
<ul>
<li>
<p>继承的作用主要在于：解决代码的复用性和可维护性</p>
</li>
<li>
<p>而接口的作用在于：设计。设计好各种规范，让类来实现这些方法</p>
</li>
<li>
<p>接口比继承更加灵活，继承是满足 is - a 的关系，而接口秩序满足 like - a 的关系</p>
</li>
<li>
<p>接口在一定程度上实现代码解耦</p>
</li>
</ul>
<h2 id="接口的多态"><a class="markdownIt-Anchor" href="#接口的多态">#</a> 接口的多态</h2>
<ul>
<li>多态参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了这个接口的类的对象，都可以作为形参传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface a)</span> &#123;<span class="comment">//这里a就是接口类型的类的对象实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多态数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Usb[] usb = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>];</span><br><span class="line">        usb[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        usb[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口存在多态传递现象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        <span class="type">TH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内部类"><a class="markdownIt-Anchor" href="#内部类">#</a> 内部类</h1>
<p>一个类的内部又完整的嵌套类另一个类结构。被嵌套的类称为内部类 (inner class)，嵌套其他类的类称为外部类 (outer class)，是类的第五大成员 (属性、方法、构造器、代码块、内部类)，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;&#125;<span class="comment">//其他类</span></span><br></pre></td></tr></table></figure>
<h2 id="内部类的分类"><a class="markdownIt-Anchor" href="#内部类的分类">#</a> 内部类的分类</h2>
<ul>
<li>定义在外部类局部位置上（比如方法内）：
<ol>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名，重点）</li>
</ol>
</li>
<li>定义在外部类的成员位置上：
<ol>
<li>成员内部类（没用 static 修饰）</li>
<li>静态内部类（使用 static 修饰）</li>
</ol>
</li>
</ul>
<h3 id="局部内部类的使用"><a class="markdownIt-Anchor" href="#局部内部类的使用">#</a> 局部内部类的使用</h3>
<p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<ol>
<li>
<p>局部内部类可以<strong>直接访问</strong>外部类的<strong>所有成员</strong>，包括私有成员</p>
</li>
<li>
<p>不能添加访问修饰符，因为他的低位就是应该局部变量，局部变量是不能使用修饰符的，但是可以使用 final 修饰，因为局部变量也可以使用 final</p>
</li>
<li>
<p>作用域：只在定义它的方法或代码中</p>
</li>
<li>
<p>局部内部类访问外部类的成员，可以直接访问</p>
</li>
<li>
<p>外部类访问局部类的成员，需要<strong>创建对象再访问</strong></p>
</li>
<li>
<p>外部<strong>其他类</strong>不能访问局部内部类，因为局部内部类地位是一个局部变量</p>
</li>
<li>
<p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this. 成员）去访问</p>
<ul>
<li>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"外部类的n="</span> <span class="token operator">+</span> 外部类名<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>code￼<span class="token number">59</span><span class="token operator">--</span><span class="token operator">></span></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>匿名内部类是系统自动生成的，表面上以一个对象的形式存在，但实际上底层生成了一个类，比如外部类叫做 Outer，那么匿名内部类会叫做 Outer$1，如果后面还有匿名内部类就依次按顺序排号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上他的形式在底层是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="细节-8"><a class="markdownIt-Anchor" href="#细节-8">#</a> 细节</h4>
<ul>
<li>匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时本身也是一个对象，因此从语法上看，它既有定义类的特征也有创建对象的特征。所以可以直接调用匿名内部类方法</li>
</ul>
<p>如何调用呢，以上面的为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;.ok();<span class="comment">//可以直接在后面跟着调用，输出hi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    p.hi();<span class="comment">//动态绑定，运行类型是Outer$1，所以输出的是hi而不是hi~~~</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它的地位是一个局部变量</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>匿名内部类访问外部类成员，直接访问</li>
<li>外部<strong>其他类</strong>不能访问匿名内部类，因为匿名内部类相当于一个局部变量</li>
<li>如果外部类和内部类的成员重名，在内部类访问时，遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this. 成员）去访问</li>
</ul>
<h4 id="实例-2"><a class="markdownIt-Anchor" href="#实例-2">#</a> 实例</h4>
<p>当作实参直接传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当作实参直接传递</span></span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法，形参是接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span> &#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下传统的方法（硬编码），如果说要多次使用，可以就用传统方法，但如果只用一次，直接传递会更简洁高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在这调用</span></span><br><span class="line">		f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法，形参是接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span> &#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span> <span class="keyword">implements</span> <span class="title class_">IL</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;picture&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个铃声接口 Bell，里面有一个 ring 方法；有一个手机类 Cellphone，具有闹钟功能 alarmclock，参数是 Bell 类型；测试手机类的闹钟功能，通过匿名内部类作为参数，输出 &quot;起床啦&quot;；再传入一个匿名内部类对象，输出 &quot;get up!&quot;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Cellphone</span> <span class="variable">cellphone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cellphone</span>();</span><br><span class="line">        cellphone.alarmclock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;起床啦&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cellphone.alarmclock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;get up!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cellphone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alarmclock</span><span class="params">(Bell bell)</span> &#123;</span><br><span class="line">        bell.ring();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bell</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员内部类的使用"><a class="markdownIt-Anchor" href="#成员内部类的使用">#</a> 成员内部类的使用</h3>
<p>成员内部类是定义在外部类的成员位置，并没有 static 修饰</p>
<ol>
<li>
<p>可以直接访问外部类的所有成员，包括私有的</p>
</li>
<li>
<p>可以添加任意访问修饰符（public、protected、默认、private），因为它本身也是一个成员</p>
</li>
<li>
<p>作用域和外部类的其他成员一样为整个类体，在外部类的成员方法中创建成员内部类对象，再调用方法</p>
</li>
<li>
<p>成员内部类访问外部类，直接访问</p>
</li>
<li>
<p>外部类访问成员内部类，创建对象再访问</p>
</li>
<li>
<p>外部其他类访问成员内部类</p>
<ol>
<li>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 第一种方式，相当于把 new Inner () 当作是 Outer 的成员</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> <span class="token class-name">Outer</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>code￼<span class="token number">67</span><span class="token operator">--</span><span class="token operator">></span></pre></td></tr></table></figure></li>
<li>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 第三种其实本质上就是前两种的结合</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>code￼<span class="token number">68</span><span class="token operator">--</span><span class="token operator">></span></pre></td></tr></table></figure></li>
</ol>
</li>
<li>
<p>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</p>
</li>
<li>
<p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</p>
</li>
<li>
<p>作用域：同其他的成员，为整个类体</p>
</li>
<li>
<p>静态内部类访问外部类，可以直接访问所有静态成员</p>
</li>
<li>
<p>外部类访问静态内部类，创建对象再访问</p>
</li>
<li>
<p>外部其他类访问静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果外部类和内部类的成员重名，在内部类访问时，遵循就近原则，如果想访问外部类的成员，可以使用（外部类名。成员）去访问</p>
</li>
</ol>
<h1 id="枚举类"><a class="markdownIt-Anchor" href="#枚举类">#</a> 枚举类</h1>
<p>枚举是一组常量的集合，属于一种特殊的类，里面只包含一组有限的特定的对象</p>
<ol>
<li>不需要提供 setXxx 方法，因为枚举对象值通常为只读</li>
<li>对枚举对象 / 属性使用 final+static 共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<h2 id="实例-3"><a class="markdownIt-Anchor" href="#实例-3">#</a> 实例</h2>
<ol>
<li>
<p>用自定义类来实现枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        System.out.println(Season.SUMMER);</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.WINTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 enum 关键字实现枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        System.out.println(Season.SUMMER);</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.WINTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用关键字enum代替class</span></span><br><span class="line">    <span class="comment">//如果有多个常量(对象)，用逗号间隔</span></span><br><span class="line">    <span class="comment">//格式：常量名(实参列表)</span></span><br><span class="line">    <span class="comment">//如果使用enum来实现枚举，要求将定义常量对象写在最前面</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>),WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>),WHAT;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Season2&#123;&#125;<span class="comment">//无参构造器，上面的WHAT因为没有传入参数所以是调用的无参构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="细节-9"><a class="markdownIt-Anchor" href="#细节-9">#</a> 细节</h2>
<ol>
<li>当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类，且是一个 final 类（可以通过反编译看到）</li>
<li>传统的 public static final Season SPRING = new Season (“春天”, “温暖”); 简化成 SPRING (“春天”, “温暖”)，这里必须知道它调用的时哪个构造器</li>
<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用逗号间隔，分号结尾</li>
<li>枚举对象必须放在枚举类的行首</li>
</ol>
<h2 id="enum常用方法"><a class="markdownIt-Anchor" href="#enum常用方法">#</a> enum 常用方法</h2>
<p>因为 enum 会默认继承 Enum 类，在父类中有些方法可以用</p>
<ol>
<li>toString：Enum 类已经重写过了，返回的是当前对象的属性信息</li>
<li>name：返回当前对象名（常量名），子类中不能重写</li>
<li>ordinal：返回当前对象的位置号，默认从 0 开始</li>
<li>values：返回当前枚举类中所有的常量</li>
<li>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li>
<li>compareTo：比较两个枚举常量，比较的就是位置号。（位置编号相减得 0 为真）</li>
</ol>
<h2 id="enum实现接口"><a class="markdownIt-Anchor" href="#enum实现接口">#</a> enum 实现接口</h2>
<ol>
<li>
<p>使用 enum 关键字后，不能再继承其他类，因为 enum 类会隐式继承 Enum，而 java 是单继承机制</p>
</li>
<li>
<p>枚举类和普通类一样，可以实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="注解"><a class="markdownIt-Anchor" href="#注解">#</a> 注解</h1>
<ol>
<li>注解（Annotation）也被称为元数据（Metadata），用于修饰包、类、方法、属性、构造器、局部变量等数据信息</li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</li>
<li>再 javase 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 javaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</li>
</ol>
<p>使用 Annotation 时要在其前面加 @符号，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素</p>
<p>三个基本的 Annotation：</p>
<ol>
<li>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示某个程序元素（类、方法等）已过时</li>
<li>@SuppressWarnings：抑制编译器的警告</li>
</ol>
<h2 id="override"><a class="markdownIt-Anchor" href="#override">#</a> @Override</h2>
<ol>
<li>@Override 只能修饰方法，不能修饰其他类、包、属性等</li>
<li>@Target 是修饰注解的注解，称为元注解</li>
<li>查看 @Override 注解的源码为 @Target (ElementType.METHOD)，说明只能修饰方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Father fly&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个@Override其实是可写可不写，但是写了会让系统再编译的时候去检查这里是否真的重写了，重写了才能编译成功，没重写就会报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">    <span class="comment">//这是一个注解类，不是接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deprecated"><a class="markdownIt-Anchor" href="#deprecated">#</a> @Deprecated</h2>
<ol>
<li>用于表示某个程序元素（类、方法、属性等）已过时</li>
<li>可以修饰方法、类、字段、包、参数等</li>
<li>@Deprecated 的作用可以做到新旧版本的兼容和过渡</li>
<li>@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.hi();</span><br><span class="line">        System.out.println(a.n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="suppresswarnings"><a class="markdownIt-Anchor" href="#suppresswarnings">#</a> @SuppressWarnings</h2>
<p>有时候写代码，代码其实可以正常运行，但是会有一些警告，这个时候就可以用 @SuppressWarnings 注解来抑制警告信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="comment">//除了all还有专门抑制其他某种类型警告，具体的使用可以查阅资料</span></span><br></pre></td></tr></table></figure>
<ul>
<li>@SuppressWarnings 的作用范围和放置的位置相关，比如放在 main 方法，那么抑制的范围就是 main 方法</li>
</ul>
<h1 id="异常exception"><a class="markdownIt-Anchor" href="#异常exception">#</a> 异常 Exception</h1>
<p>快捷键：ctrl + alt + t 选择 try-catch</p>
<h2 id="异常的概念"><a class="markdownIt-Anchor" href="#异常的概念">#</a> 异常的概念</h2>
<p>一般可以分为两类</p>
<ol>
<li>Error：java 虚拟机无法解决的严重问题，如：JVM 系统内部错误、资源耗尽等严重情况。比如 StackOverflow [栈溢出] 和 OOM (out of memory)，Error 是严重错误，程序会崩溃</li>
<li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针方向，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类：运行时异常和编译时异常</li>
</ol>
<h2 id="异常体系图"><a class="markdownIt-Anchor" href="#异常体系图">#</a> 异常体系图</h2>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/12/06/java%E7%AC%94%E8%AE%B0/C:%5CUsers%5CAhan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240908205218302.png" alt="image-20240908205218302"></p>
<ol>
<li>异常分为两大类，运行时异常和编译时异常</li>
<li>运行时异常编译器检查不出来，一般是指编程时的逻辑错误，时程序员应该避免其出现的异常。java.lang.RuntimeException 类以及它的子类都是运行时异常</li>
<li>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理看你会对程序的可读性和运行效率产生影响</li>
<li>编译时异常时编译器要求必须处理的异常</li>
</ol>
<ul>
<li>常见的运行时异常：
<ol>
<li>NullPointException 空指针异常：当应用程序试图在需要对象的地方使用 null 时，抛出该异常</li>
<li>ArithmeticException 数学运算异常</li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 类型转换异常</li>
<li>NumberFormatException 数字格式不正确异常</li>
</ol>
</li>
<li>常见的编译异常：
<ol>
<li>SQLException：操作数据库时，查询表可能发生异常</li>
<li>IOException：操作文件时发生的异常</li>
<li>FileNotFoundException：当操作一个不存在的文件时发生异常</li>
<li>ClassNotFoundException：加载类，而该类不存在时异常</li>
<li>EOFException：操作文件，到文件末尾，发生异常</li>
<li>IllegalArgumentException：参数异常</li>
</ol>
</li>
</ul>
<h2 id="异常处理概念"><a class="markdownIt-Anchor" href="#异常处理概念">#</a> 异常处理概念</h2>
<p>异常处理就是当异常发生时，对异常处理的方式</p>
<h3 id="try-catch-finally"><a class="markdownIt-Anchor" href="#try-catch-finally">#</a> try-catch-finally</h3>
<p>程序员在代码中捕获发生的异常，自行处理</p>
<p>try 块用于包含可能出错的代码，catch 块用于处理 try 块中发生的异常，可以根据需要在程序中有多个 try-catch 模块</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>如果异常发生了，则异常发生后面的代码都不会执行，直接进入到 catch 块</li>
<li>如果异常没有发生，则顺序执行 try 的代码块，不会进入 catch</li>
<li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用 finally {}</li>
<li>如果 try 代码块可能有多个异常，，可以使用多个 catch 分别捕获不同的异常，但是要求子类异常写在前面，父类一场写在后面（比如 Exception 在后，NullPointerException 在前），如果发生异常，只会匹配一个 catch</li>
<li>可以进场 try-finally 配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。当希望执行一段代码，不管是否发生异常，都必须执行某个业务逻辑时可以使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可疑代码</span></span><br><span class="line">    <span class="comment">//将异常生成对应的异常对象，传送给catch块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常) &#123;</span><br><span class="line">    <span class="comment">//对异常的处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常) &#123;</span><br><span class="line">    <span class="comment">//对异常的处理</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放资源等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="throws"><a class="markdownIt-Anchor" href="#throws">#</a> throws</h3>
<p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是 JVM</p>
<p>如果一个方法（中的语句执行时）可能生成某种异常，但不能确定如何处理这种异常，则此方法显式地声明抛出异常，表明该方法将不对这些异常进行处理，而又该方法的调用者处理</p>
<p>在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>对于编译异常，程序中必须处理，比如 try-catch 或者 throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理</li>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的<strong>一致</strong>，要么为父类抛出的异常的类型的<strong>子类型</strong></li>
<li>在 throws 过程中，如果有方法 try-catch，就相当于处理异常，就可以不必 throws</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//这里是Exception是父类，也可以是FileNotFoundException子类</span></span><br><span class="line">    							   <span class="comment">//也可以多个子类异常，逗号分隔</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://1.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常">#</a> 自定义异常</h2>
<p>当程序中出现了某些错误，但该错误信息并没有在 Throwable 子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</p>
<p>自定义异常的步骤</p>
<ol>
<li>定义类：自定义异常类名（程序员自己写），继承 Exception 或 RuntimeException</li>
<li>如果继承 Exception，属于编译异常</li>
<li>如果继承 RuntimeException，属于运行异常（一般来说继承 RuntimeException）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">151</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;age should between 18 and 120.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般情况我们自定义异常时，最好是继承RuntimeException</span></span><br><span class="line"><span class="comment">//这样比较方便，不需要在主方法中再去抛异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throw和throws的对比"><a class="markdownIt-Anchor" href="#throw和throws的对比">#</a> throw 和 throws 的对比</h2>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody>
</table>
<h1 id="常用类"><a class="markdownIt-Anchor" href="#常用类">#</a> 常用类</h1>
<h2 id="包装类wrapper"><a class="markdownIt-Anchor" href="#包装类wrapper">#</a> 包装类 Wrapper</h2>
<h4 id="包装类的分类"><a class="markdownIt-Anchor" href="#包装类的分类">#</a> 包装类的分类</h4>
<ol>
<li>针对八种基本数据类型相应的应用类型 —— 包装类</li>
<li>有了类的特点，就可以调用类中的方法</li>
</ol>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
<h4 id="包装类和基本数据类型的转换"><a class="markdownIt-Anchor" href="#包装类和基本数据类型的转换">#</a> 包装类和基本数据类型的转换</h4>
<p>包装类是对象，基本数据类型是属性</p>
<ol>
<li>jdk5 前的手动装箱和拆箱方式，装箱：基本类型 -&gt; 包装类型，反过来就是拆箱</li>
<li>jdk5 及以后的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的时 valueOf 方法，比如 Integer.valueOf ()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//手动装箱int-&gt;Integer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动拆箱Integer-&gt;int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdk5后，就可以自动装箱和自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">interger2</span> <span class="operator">=</span> n2;<span class="comment">//底层使用的依然还是Integer.valueOf(n2)</span></span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> interger2;<span class="comment">//底层使用的还是intValue()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包装类型和string类型的相互转换"><a class="markdownIt-Anchor" href="#包装类型和string类型的相互转换">#</a> 包装类型和 String 类型的相互转换</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//包装类(Integer)-&gt;String</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//way 1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;<span class="comment">//这里只是以i为主体进行了一个转换，但i自己本身还是没变化</span></span><br><span class="line">        <span class="comment">//way2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();</span><br><span class="line">        <span class="comment">//way3</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String-&gt;包装类(Integer)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">        <span class="comment">//way1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到了自动装箱</span></span><br><span class="line">        <span class="comment">//way2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);<span class="comment">//用到了构造器，可以ctrl+b查看</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="integer类和character类的常用方法"><a class="markdownIt-Anchor" href="#integer类和character类的常用方法">#</a> Integer 类和 Character 类的常用方法</h2>
<p>这几个是比较常用的，还有非常多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">//返回最大/最小值</span></span><br><span class="line">   System.out.println(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">   System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是数字</span></span><br><span class="line">System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是字母</span></span><br><span class="line">   System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断大小写</span></span><br><span class="line">   System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"></span><br><span class="line">   System.out.println(Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是空格</span></span><br><span class="line">   System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//转换大小写</span></span><br><span class="line">   System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="integer类"><a class="markdownIt-Anchor" href="#integer类">#</a> Integer 类</h2>
<p><strong>面试题：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于生成的是两个对象，所以结果为false</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);</span><br><span class="line">        </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//底层为Integer.valueOf(1);</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//底层为Integer.valueOf(1);</span></span><br><span class="line">    System.out.println(m == n);<span class="comment">//在valueOf源码中，赋值在-127~128之间的，</span></span><br><span class="line">    <span class="comment">//就直接返回数值，而超过这个范围的，就new一个对象返回，所以这里为true</span></span><br><span class="line">        </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);</span><br><span class="line">    <span class="comment">//而这里大于了127不在范围中，返回一个对象，所以x和y是不同的两个对象，为false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"><span class="comment">//这个要注意，只要有int类型的(基本数据类型)，那么做比较的时候就是比较值是否相等</span></span><br><span class="line"><span class="comment">//哪怕x的底层是new一个对象，但这里对比的还是值的大小</span></span><br><span class="line"><span class="comment">//所以这里输出为true</span></span><br></pre></td></tr></table></figure>
<h2 id="string类"><a class="markdownIt-Anchor" href="#string类">#</a> String 类</h2>
<ol>
<li>
<p>字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节</p>
</li>
<li>
<p>String 类较常用构造器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String();</span><br><span class="line">String s2 = new String(String original);</span><br><span class="line">String s3 = new String(char[] a);</span><br><span class="line">String s4 = new String(char[] a, int startIndex, int count);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>String 类实现了接口 Serializable（String 可以序列化，在网络传输），还实现了 Comparable（对象可以比较大小）</p>
</li>
<li>
<p>String 是 final 类，不能被其他的类继承</p>
</li>
<li>
<p>String 有属性 private final char value []; 用于存放字符串内容，所以其本质是字符数组</p>
</li>
<li>
<p>value 是一个 final 类型，不可以修改（地址不可修改，值可以修改）</p>
</li>
</ol>
<h3 id="创建string对象的两种方式"><a class="markdownIt-Anchor" href="#创建string对象的两种方式">#</a> 创建 String 对象的两种方式</h3>
<ol>
<li>
<p>直接赋值： <code>String s = &quot;tch&quot;;</code></p>
<p>创建过程：先从常量池查看是否有 &quot;tch&quot; 数据空间，如果有，则直接指向它；如果没有则重写创建，然后指向。s 最终指向的是常量池的空间地址</p>
</li>
<li>
<p>调用构造器： <code>String s = new String(&quot;tch&quot;);</code></p>
<p>创建过程：先在堆中创建空间，里面维护了 value 属性，指向常量池的 &quot;tch&quot; 空间。如果常量池没有 &quot;tch&quot;，就重新创建，如果有，就直接通过 value 指向。最终指向的是堆中的空间地址</p>
<h3 id="实例-4"><a class="markdownIt-Anchor" href="#实例-4">#</a> 实例</h3>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;tch&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;tch&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//T</span></span><br><span class="line">System.out.println(a == b);<span class="comment">//F</span></span><br><span class="line">System.out.println(a == b.intern());<span class="comment">//T</span></span><br><span class="line">System.out.println(b == b.intern());<span class="comment">//F</span></span><br><span class="line"><span class="comment">//intern()方法的作用：如果池中已经包含了一个等于这个String对象的字符串，就直接返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.name = <span class="string">&quot;tch&quot;</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p2.name = <span class="string">&quot;tch&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(p1.name.equals(p2.name));<span class="comment">//T</span></span><br><span class="line">System.out.println(p1.name == p2.name);<span class="comment">//T</span></span><br><span class="line">System.out.println(p1.name == <span class="string">&quot;tch&quot;</span>);<span class="comment">//T</span></span><br><span class="line">        </span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;tch&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;tch&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//F</span></span><br></pre></td></tr></table></figure>
<h3 id="string对象特性"><a class="markdownIt-Anchor" href="#string对象特性">#</a> String 对象特性</h3>
<ol>
<li>String 是一个 final 类，代表不可变的字符序列</li>
<li>字符串是不可变的，一个字符串对象一旦被分配，其内容是不可改变的</li>
<li>常量相加，看的是常量池；变量相加，看的是堆</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一共有三个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line"><span class="comment">//1.先创建一个StringBuilder sb = StringBuilder()</span></span><br><span class="line"><span class="comment">//2.执行sb.append(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//3.执行sb.append(&quot;abc&quot;);</span></span><br><span class="line"><span class="comment">//4.String c = sb.toString();</span></span><br><span class="line"><span class="comment">//最后c指向堆中的对象(String)value[]--&gt;池中的&quot;helloabc&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="string类的常见方法"><a class="markdownIt-Anchor" href="#string类的常见方法">#</a> String 类的常见方法</h3>
<p>String 类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此 java 设计者还提供了 StringBuilder 和 StringBuffer 来增强 String 的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substring(<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//左闭右开，截取从1到4减1的字符串</span></span><br><span class="line">indexOf();<span class="comment">//获取字符在字符串对象中第一次出现的索引，从0开始，若找不到返回-1</span></span><br><span class="line">toUpperCase();	toLowerCase();		concat();	replace();		</span><br><span class="line">split();		compareTo(); 	toCharArray();		format();</span><br></pre></td></tr></table></figure>
<h2 id="stringbuffer类"><a class="markdownIt-Anchor" href="#stringbuffer类">#</a> StringBuffer 类</h2>
<ol>
<li>java.lang.StringBuffer 代表可变的字符序列，可以对字符串内容进行增删</li>
<li>很多方法与 StringBuffer 相同，但 StringBuffer 是可变长度的</li>
<li>StringBuffer 是一个容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//1.StringBuffer的直接父类是AbstractStringBuilder</span></span><br><span class="line"><span class="comment">//2.StringBuffer实现了序列化</span></span><br><span class="line"><span class="comment">//3.在父类中AbstractStringBuilder有属性char[] value，且不是final</span></span><br><span class="line"><span class="comment">//4.该value数组存放字符串内容，因此他是存放在堆中的</span></span><br><span class="line"><span class="comment">//5.StringBuffer是一个final类，不能被继承</span></span><br></pre></td></tr></table></figure>
<h3 id="string和stringbuffer的对比"><a class="markdownIt-Anchor" href="#string和stringbuffer的对比">#</a> String 和 StringBuffer 的对比</h3>
<ol>
<li>String 保存的是字符串常量，里面的值不能更改，每次 String 类的更新，实际上是更改地址，效率比较低</li>
<li>StringBuffer 保存的是字符串变量，里面的值可以修改，每次 StringBuffer 的更新实际上可以更新内容，不用每次更改地址，效率较高（空间大小不够的时候会扩容，也就会更改地址）</li>
</ol>
<h3 id="stingbuffer的构造器"><a class="markdownIt-Anchor" href="#stingbuffer的构造器">#</a> StingBuffer 的构造器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer()	<span class="comment">//创建一个大小为16的char[]，用于存放字符内容</span></span><br><span class="line"></span><br><span class="line">StringBuffer(CharSequence seq)	<span class="comment">//构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</span></span><br><span class="line"></span><br><span class="line">StringBuffer(<span class="type">int</span> capacity)	<span class="comment">//指定char[]的大小</span></span><br><span class="line">    </span><br><span class="line">StringBuffer(String str)	<span class="comment">//通过给一个String来创建StringBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="string和stringbuffer相互转换"><a class="markdownIt-Anchor" href="#string和stringbuffer相互转换">#</a> String 和 StringBuffer 相互转换</h3>
<h4 id="string-stringbuffer"><a class="markdownIt-Anchor" href="#string-stringbuffer">#</a> String —&gt; StringBuffer</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;helllo&quot;</span>;</span><br><span class="line"><span class="comment">//way 1</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//way 2</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">b2.appends(s);</span><br></pre></td></tr></table></figure>
<h4 id="stringbuffer-string"><a class="markdownIt-Anchor" href="#stringbuffer-string">#</a> StringBuffer —&gt; String</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//way 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> b1.toString(); <span class="comment">//b1是[StringBuffer]</span></span><br><span class="line"><span class="comment">//way 2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1);</span><br></pre></td></tr></table></figure>
<h3 id="stringbuffer类常见方法"><a class="markdownIt-Anchor" href="#stringbuffer类常见方法">#</a> StringBuffer 类常见方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">s.append(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">s.append(<span class="string">&quot;123&quot;</span>).append(<span class="number">100</span>).append(<span class="literal">true</span>).append(<span class="number">1.5</span>);</span><br><span class="line"><span class="comment">//删：左闭右开</span></span><br><span class="line">delete(start, end)</span><br><span class="line"><span class="comment">//改：将始终位置的内容替换为string，左闭右开</span></span><br><span class="line">replace(start, end, string)	</span><br><span class="line"><span class="comment">//查：查找子串在字符串第一次出现的索引，找不到返回-1</span></span><br><span class="line">indexOf()</span><br><span class="line"><span class="comment">//插：在指定位置插入字符串</span></span><br><span class="line">insert(pos, string)</span><br><span class="line"><span class="comment">//获取长度：</span></span><br><span class="line">length</span><br></pre></td></tr></table></figure>
<h2 id="stringbuilder类"><a class="markdownIt-Anchor" href="#stringbuilder类">#</a> StringBuilder 类</h2>
<ol>
<li>一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被<strong>单个线程</strong>使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快</li>
<li>在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据</li>
<li>StringBuilder 的常用方法和 StringBuffer 是一样的</li>
<li>StringBuilder 是 final 类，不能被继承</li>
<li>StringBuilder 对象字符序列也是存放在父类 AbstractStringBuilder 的 char [] value 中，所以也是存放在堆中</li>
<li>多线程使用有风险，源码中没有线程同步的操作，也就是没有 synchronized 关键字</li>
</ol>
<h2 id="stringstringbuffer和string-builder的对比"><a class="markdownIt-Anchor" href="#stringstringbuffer和string-builder的对比">#</a> String，StringBuffer 和 String Builder 的对比</h2>
<ol>
<li>
<p>String、StringBuffer 和 StringBuilder 都代表可变的字符序列，且方法一样</p>
</li>
<li>
<p>String：不可变字符序列，效率低，但是复用率高</p>
</li>
<li>
<p>StringBuffer：可变字符序列，效率较高（增删），线程安全</p>
</li>
<li>
<p>StringBuilder：可变字符序列，效率最高，但线程不安全</p>
</li>
<li>
<p>String 使用注意说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这串代码中，原本的字符串对象 &quot;a&quot; 是被丢弃了之后在产生的 &quot;ab&quot;，多次执行这种改变内容的操作会导致大量副本对象存留在内存中，降低效率，尤其是当这种操作在循环中时。所以在需要对 String 对象做大量的修改时，不要用 String</p>
</li>
</ol>
<h2 id="math类"><a class="markdownIt-Anchor" href="#math类">#</a> Math 类</h2>
<ol>
<li>
<p>abs 绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(-<span class="number">1</span>);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>pow 求幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//2的四次方</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ceil 向上取整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">ceil</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.001</span>);<span class="comment">//-3.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>floor 向下取整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">floor</span> <span class="operator">=</span> Math.floor(-<span class="number">4.99</span>);<span class="comment">//-5.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>round 四舍五入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">round</span> <span class="operator">=</span> Math.round(-<span class="number">5.001</span>);<span class="comment">//-5</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sqrt 开方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">9.0</span>)<span class="comment">//3.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>random 求随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">random</span> <span class="operator">=</span> Math.random();<span class="comment">//返回一个[0,1)之间的随机小鼠</span></span><br><span class="line"><span class="comment">//如果要让它取到一个设定范围内的整数，比如[2, 7]，可以这么写</span></span><br><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">2</span> + Math.random() * (<span class="number">7</span> - <span class="number">2</span> + <span class="number">1</span>));<span class="comment">//因为需要取整，所以右边需要加1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>max、min 求最值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="arrays类"><a class="markdownIt-Anchor" href="#arrays类">#</a> Arrays 类</h2>
<p>Arrays 类用于管理或操作数组（比如排序、搜索）</p>
<ol>
<li>
<p>toString：返回数组的字符串形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString(arr);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sort 排序：自然排序和定制排序（忘记了可看 p483）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序</span></span><br><span class="line">Integer arr[] = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">//定制排序，传入一个接口Comparator实现定制排序</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer o1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer o2);</span><br><span class="line">        <span class="keyword">return</span> i1 - i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//实现了Comparator接口的匿名内部类，要求实现compare方法</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>binarySearch：通过二分法进行查找，只能对有序数组使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>copyOf 数组元素复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] newArr = Arrays.copyOf(arr, arr.length);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fill：数组元素的填充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] num = <span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Arrays.fill(num, <span class="number">99</span>);<span class="comment">//将数组用99填充</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>equals：比较两个数组的元素内容是否完全一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">equals</span>  <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>asList：将一组值转换成 list</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; asList = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);<span class="comment">//asList会将这些数据转为一个List集合</span></span><br><span class="line">System.out.println(<span class="string">&quot;asList=&quot;</span> + asList);</span><br><span class="line"><span class="comment">//返回asList编译类型List(接口)</span></span><br><span class="line"><span class="comment">//asList的运行类型是java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="system类"><a class="markdownIt-Anchor" href="#system类">#</a> System 类</h2>
<ol>
<li>
<p>exit：退出当前程序</p>
</li>
<li>
<p>arraycopy：复制数组元素，比较适合底层调用，一般情况还是用 Arrays.copyOf。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//把src从第0个位置开始的元素，复制给dest，从0位置开始，复制3个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>currentTimeMillens：返回当前时间距离 1970-1-1 的毫秒数</p>
</li>
<li>
<p>gc：运行垃圾回收机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="biginteger和bigdecimal类"><a class="markdownIt-Anchor" href="#biginteger和bigdecimal类">#</a> BigInteger 和 BigDecimal 类</h2>
<ol>
<li>BigInteger 适合保存比较大的整型</li>
<li>BigDecimal 适合保存精度更高的浮点型？</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;15.156448946513165453&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;45.166431135&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>加减乘除不能直接用传统的方法，要用下面的方法来进行</p>
<h3 id="常见方法"><a class="markdownIt-Anchor" href="#常见方法">#</a> 常见方法</h3>
<ol>
<li>
<p>add</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> bigInteger.add(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">add</span> <span class="operator">=</span> bigdecimal.add(b);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>subtract：减</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">subtract</span> <span class="operator">=</span> bigInteger.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">subtract</span> <span class="operator">=</span> bigdecimal.subtract(b);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>multiply</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">multiply</span> <span class="operator">=</span> bigInteger.multiply(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">multiply</span> <span class="operator">=</span> bigdecimal.multiply(b);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>divide：除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">divide</span> <span class="operator">=</span> bigInteger.divide(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bigdecimal.divide(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在除法中可能会出现无限循环小数，这里可以指定精度：BigDecimal.ROUND_CELING</span></span><br><span class="line">System.out.println(<span class="string">&quot;bigDecimal.divide(b, a.ROUND_CELING)&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="日期类"><a class="markdownIt-Anchor" href="#日期类">#</a> 日期类</h2>
<ol>
<li>Date：精确到毫秒</li>
<li>SimpleDateFormat：格式和解析日期的类。它允许进行格式化（日期 -&gt; 文本），解析（文本 -&gt; 日期）和规范化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//默认输出格式一般是国外的惯用格式，这里可以格式化</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">day</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> day.format(d1);</span><br><span class="line">System.out.println(<span class="string">&quot;当前日期为：&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过毫秒数来指定此毫秒数对应的时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">923898</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以把一个格式化的String转换成对应的Date。(格式一定要正确)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> day.parse(s);</span><br></pre></td></tr></table></figure>
<h3 id="第二代日期类"><a class="markdownIt-Anchor" href="#第二代日期类">#</a> 第二代日期类</h3>
<ol>
<li>
<p>Calendar 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Calendar</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable, Comparable&lt;Calendar&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Calendar 类是一个抽象类，为 YEAR, MONTH, DAY_OF_MONTH, HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calendar是一个抽象类，且构造器是私有的，所以可以通过getInstance()来获取实例</span></span><br><span class="line"><span class="comment">//这个就比较灵活，可以需要什么就get什么，随意组合</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(c.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">System.out.println(c.get(Calendar.YEAR));</span><br><span class="line">System.out.println(c.get(Calendar.MONTH) + <span class="number">1</span>);<span class="comment">//月要加1，因为Calendar返回月的时候是从0开始编号的</span></span><br><span class="line">System.out.println(c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>
<h3 id="第三代日期类"><a class="markdownIt-Anchor" href="#第三代日期类">#</a> 第三代日期类</h3>
<p>JDK 1.0 中包含了一个 java.util.Date 类，但它的大多数方法已经在 JDK 1.1 引入 Calendar 类后被弃用了，而 Calendar 类也存在一些问题</p>
<ol>
<li>可变性：日期和时间这样的类应该是不可变的</li>
<li>偏移性：Date 中的年份是从 1900 年开始的，而月份都从 0 开始</li>
<li>格式化：格式化只对 Date 有用，Calendar 不可以</li>
<li>线程不安全，不能处理闰秒（每隔 2 天，多出 1s）</li>
</ol>
<h4 id="第三代日期类常见方法"><a class="markdownIt-Anchor" href="#第三代日期类常见方法">#</a> 第三代日期类常见方法</h4>
<p>LocalDate (日期 / 年月日)、LocalTime (时间 / 时分秒)、LocalDateTime (日期时间) JDK8 加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">System.out.println(ldt.getYear());</span><br><span class="line">System.out.println(ldt.getMonth());</span><br><span class="line">System.out.println(ldt.getDayOfMonth());</span><br><span class="line">System.out.println(ldt.getHour());</span><br></pre></td></tr></table></figure>
<h4 id="格式日期类datetimeformatter"><a class="markdownIt-Anchor" href="#格式日期类datetimeformatter">#</a> 格式日期类 DateTimeFormatter</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建一个DateTimeFormatter对象</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt)</span><br></pre></td></tr></table></figure>
<h4 id="时间戳"><a class="markdownIt-Anchor" href="#时间戳">#</a> 时间戳</h4>
<p>类似于 Date，提供了一系列和 Date 类转换的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">//通过方法转换：</span></span><br><span class="line"><span class="comment">//Instant --&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line"><span class="comment">//Date --&gt; Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>
<h4 id="更多方法"><a class="markdownIt-Anchor" href="#更多方法">#</a> 更多方法</h4>
<ol>
<li>LocalDateTime 类</li>
<li>MonthDay 类：检查重复事件</li>
<li>是否是闰年</li>
<li>增加日期的某个部分</li>
<li>使用 plus 方法增加时间的某个部分</li>
<li>使用 minus 方法查看一年前和一年后的日期</li>
</ol>
<h1 id="集合collection"><a class="markdownIt-Anchor" href="#集合collection">#</a> 集合（Collection）</h1>
<p>集合主要是两组，即单列集合和双列集合。</p>
<ol>
<li>Collection 接口有两个重要的子接口，List 和 Set，他们实现子类都是单列集合</li>
<li>Map 接口的实现子类是双列集合，存放 K-V</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">al.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">al.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;No.1&quot;</span>, <span class="string">&quot;tch&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;No.2&quot;</span>, <span class="string">&quot;hct&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="集合和数组的对比"><a class="markdownIt-Anchor" href="#集合和数组的对比">#</a> 集合和数组的对比</h2>
<p>数组：</p>
<ol>
<li>长度开始时必须指定，且指定后就不能修改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加元素的示意代码比较麻烦</li>
</ol>
<p>而集合：</p>
<ol>
<li>可以动态保存任意多个对象，使用比较方便</li>
<li>提供了一系列方便的操作对象的方法：add、remove、set、get 等</li>
<li>使用集合添加，删除新元素的示意代码，更加简洁</li>
</ol>
<h2 id="collection接口和常用方法"><a class="markdownIt-Anchor" href="#collection接口和常用方法">#</a> Collection 接口和常用方法</h2>
<h3 id="collection接口实现类的特点"><a class="markdownIt-Anchor" href="#collection接口实现类的特点">#</a> Collection 接口实现类的特点</h3>
<p><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code></p>
<ol>
<li>Collection 实现子类可以存放多个元素，每个元素可以是 Object</li>
<li>有些 Collection 的实现类，可以存放重复的元素，有些不可以</li>
<li>Collection 的实现类，有些是有序的（List），有些是无序的（Set）</li>
<li>Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</li>
</ol>
<h3 id="collection接口常用方法"><a class="markdownIt-Anchor" href="#collection接口常用方法">#</a> Collection 接口常用方法</h3>
<p>以实现子类 ArrayList 来演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>add：添加单个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;tch&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>remove：删除指定元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="number">0</span>);<span class="comment">//删除索引位置为0的元素</span></span><br><span class="line">list.remove(<span class="string">&quot;tch&quot;</span>);<span class="comment">//指定删除</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>contains：查找元素是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(<span class="string">&quot;tch&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>size：获取元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.size();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>isEmpty：判断是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.isEmpty();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>clear：清空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clear();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>addAll：添加多个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;tch2&quot;</span>);</span><br><span class="line">list.addAll(list2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>containsAll：查找多个元素是否都存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.containsAll(list2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>removeAll：删除多个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeAll(list2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="collection接口遍历元素方式"><a class="markdownIt-Anchor" href="#collection接口遍历元素方式">#</a> Collection 接口遍历元素方式</h3>
<h4 id="使用iterator迭代器"><a class="markdownIt-Anchor" href="#使用iterator迭代器">#</a> 使用 Iterator（迭代器）</h4>
<ol>
<li>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素</li>
<li>所有实现了 Collection 接口的集合类都有一个 iterator () 方法，用以返回一个实现了 Iterator 接口的对象，即可以返回一个迭代器</li>
<li>Iterator 仅用于遍历集合，Iterator 本身并不存放对象</li>
</ol>
<p><strong>工作原理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();<span class="comment">//得到一个集合的迭代器</span></span><br><span class="line"><span class="comment">//hasNext()判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//next()的作用：指针下移、将下移以后的位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;<span class="comment">//快捷键itit</span></span><br></pre></td></tr></table></figure>
<p>在调用 iterator.next () 方法之前必须要调用 iterator.hasNext () 进行检测，若不调用，且下一条记录无效时，直接调用 iterator.next () 会抛出 NoSuchElementException 异常</p>
<p>如果要再次使用，需要重置迭代器 <code>iterator = coll.iterator();</code></p>
<h4 id="使用for循环增强"><a class="markdownIt-Anchor" href="#使用for循环增强">#</a> 使用 for 循环增强</h4>
<p>增强 for 就是简化版的 iterator，本质一样，只能用于遍历集合或数组。底层其实就是迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">&#125;<span class="comment">//快捷键I</span></span><br></pre></td></tr></table></figure>
<h2 id="list接口和常用方法"><a class="markdownIt-Anchor" href="#list接口和常用方法">#</a> List 接口和常用方法</h2>
<p>List 接口是 Collection 接口的子接口</p>
<ol>
<li>List 集合类中元素有序（即添加顺序和取出顺序一致）且可重复</li>
<li>List 集合中的每个元素都有对应的顺序索引（索引从 0 开始）</li>
<li>List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li>
<li>常用的 List 接口的实现类：ArrayList、LinkedList、Vector</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, Object ele)</span><span class="comment">//在index位置插入ele元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection eles)</span><span class="comment">//从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span><span class="comment">//获取指定index位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object obj)</span><span class="comment">//返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastlndexOf</span><span class="params">(Object obj)</span><span class="comment">//返回obj在当前集合中末次出现的位置</span></span><br><span class="line">Object <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span><span class="comment">//移除指定 indiex位言的完素，井返回此元</span></span><br><span class="line">Object <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, Object ele)</span><span class="comment">//设置指定index位置的元素为ele，相当于是替换.</span></span><br><span class="line">List <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromlndex, <span class="type">int</span> tolndex)</span><span class="comment">//返回从fromlndex到tolndex位置的子集合</span></span><br></pre></td></tr></table></figure>
<p>List 和 ArrayList 的区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42002500/article/details/111088801">Java 中 List 和 ArrayList 的区别及使用_java list arraylist-CSDN 博客</a></p>
<h3 id="arraylist的底层结构和源码分析"><a class="markdownIt-Anchor" href="#arraylist的底层结构和源码分析">#</a> ArrayList 的底层结构和源码分析</h3>
<h4 id="注意事项-4"><a class="markdownIt-Anchor" href="#注意事项-4">#</a> 注意事项</h4>
<ol>
<li>permits all elements (可以放所有元素), including null。ArrayList 可以加入 null，并且可以加入多个</li>
<li>ArrayList 是由数组来实现数据存储的</li>
<li>ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全（但执行效率高），但在多线程情况下不建议使用 ArrayList</li>
</ol>
<h4 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析">#</a> 源码分析</h4>
<ol>
<li>ArrayList 中维护了一个 Object 类型的数组 elementData. ［debug 看源码］transient Objectil elementData;</li>
<li>当创建 ArrayList 对象时，如果使用的是<strong>无参构造器</strong>，则初始 elementData 容量为 0，第 1 次添加，则扩容 elementData 为 10，如需要再次扩容，则扩容 elementData 为 1.5 倍</li>
<li>如果使用的是<strong>指定大小的构造器</strong>，则初始 elementData 容量为指定大小，如果需要扩容，则直接扩容 elementData 为 1.5 倍</li>
</ol>
<h3 id="vector的底层结构和源码分析"><a class="markdownIt-Anchor" href="#vector的底层结构和源码分析">#</a> Vector 的底层结构和源码分析</h3>
<h4 id="注意事项-5"><a class="markdownIt-Anchor" href="#注意事项-5">#</a> 注意事项</h4>
<ol>
<li>
<p>Vector 类的定义说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Vector 底层也是一个对象数组， <code>protected Object[] elementData;</code></p>
</li>
<li>
<p>Vector 是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized</p>
</li>
<li>
<p>在开发中需要线程同步安全的，考虑使用 Vector</p>
</li>
</ol>
<h4 id="源码分析-2"><a class="markdownIt-Anchor" href="#源码分析-2">#</a> 源码分析</h4>
<ol>
<li>创建对象时，如果使用的无参构造器，默认容量为 10，满了之后按照 2 倍扩容</li>
<li>创建对象时，如果是指定大小，则每次直接按照 2 倍扩容</li>
</ol>
<h3 id="linklist的底层结构"><a class="markdownIt-Anchor" href="#linklist的底层结构">#</a> LinkList 的底层结构</h3>
<ol>
<li>LinkList 实现了双向链表和双端队列的特点</li>
<li>可以添加任意元素（可重复），包括 null</li>
<li>线程不安全，没有实现同步</li>
</ol>
<h4 id="底层操作机制"><a class="markdownIt-Anchor" href="#底层操作机制">#</a> 底层操作机制</h4>
<ol>
<li>LinkList 底层是一个双向链表</li>
<li>LinkList 中维护了两个属性 first 和 last 分别指向首结点和尾结点</li>
<li>每个结点 (Node 对象) 里面有维护了 prev、next、item 三个属性，其中 prev 指向前一个，next 指向后一个，实现双向链表</li>
<li>所以 LinkList 的元素的添加和删除，不是通过数组完成的，效率较高</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/12/06/java%E7%AC%94%E8%AE%B0/D:%5C%E6%96%87%E6%A1%A3%5CWPS%5C543277641%5CIMG_0027.PNG" alt="IMG_0027"></p>
<h3 id="arraylist和linkedlist的比较"><a class="markdownIt-Anchor" href="#arraylist和linkedlist的比较">#</a> ArrayList 和 LinkedList 的比较</h3>
<p><strong>如何选择：</strong></p>
<ol>
<li>改查多，选 ArrayList</li>
<li>增删多，选 LinkedList</li>
<li>一般来说在程序中，80％-90％都是查询，因此大部分情况下会选择 ArrayList</li>
<li>在一个项目中根据业务灵活选择，也有可能一个模块使用的是 ArrayList，另一个模块是 LinkedList</li>
</ol>
<h2 id="set接口和常用方法"><a class="markdownIt-Anchor" href="#set接口和常用方法">#</a> Set 接口和常用方法</h2>
<ol>
<li>无序，没有索引</li>
<li>不允许重复元素，所以最多包含一个 null</li>
<li>JDK API 中 set 接口的实现类有 HashSet、TreeSet 等等</li>
<li>set 接口对象不能通过索引来获取，且没有 get 方法，所以不能用普通 for 循环遍历</li>
</ol>
<h3 id="hashset"><a class="markdownIt-Anchor" href="#hashset">#</a> HashSet</h3>
<ol>
<li>HashSet 实现了 Set 接口，可存放 null 但只能有一个</li>
<li>HashSet 实际上是 HashMap</li>
<li>HashSet 不抱着元素是有序的，取决于 hash 后，在确定索引的结果</li>
<li>不能有重复对象</li>
</ol>
<h4 id="方法注意事项"><a class="markdownIt-Anchor" href="#方法注意事项">#</a> 方法注意事项</h4>
<ol>
<li>add 方法在执行后会返回一个 boolean 值，如果添加成功返回 true，反之返回 false</li>
<li>可以通过 remove 指定删除对象</li>
</ol>
<h4 id="hashset底层机制"><a class="markdownIt-Anchor" href="#hashset底层机制">#</a> HashSet 底层机制</h4>
<p>HashSet 底层是 HashMap，HashMap 底层是数组 + 链表 + 红黑树</p>
<ol>
<li>添加一个元素时，先得到 hash 值，再转成索引值</li>
<li>找到储存数据表 table，看这个索引位置是否已经存放的有元素</li>
<li>如果没有直接加入</li>
<li>如果有，就调用 equals 比较，如果相同就放弃添加，反之添加到最后</li>
<li>在 java8 中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD (默认是 8)，且 table 的大小 &gt;=MIN_TREEIFY_CAPACITY (默认 64)，就会进行树化（红黑树）</li>
</ol>
<p><strong>扩容机制：</strong></p>
<ol>
<li>第一次添加时，table 扩容到 16，临界值 (threshold) 是 16 * 加载因子 (loadFactor)，加载因子 = 0.75，结果就是 12</li>
<li>如果 table 数组使用到了临界值 12，就会扩容到 <code>16*2=32</code> ，新的临界值就是 <code>32*0.75</code> ，以此类推</li>
<li>在 java8 中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD (默认是 8)，并且 table 的大小 &gt;=MIN_TREEIFY_CAPACITY (默认 64)，就会进行树化（红黑树），否则仍然采用数组扩容机制</li>
<li>要注意的是，在一个 table 中只要添加了 0.75 倍的 Node，就会进行扩容，无论是添加到某个结点，还是某个结点的链表上</li>
</ol>
<h3 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset">#</a> LinkedHashSet</h3>
<ol>
<li>LinkedHashSet 是 HashSet 的子类</li>
<li>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个数组 + 双向链表</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的储存位置，同时使用链表维护元素的次序 (图)，这使得元素看起来是以插入顺序保存的</li>
<li>LinkedHashSet 不允许添加重复元素</li>
</ol>
<h3 id="treeset"><a class="markdownIt-Anchor" href="#treeset">#</a> TreeSet</h3>
<p>//////</p>
<h1 id="图map"><a class="markdownIt-Anchor" href="#图map">#</a> 图（Map）</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;no1&quot;</span>, <span class="string">&quot;tch1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;no2&quot;</span>, <span class="string">&quot;tch2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;no1&quot;</span>, <span class="string">&quot;tch3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;no3&quot;</span>, <span class="string">&quot;tch1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Map 接口实现类的特点：</strong></p>
<ol>
<li>Map 与 Collection 并列存在，用于保存具有映射关系的数据：Key-Value</li>
<li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中</li>
<li>Map 中的 key 不允许重复，原因和 HashSet 一样（当 key 相同时，新的那个 key 的 value 会替换旧的 key 的 value）</li>
<li>Map 中的 value 可以重复</li>
<li>Map 的 key 可以为 null，value 也可以为 null，但 key 为 null 只能有一个，而 value 可以有多个</li>
<li>常用 String 类作为 Map 的 key</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 能找到对应的 value（用 get 方法，通过 key 值查找）</li>
<li>一对 k-v 是放在一个 Node 中的，因为 Node 实现了 Entry 接口（有些书上说，一对 k-v 就是一个 Entry）</li>
</ol>
<h2 id="对mapentry的解释"><a class="markdownIt-Anchor" href="#对mapentry的解释">#</a> 对 Map.Entry 的解释</h2>
<p>Map.Entry 是 Map 中的一个接口，他的用途是表示一个映射项（里面有 Key 和 Value），而 Set&lt;Map.Entry&lt;K,V&gt;&gt; 表示一个映射项的 Set。Map.Entry 里有相应的 getKey 和 getValue 方法，即<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JavaBean&amp;spm=1001.2101.3001.7020"> JavaBean</a>，让我们能够从一个项中取出 Key 和 Value。</p>
<p>因为 Map 这个类没有继承 Iterable 接口，所以不能直接通过 map.<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=iterator&amp;spm=1001.2101.3001.7020">iterator</a> 来遍历，所以就只能先转化为 set 类型，用 entrySet () 方法，其中 set 中的每一个元素值就是 map 中的一个键值对，也就是 Map.Entry&lt;K,V&gt; 了，然后就可以遍历了。</p>
<hr>
<p>Map 是 java 中的接口，Map.Entry 是 Map 的一个内部接口。</p>
<p>Map 提供了一些常用方法，如 keySet ()、entrySet () 等方法，keySet () 方法返回值是 Map 中 key 值的集合；entrySet () 的返回值也是返回一个 Set 集合，此集合的类型为 Map.Entry。</p>
<p>Map.Entry 是 Map 声明的一个内部接口，此接口为泛型，定义为 Entry&lt;K,V&gt;。它表示 Map 中的一个实体（一个 key-value 对）。接口中有 getKey (),getValue 方法</p>
<p>Node&lt;K,V&gt; 实现了 Entry 接口，Entry 接口中 K 表示 key, 即键，V 表示 value, 即值。Entry 即 Node 是 Map 集合中的一个对象元素，而 Map 集合正是由一个个 Entry 即 Node 对象所构成。<br>
正是因为 Node 实现了 Entry 接口，所以使用 Entry 的时候也可以使用其 getValue () 和 getKey () 方法</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/12/06/java%E7%AC%94%E8%AE%B0/D:%5CDesktop%5C4bc77e5417f181b4c06b18ae3162ff47.png" alt="1"><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39736597/article/details/113762355">Java 中 Map.Entry 详解_java map.entry-CSDN 博客</a></p>
<h2 id="map接口的常用方法"><a class="markdownIt-Anchor" href="#map接口的常用方法">#</a> Map 接口的常用方法</h2>
<ol>
<li>put：添加</li>
<li>remove：根据键删除</li>
<li>get：根据键获取</li>
<li>size：元素个数</li>
<li>isEmpty：判断是否为空</li>
<li>clear：清除</li>
<li>containsKey：查找键是否存在</li>
</ol>
<h2 id="map接口遍历方法"><a class="markdownIt-Anchor" href="#map接口遍历方法">#</a> Map 接口遍历方法</h2>
<ol>
<li>
<p>containsKey：查找键是否存在</p>
</li>
<li>
<p>keySet：获取所有键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一组：先取出所有key，再通过key取出对应的value</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : set) &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2)迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">        System.out.println(next + <span class="string">&quot;:&quot;</span> + map.get(next));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>values：获取所有值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二组：取出所有的value</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2)迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>entrySet：获取所有关系 k-v</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三组：通过EntrySet获取k-v</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();<span class="comment">//EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line">    <span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">        <span class="comment">//将entry对象转成Map.Entry</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">        System.out.println(m.getKey() + <span class="string">&quot;:&quot;</span> + m.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2)迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">        <span class="comment">//向下转型Map.Entry</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">        System.out.println(m.getKey() + <span class="string">&quot;:&quot;</span> + m.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable">#</a> Hashtable</h2>
<ol>
<li>存放元素是键值对：k-v</li>
<li>hashtable 的键和值哦都不能为 null</li>
<li>hashTable 使用方法基本和 HashMap 一样</li>
<li>hashTable 线程安全，hashMap 线程不安全</li>
</ol>
<h3 id="底层"><a class="markdownIt-Anchor" href="#底层">#</a> 底层</h3>
<ol>
<li>底层数组 Hashtable$Entry [] 初始化大小为 11</li>
<li>临界值 threshold 8 = 11 * 0.75</li>
<li>用方法 addEntry (hash, key, value, index) 添加 k-v，封装到 entry</li>
<li>当 if (count&gt;= threshold) 满足时进行扩容</li>
</ol>
<h2 id="properties"><a class="markdownIt-Anchor" href="#properties">#</a> Properties</h2>
<ol>
<li>properties 类继承自 Hashtable 类，且实现了 Map 接口，也是使用键值对来储存数据</li>
<li>使用特点和 Hashtable 类似</li>
<li>properties 可以用于从 xxx.properties 文件中加载数据到 Properties 类对象，并进行读取和修改</li>
</ol>
<h2 id="开发时如何选择"><a class="markdownIt-Anchor" href="#开发时如何选择">#</a> 开发时如何选择</h2>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名 - 非商业性使用 - 相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/12/03/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">博客迁移</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">阿翰</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text"> java 运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text"> 注意事项：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text"> 转义字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-text"> 文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-text"> 用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8javadoc%E6%A0%87%E7%AD%BE"><span class="toc-text"> 常用 javadoc 标签</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%86%E8%8A%82"><span class="toc-text"> 数据类型转换细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 自动转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 强制转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="toc-text"> 位移运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 动态初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 静态初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-text"> 扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text"> 二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%84%E5%88%99"><span class="toc-text"> 创建规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-text"> 类和对象的内存分配机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90"><span class="toc-text"> 创建对象的流程简单分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text"> 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text"> 如何创建和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-text"> 方法调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="toc-text"> 一些细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text"> 传参机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text"> 递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text"> 方法重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text"> 可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text"> 基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> 构造器 &#x2F; 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> this 关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-text"> 包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text"> 作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text"> 命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-text"> 常用的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-2"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text"> 访问修饰符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85encapsulation"><span class="toc-text"> 封装 encapsulation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text"> 封装的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text"> 封装的实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getter%E5%92%8Csetter"><span class="toc-text"> Getter 和 Setter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-text"> 作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text"> 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text"> 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-3"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> super 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-text"> 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-4"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E8%A6%86%E7%9B%96override"><span class="toc-text"> 方法重写 &#x2F; 覆盖 (override)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text"> 注意事项和使用细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text"> 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text"> 方法的多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text"> 对象的多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-text"> 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text"> 多态向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text"> 向下转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-text"> java 动态绑定机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text"> 多态数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text"> 多态参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-text"> Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"> &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals"><span class="toc-text"> equals()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="toc-text"> hashCode 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tostring%E6%96%B9%E6%B3%95"><span class="toc-text"> toString 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize%E6%96%B9%E6%B3%95"><span class="toc-text"> finalize 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-text"> 断点调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text"> 快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text"> 类变量和类方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-text"> main 方法语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text"> 代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text"> 代码块的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-5"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text"> 单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text"> 饿汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text"> 懒汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text"> 两者区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> final 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-text"> 注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text"> 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-6"><span class="toc-text"> 细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="toc-text"> 抽象模板模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text"> 主要解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text"> 优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-7"><span class="toc-text"> 细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text"> 接口和继承的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text"> 接口的多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text"> 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text"> 局部内部类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-8"><span class="toc-text"> 细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-text"> 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text"> 成员内部类的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text"> 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-text"> 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-9"><span class="toc-text"> 细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> enum 常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text"> enum 实现接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text"> 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#override"><span class="toc-text"> @Override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deprecated"><span class="toc-text"> @Deprecated</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suppresswarnings"><span class="toc-text"> @SuppressWarnings</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8exception"><span class="toc-text"> 异常 Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text"> 异常的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-text"> 异常体系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-text"> 异常处理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally"><span class="toc-text"> try-catch-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws"><span class="toc-text"> throws</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text"> 自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text"> throw 和 throws 的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text"> 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BBwrapper"><span class="toc-text"> 包装类 Wrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 包装类的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 包装类和基本数据类型的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8Cstring%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 包装类型和 String 类型的相互转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#integer%E7%B1%BB%E5%92%8Ccharacter%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Integer 类和 Character 类的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#integer%E7%B1%BB"><span class="toc-text"> Integer 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB"><span class="toc-text"> String 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAstring%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text"> 创建 String 对象的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-text"> 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-text"> String 对象特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text"> String 类的常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringbuffer%E7%B1%BB"><span class="toc-text"> StringBuffer 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8Cstringbuffer%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text"> String 和 StringBuffer 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stingbuffer%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text"> StingBuffer 的构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8Cstringbuffer%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text"> String 和 StringBuffer 相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string-stringbuffer"><span class="toc-text"> String —&gt; StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringbuffer-string"><span class="toc-text"> StringBuffer —&gt; String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringbuffer%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text"> StringBuffer 类常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringbuilder%E7%B1%BB"><span class="toc-text"> StringBuilder 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringstringbuffer%E5%92%8Cstring-builder%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text"> String，StringBuffer 和 String Builder 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#math%E7%B1%BB"><span class="toc-text"> Math 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrays%E7%B1%BB"><span class="toc-text"> Arrays 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system%E7%B1%BB"><span class="toc-text"> System 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#biginteger%E5%92%8Cbigdecimal%E7%B1%BB"><span class="toc-text"> BigInteger 和 BigDecimal 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text"> 常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text"> 日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text"> 第二代日期类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text"> 第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text"> 第三代日期类常见方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BBdatetimeformatter"><span class="toc-text"> 格式日期类 DateTimeFormatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text"> 时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="toc-text"> 更多方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88collection"><span class="toc-text"> 集合（Collection）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text"> 集合和数组的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Collection 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#collection%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text"> Collection 接口实现类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Collection 接口常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%E6%96%B9%E5%BC%8F"><span class="toc-text"> Collection 接口遍历元素方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 使用 Iterator（迭代器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA"><span class="toc-text"> 使用 for 循环增强</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> List 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text"> ArrayList 的底层结构和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-text"> 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text"> 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text"> Vector 的底层结构和源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-text"> 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="toc-text"> 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linklist%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text"> LinkList 的底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text"> 底层操作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E5%92%8Clinkedlist%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text"> ArrayList 和 LinkedList 的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Set 接口和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset"><span class="toc-text"> HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text"> 方法注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashset%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-text"> HashSet 底层机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedhashset"><span class="toc-text"> LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeset"><span class="toc-text"> TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BEmap"><span class="toc-text"> 图（Map）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9mapentry%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text"> 对 Map.Entry 的解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text"> Map 接口的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text"> Map 接口遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable"><span class="toc-text"> Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-text"> 底层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#properties"><span class="toc-text"> Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%97%B6%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text"> 开发时如何选择</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
